<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>æˆ°éš 40K ç¬¬åç‰ˆï¼šå®˜æ–¹è¦å‰‡æˆ°æ£‹æ¨¡æ“¬å™¨</title>
<style>
:root {
  --bg: #0a0e14;
  --panel: #111827;
  --panel2: #0f172a;
  --line: #1e3a5f;
  --txt: #e5e7eb;
  --muted: #9ca3af;
  --gold: #fbbf24;
  --red: #ef4444;
  --blue: #3b82f6;
  --green: #22c55e;
}

* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; font-family: "Microsoft JhengHei", "Noto Sans TC", sans-serif; background: var(--bg); color: var(--txt); overflow: hidden; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }

/* ===== éŠæˆ²ç•«é¢ ===== */
.game-screen { display: none; height: 100dvh; min-height: 100dvh; flex-direction: column; }
.game-screen.active { display: flex; }

/* Header */
.game-header {
  padding: 8px 16px;
  background: linear-gradient(180deg, #1a1a2e, transparent);
  border-bottom: 1px solid var(--line);
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.game-title { font-size: 16px; color: var(--gold); }
.phase-indicator {
  display: flex;
  gap: 4px;
}
.phase-pip {
  padding: 4px 10px;
  font-size: 11px;
  border-radius: 4px;
  background: rgba(255,255,255,0.1);
  color: var(--muted);
}
.phase-pip.active { background: var(--gold); color: #000; font-weight: bold; }
.phase-pip.done { background: var(--green); color: #000; }

/* Main Layout */
.game-main {
  flex: 1;
  display: flex;
  overflow: hidden;
}

/* Flexbox å…§å®¹è£åˆ‡ä¿®æ­£ï¼šå…è¨±å­å±¤å®¹å™¨æ­£ç¢ºæ»¾å‹•ï¼ˆé¿å…è¢«ç ï¼‰ */
.game-main, .units-panel, .battlefield-container, .info-panel, .combat-log { min-height: 0; }
.units-panel, .battlefield-container, .info-panel { min-width: 0; }
.units-list, .log-content { min-height: 0; }
.selected-unit-info { max-height: 45%; overflow: auto; }
.battlefield-wrap { min-height: 0; }


/* Left Panel - Units */
.units-panel {
  width: 280px;
  background: var(--panel);
  border-right: 1px solid var(--line);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.panel-header {
  padding: 10px 12px;
  font-size: 13px;
  color: var(--gold);
  border-bottom: 1px solid var(--line);
  display: flex;
  justify-content: space-between;
}
.units-list {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.unit-item {
  display: flex;
  gap: 8px;
  padding: 8px;
  margin-bottom: 6px;
  background: rgba(0,0,0,0.3);
  border: 2px solid transparent;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
}
.unit-item:hover { background: rgba(255,255,255,0.05); }
.unit-item.selected { border-color: var(--gold); background: rgba(251,191,36,0.1); }
.unit-item.enemy { border-color: var(--red); }
.unit-item.dead { opacity: 0.4; pointer-events: none; }
.unit-item.acted { opacity: 0.6; }

.unit-avatar {
  width: 48px;
  height: 48px;
  border-radius: 6px;
  background: #1a1a2e;
  overflow: hidden;
  flex-shrink: 0;
}
.unit-avatar img { width: 100%; height: 100%; object-fit: cover; }

.unit-info { flex: 1; min-width: 0; }
.unit-name { font-size: 12px; font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.unit-stats-mini { font-size: 10px; color: var(--muted); margin-top: 2px; }
.unit-hp-bar { height: 4px; background: #1a1a2e; border-radius: 2px; margin-top: 4px; overflow: hidden; }
.unit-hp-fill { height: 100%; background: linear-gradient(90deg, var(--red), var(--green)); transition: width 0.3s; }

/* Center - Battlefield */
.battlefield-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.battlefield-toolbar {
  padding: 8px 12px;
  background: var(--panel);
  border-bottom: 1px solid var(--line);
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
}
.toolbar-btn {
  padding: 6px 12px;
  font-size: 12px;
  border: 1px solid var(--line);
  background: rgba(255,255,255,0.05);
  color: var(--txt);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
}
.toolbar-btn:hover { background: rgba(255,255,255,0.1); }
.toolbar-btn.primary { background: var(--blue); border-color: var(--blue); }
.toolbar-btn.danger { background: var(--red); border-color: var(--red); }
.toolbar-btn.success { background: var(--green); border-color: var(--green); color: #000; }
.toolbar-btn:disabled { opacity: 0.4; cursor: not-allowed; }

.action-hint {
  margin-left: auto;
  font-size: 12px;
  color: var(--gold);
  padding: 4px 10px;
  background: rgba(251,191,36,0.1);
  border-radius: 4px;
}

.battlefield-wrap {
  flex: 1;
  position: relative;
  overflow: auto;
  min-height: 200px;
  background: linear-gradient(135deg, #1a2a1a 0%, #0f1a0f 100%);
  display: flex;
  align-items: center;
  justify-content: center;
}
#gameCanvas {
  display: block;
  border: none;
  box-shadow: 0 0 20px rgba(0,0,0,0.5);
}

/* Right Panel - Info & Log */
.info-panel {
  width: 320px;
  background: var(--panel);
  border-left: 1px solid var(--line);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.selected-unit-info {
  padding: 12px;
  border-bottom: 1px solid var(--line);
}
.selected-unit-header {
  display: flex;
  gap: 12px;
  margin-bottom: 10px;
}
.selected-avatar {
  width: 64px;
  height: 64px;
  border-radius: 8px;
  overflow: hidden;
  background: #1a1a2e;
}
.selected-avatar img { width: 100%; height: 100%; object-fit: cover; }
.selected-details { flex: 1; }
.selected-name { font-size: 14px; font-weight: bold; color: var(--gold); }
.selected-faction { font-size: 11px; color: var(--muted); }

.stats-grid {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 4px;
  margin-top: 10px;
}
.stat-cell {
  text-align: center;
  padding: 6px 4px;
  background: rgba(0,0,0,0.3);
  border-radius: 4px;
}
.stat-label { font-size: 9px; color: var(--muted); }
.stat-value { font-size: 14px; font-weight: bold; }

.weapons-section {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--line);
}
.weapon-item {
  padding: 6px 8px;
  margin-bottom: 4px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  font-size: 11px;
}
.weapon-name { color: var(--gold); font-weight: bold; }
.weapon-stats { color: var(--muted); margin-top: 2px; }

.combat-log {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.log-content {
  flex: 1;
  overflow-y: auto;
  padding: 10px;
  font-size: 11px;
  line-height: 1.6;
  font-family: Consolas, monospace;
}
.log-entry { margin-bottom: 4px; padding: 2px 6px; border-left: 2px solid var(--line); }
.log-entry.hit { border-color: var(--green); color: #86efac; }
.log-entry.miss { border-color: var(--red); color: #fca5a5; }
.log-entry.damage { border-color: #f97316; color: #fdba74; }
.log-entry.phase { border-color: var(--gold); color: var(--gold); font-weight: bold; }
.log-entry.info { border-color: var(--blue); color: #93c5fd; }

/* ===== éª°å­è¦–è¦ºåŒ– ===== */
.dice-overlay {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.9);
  border: 3px solid var(--gold);
  border-radius: 16px;
  padding: 20px 30px;
  z-index: 1000;
  display: none;
  flex-direction: column;
  align-items: center;
  gap: 15px;
  min-width: 300px;
  box-shadow: 0 0 40px rgba(251, 191, 36, 0.3);
}
.dice-overlay.active { display: flex; animation: dicePopIn 0.3s ease-out; }
@keyframes dicePopIn {
  from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
  to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
}
.dice-title {
  font-size: 14px;
  color: var(--gold);
  text-transform: uppercase;
  letter-spacing: 2px;
}
.dice-container {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center;
  max-width: 400px;
}
.dice {
  width: 48px;
  height: 48px;
  background: linear-gradient(135deg, #2a2a3a, #1a1a2a);
  border: 2px solid #444;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  font-weight: bold;
  color: #fff;
  transition: all 0.3s;
  position: relative;
}
.dice.rolling { animation: diceRoll 0.1s infinite; }
@keyframes diceRoll {
  0%, 100% { transform: rotate(-5deg); }
  50% { transform: rotate(5deg); }
}
.dice.success { border-color: var(--green); color: var(--green); box-shadow: 0 0 10px rgba(34, 197, 94, 0.5); }
.dice.fail { border-color: var(--red); color: var(--red); opacity: 0.6; }
.dice.critical { border-color: var(--gold); color: var(--gold); box-shadow: 0 0 15px rgba(251, 191, 36, 0.7); animation: diceCrit 0.5s ease-out; }
@keyframes diceCrit {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.2); }
}
.dice-result {
  font-size: 18px;
  color: var(--txt);
  text-align: center;
}
.dice-result .success-count { color: var(--green); font-weight: bold; }
.dice-result .fail-count { color: var(--red); }

/* Score Bar */
.score-bar {
  padding: 8px 12px;
  background: rgba(0,0,0,0.3);
  border-top: 1px solid var(--line);
  display: flex;
  justify-content: space-around;
  font-size: 12px;
}
.score-item { text-align: center; }
.score-label { color: var(--muted); font-size: 10px; }
.score-value { font-size: 16px; font-weight: bold; color: var(--gold); }

/* ===== è»è¡¨é…ç½®ç•«é¢ ===== */
.setup-screen {
  height: 100vh;
  background: radial-gradient(ellipse at 30% 20%, #1a2340 0%, var(--bg) 60%);
  overflow-y: auto;
  padding: 20px;
}

.setup-header {
  text-align: center;
  margin-bottom: 30px;
}
.setup-header h1 {
  font-size: 32px;
  color: var(--gold);
  text-shadow: 0 0 20px rgba(251,191,36,0.3);
}
.setup-header p {
  color: var(--muted);
  margin-top: 8px;
}

.setup-container {
  max-width: 1400px;
  margin: 0 auto;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
}

.army-builder {
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 16px;
}
.army-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--line);
}
.army-title { font-size: 16px; font-weight: bold; }
.army-title.player1 { color: var(--blue); }
.army-title.player2 { color: var(--red); }
.points-display {
  font-size: 14px;
  padding: 4px 12px;
  background: rgba(0,0,0,0.3);
  border-radius: 6px;
}

.faction-select {
  margin-bottom: 16px;
}
.faction-select label {
  display: block;
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 6px;
}
.faction-select select {
  width: 100%;
  padding: 8px 12px;
  background: rgba(0,0,0,0.3);
  border: 1px solid var(--line);
  border-radius: 6px;
  color: var(--txt);
  font-size: 14px;
}

.available-units {
  margin-bottom: 16px;
}
.available-units h4 {
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 8px;
}
.unit-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 8px;
  max-height: 300px;
  overflow-y: auto;
}
.unit-option {
  display: flex;
  gap: 8px;
  padding: 8px;
  background: rgba(0,0,0,0.2);
  border: 1px solid var(--line);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
}
.unit-option:hover { background: rgba(255,255,255,0.05); border-color: var(--gold); }
.unit-option img {
  width: 40px;
  height: 40px;
  border-radius: 4px;
  object-fit: cover;
}
.unit-option-info { flex: 1; }
.unit-option-name { font-size: 11px; font-weight: bold; }
.unit-option-cost { font-size: 10px; color: var(--gold); }

.selected-roster {
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  padding: 12px;
  min-height: 150px;
}
.selected-roster h4 {
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 8px;
}
.roster-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 8px;
  background: rgba(255,255,255,0.05);
  border-radius: 4px;
  margin-bottom: 4px;
  font-size: 12px;
}
.roster-item .remove-btn {
  background: var(--red);
  border: none;
  color: #fff;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 14px;
  line-height: 1;
}

.setup-actions {
  text-align: center;
  margin-top: 30px;
}
.start-game-btn {
  padding: 16px 48px;
  font-size: 18px;
  background: linear-gradient(135deg, #dc2626, #991b1b);
  border: 2px solid var(--gold);
  color: var(--gold);
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.2s;
}
.start-game-btn:hover { transform: scale(1.05); }
.start-game-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

/* Terrain Legend */
.terrain-legend {
  margin-top: 20px;
  padding: 12px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
}
.terrain-legend h4 { font-size: 12px; color: var(--gold); margin-bottom: 8px; }
.terrain-item {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
  font-size: 11px;
}
.terrain-color {
  width: 16px;
  height: 16px;
  border-radius: 4px;
}

/* Responsive */
@media (max-width: 1200px) {
  .units-panel, .info-panel { width: 240px; }
}
@media (max-width: 900px) {
  .game-main { flex-direction: column; }
  .units-panel, .info-panel { width: 100%; height: auto; max-height: 200px; }
  .setup-container { grid-template-columns: 1fr; }
}
</style>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-database-compat.js"></script>
</head>
<body>

<!-- ===== è»è¡¨é…ç½®ç•«é¢ ===== -->
<div class="setup-screen" id="setupScreen">
  <div class="setup-header">
    <h1>âš”ï¸ æˆ°éš 40,000 âš”ï¸</h1>
    <p>ç¬¬åç‰ˆæ ¸å¿ƒè¦å‰‡ - è»è¡¨é…ç½®</p>
    <p style="font-size: 11px; color: #666; margin-top: 4px;">ç‰ˆæœ¬ 1.1.0 (2026-02-07)</p>
  </div>

  <!-- é€£ç·šå°æˆ°é¸é … -->
  <div style="max-width: 600px; margin: 0 auto 20px; padding: 15px; background: rgba(59,130,246,0.15); border: 1px solid var(--blue); border-radius: 10px;">
    <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; justify-content: center; margin-bottom: 10px;">
      <span style="font-weight: bold; color: var(--blue); font-size: 16px;">ğŸŒ éŠæˆ²æ¨¡å¼</span>
      <select id="gameMode" onchange="switchGameMode(this.value)" style="padding: 8px 12px; background: var(--panel); border: 1px solid var(--line); border-radius: 6px; color: var(--txt); font-size: 14px;">
        <option value="local">æœ¬åœ°å°æˆ° / AI</option>
        <option value="online">ç·šä¸Šå°æˆ°</option>
      </select>
    </div>

    <!-- ç·šä¸Šå°æˆ°é¢æ¿ -->
    <div id="onlinePanel" style="display: none; margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px;">
      <div id="roomLobby">
        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
          <button onclick="createRoom()" style="padding: 12px 24px; background: linear-gradient(135deg, #22c55e, #16a34a); border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 14px;">
            â• å»ºç«‹æˆ¿é–“
          </button>
          <div style="display: flex; gap: 5px;">
            <input type="text" id="joinRoomCode" placeholder="è¼¸å…¥æˆ¿é–“ç¢¼" maxlength="6" style="width: 120px; padding: 12px; background: var(--panel); border: 1px solid var(--line); border-radius: 8px; color: var(--txt); text-align: center; font-size: 16px; text-transform: uppercase;">
            <button onclick="joinRoom()" style="padding: 12px 24px; background: linear-gradient(135deg, #3b82f6, #2563eb); border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 14px;">
              ğŸšª åŠ å…¥
            </button>
          </div>
        </div>
      </div>

      <!-- æˆ¿é–“è³‡è¨Šï¼ˆå»ºç«‹/åŠ å…¥å¾Œé¡¯ç¤ºï¼‰ -->
      <div id="roomInfo" style="display: none; text-align: center;">
        <div style="font-size: 14px; color: var(--muted); margin-bottom: 10px;">æˆ¿é–“ç¢¼</div>
        <div id="roomCodeDisplay" style="font-size: 32px; font-weight: bold; color: var(--gold); letter-spacing: 8px; margin-bottom: 10px;"></div>
        <div id="roomStatus" style="font-size: 14px; color: var(--green);">ç­‰å¾…å°æ‰‹åŠ å…¥...</div>
        <button onclick="leaveRoom()" style="margin-top: 15px; padding: 8px 16px; background: rgba(239,68,68,0.2); border: 1px solid var(--red); border-radius: 6px; color: var(--red); cursor: pointer;">é›¢é–‹æˆ¿é–“</button>
      </div>
    </div>
  </div>

  <!-- é»æ•¸ä¸Šé™è¨­å®š -->
  <div style="max-width: 600px; margin: 0 auto 20px; padding: 15px; background: rgba(251,191,36,0.1); border: 1px solid var(--gold); border-radius: 10px;">
    <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; justify-content: center;">
      <label style="font-weight: bold; color: var(--gold);">âš¡ é»æ•¸ä¸Šé™:</label>
      <input type="range" id="maxPointsSlider" min="500" max="3000" step="250" value="1000"
             onchange="updateMaxPoints(this.value)" style="flex: 1; min-width: 150px; max-width: 300px;">
      <span style="font-size: 20px; font-weight: bold; color: var(--gold); min-width: 80px;" id="maxPointsDisplay">1000</span>
      <select id="maxPointsPreset" onchange="setPointsPreset(this.value)" style="padding: 6px 10px; background: var(--panel); border: 1px solid var(--line); border-radius: 6px; color: var(--txt);">
        <option value="500">Combat Patrol (500)</option>
        <option value="1000" selected>Incursion (1000)</option>
        <option value="2000">Strike Force (2000)</option>
        <option value="3000">Onslaught (3000)</option>
      </select>
    </div>
  </div>

  <div class="setup-container">
    <!-- ç©å®¶ä¸€è»è¡¨ -->
    <div class="army-builder" id="army1Builder">
      <div class="army-header">
        <span class="army-title player1">ğŸ‘¤ <span id="p1ModeLabel">ç©å®¶ä¸€</span></span>
        <span class="points-display">é»æ•¸: <span id="p1Points">0</span> / <span class="max-pts">1000</span></span>
      </div>

      <div class="ai-toggle" style="margin-bottom: 12px; padding: 10px; background: rgba(59,130,246,0.1); border: 1px solid var(--blue); border-radius: 8px;">
        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
          <input type="checkbox" id="ai1ModeToggle" onchange="toggleAI1Mode()" style="width: 18px; height: 18px;">
          <span style="font-size: 14px; font-weight: bold; color: var(--blue);">ğŸ¤– AIæ§åˆ¶</span>
        </label>
        <div id="ai1DifficultyWrapper" style="margin-top: 8px; display: none;">
          <label style="font-size: 11px; color: var(--muted);">AI-1é›£åº¦ï¼š</label>
          <select id="ai1Difficulty" style="padding: 4px 8px; background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 4px; color: var(--txt); font-size: 12px;">
            <option value="easy">ç°¡å–® - éš¨æ©Ÿè¡Œå‹•</option>
            <option value="normal" selected>æ™®é€š - åŸºæœ¬ç­–ç•¥</option>
            <option value="hard">å›°é›£ - é€²éšç­–ç•¥</option>
          </select>
        </div>
      </div>

      <div class="faction-select">
        <label>é¸æ“‡é™£ç‡Ÿ</label>
        <select id="p1Faction" onchange="updateAvailableUnits(1); updateDetachmentOptions(1);">
          <option value="space-marines">æ˜Ÿéš›æˆ°å£« Adeptus Astartes</option>
          <option value="necrons">æ­»éˆ Necrons</option>
          <option value="tyranids">æ³°å€«èŸ²æ— Tyranids</option>
          <option value="chaos">æ··æ²Œæˆ°å£« Chaos Space Marines</option>
          <option value="orks">æ­å…‹è »äºº Orks</option>
        </select>
      </div>

      <div class="faction-select">
        <label>ç¨®æ—è¦å‰‡ Detachment</label>
        <select id="p1Detachment" onchange="selectDetachment(1)">
        </select>
        <div id="p1DetachmentDesc" style="font-size: 11px; color: var(--muted); margin-top: 6px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;"></div>
      </div>

      <!-- Meta è‡ªå‹•é…ç½®æŒ‰éˆ• -->
      <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
        <button onclick="autoConfigMeta(1)" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #667eea, #764ba2); border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 13px;">
          ğŸ† Metaé…ç½®
        </button>
        <button onclick="autoConfigBalanced(1)" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #11998e, #38ef7d); border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 13px;">
          âš–ï¸ å‡è¡¡é…ç½®
        </button>
        <button onclick="clearRoster(1)" style="padding: 10px 15px; background: rgba(239,68,68,0.2); border: 1px solid var(--red); border-radius: 8px; color: var(--red); font-weight: bold; cursor: pointer; font-size: 13px;">
          ğŸ—‘ï¸ æ¸…ç©º
        </button>
      </div>

      <div class="available-units">
        <h4>å¯ç”¨å–®ä½ï¼ˆé»æ“Šæ·»åŠ ï¼‰</h4>
        <div class="unit-grid" id="p1UnitGrid"></div>
      </div>

      <div class="selected-roster">
        <h4>å·²é¸å–®ä½</h4>
        <div id="p1Roster"></div>
      </div>
    </div>

    <!-- ç©å®¶äºŒè»è¡¨ -->
    <div class="army-builder" id="army2Builder">
      <div class="army-header">
        <span class="army-title player2">ğŸ¤– <span id="p2ModeLabel">ç©å®¶äºŒ</span></span>
        <span class="points-display">é»æ•¸: <span id="p2Points">0</span> / <span class="max-pts">1000</span></span>
      </div>

      <div class="ai-toggle" style="margin-bottom: 12px; padding: 10px; background: rgba(220,38,38,0.1); border: 1px solid var(--red); border-radius: 8px;">
        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
          <input type="checkbox" id="aiModeToggle" onchange="toggleAIMode()" checked style="width: 18px; height: 18px;">
          <span style="font-size: 14px; font-weight: bold; color: var(--red);">ğŸ¤– AIå°æ‰‹æ¨¡å¼</span>
        </label>
        <div style="margin-top: 8px;">
          <label style="font-size: 11px; color: var(--muted);">AIé›£åº¦ï¼š</label>
          <select id="aiDifficulty" style="padding: 4px 8px; background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 4px; color: var(--txt); font-size: 12px;">
            <option value="easy">ç°¡å–® - éš¨æ©Ÿè¡Œå‹•</option>
            <option value="normal" selected>æ™®é€š - åŸºæœ¬ç­–ç•¥</option>
            <option value="hard">å›°é›£ - é€²éšç­–ç•¥</option>
          </select>
        </div>
        <div style="margin-top: 8px;">
          <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 11px; color: var(--muted);">
            <input type="checkbox" id="diceAnimToggle" checked style="width: 14px; height: 14px;">
            <span>éª°å­å‹•ç•«ï¼ˆé—œé–‰å¯åŠ é€ŸAIå°æˆ°ï¼‰</span>
          </label>
        </div>
      </div>

      <div class="faction-select">
        <label>é¸æ“‡é™£ç‡Ÿ</label>
        <select id="p2Faction" onchange="updateAvailableUnits(2); updateDetachmentOptions(2);">
          <option value="necrons">æ­»éˆ Necrons</option>
          <option value="tyranids">æ³°å€«èŸ²æ— Tyranids</option>
          <option value="chaos">æ··æ²Œæˆ°å£« Chaos Space Marines</option>
          <option value="orks">æ­å…‹è »äºº Orks</option>
          <option value="space-marines">æ˜Ÿéš›æˆ°å£« Adeptus Astartes</option>
        </select>
      </div>

      <div class="faction-select">
        <label>ç¨®æ—è¦å‰‡ Detachment</label>
        <select id="p2Detachment" onchange="selectDetachment(2)">
        </select>
        <div id="p2DetachmentDesc" style="font-size: 11px; color: var(--muted); margin-top: 6px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;"></div>
      </div>

      <!-- Meta è‡ªå‹•é…ç½®æŒ‰éˆ• -->
      <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
        <button onclick="autoConfigMeta(2)" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #667eea, #764ba2); border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 13px;">
          ğŸ† Metaé…ç½®
        </button>
        <button onclick="autoConfigBalanced(2)" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #11998e, #38ef7d); border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 13px;">
          âš–ï¸ å‡è¡¡é…ç½®
        </button>
        <button onclick="clearRoster(2)" style="padding: 10px 15px; background: rgba(239,68,68,0.2); border: 1px solid var(--red); border-radius: 8px; color: var(--red); font-weight: bold; cursor: pointer; font-size: 13px;">
          ğŸ—‘ï¸ æ¸…ç©º
        </button>
      </div>

      <div class="available-units">
        <h4>å¯ç”¨å–®ä½ï¼ˆé»æ“Šæ·»åŠ ï¼‰</h4>
        <div class="unit-grid" id="p2UnitGrid"></div>
      </div>

      <div class="selected-roster">
        <h4>å·²é¸å–®ä½</h4>
        <div id="p2Roster"></div>
      </div>
    </div>
  </div>

  <!-- æˆ°å ´è¨­å®š -->
  <div class="battlefield-settings" style="margin-top: 20px; padding: 16px; background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 8px;">
    <h3 style="color: var(--gold); margin-bottom: 12px; font-size: 14px;">ğŸ—ºï¸ æˆ°å ´è¨­å®š</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
      <div class="faction-select">
        <label>æˆ°å ´å°ºå¯¸</label>
        <select id="battlefieldSize" onchange="updateBattlefieldPreview()">
          <option value="combat-patrol">Combat Patrol - 44" x 30" (å°å‹)</option>
          <option value="incursion">Incursion - 44" x 30"</option>
          <option value="strike-force" selected>Strike Force - 60" x 44" (æ¨™æº–)</option>
          <option value="onslaught">Onslaught - 90" x 44" (å¤§å‹)</option>
        </select>
        <div id="sizeDesc" style="font-size: 11px; color: var(--muted); margin-top: 4px;">æ¨™æº–å°æˆ°å°ºå¯¸ï¼Œé©åˆ 1000-2000 é»</div>
      </div>
      <div class="faction-select">
        <label>åœ°åœ–å ´æ™¯</label>
        <select id="mapScenario" onchange="updateBattlefieldPreview()">
          <option value="standard">æ¨™æº–æˆ°å ´ - å‡è¡¡åœ°å½¢</option>
          <option value="city">åŸå¸‚å»¢å¢Ÿ - å¤§é‡æ©é«”</option>
          <option value="forest">å¯†æ—åœ°å¸¶ - æ¨¹æ—ç‚ºä¸»</option>
          <option value="wasteland">è’é‡æˆ°å ´ - é–‹æ”¾å¹³åŸ</option>
          <option value="fortress">è¦å¡æ”»é˜² - é˜²ç¦¦å·¥äº‹</option>
          <option value="random">éš¨æ©Ÿç”Ÿæˆ</option>
        </select>
        <div id="mapDesc" style="font-size: 11px; color: var(--muted); margin-top: 4px;">å‡è¡¡é…ç½®çš„æ¨™æº–åœ°å½¢</div>
      </div>
    </div>
    <div id="battlefieldPreview" style="margin-top: 12px; padding: 10px; background: rgba(0,0,0,0.4); border-radius: 6px; text-align: center;">
      <canvas id="previewCanvas" width="300" height="200" style="border: 1px solid var(--line); border-radius: 4px;"></canvas>
      <div style="font-size: 11px; color: var(--muted); margin-top: 6px;">é è¦½ (æ¯”ä¾‹ç¸®å°)</div>
    </div>
  </div>

  <div class="terrain-legend">
    <h4>åœ°å½¢è¦å‰‡èªªæ˜ï¼ˆå®˜æ–¹10ç‰ˆï¼‰</h4>
    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
      <div class="terrain-item"><div class="terrain-color" style="background: #4a5568;"></div> å»¢å¢Ÿ Ruinsï¼šå®Œå…¨åœ¨å…§æˆ–ä¸å®Œå…¨å¯è¦‹æ™‚+1è­·ç”²è±å…</div>
      <div class="terrain-item"><div class="terrain-color" style="background: #2d5a27;"></div> æ¨¹æ— Woodsï¼šå®Œå…¨åœ¨å…§æˆ–ä¸å®Œå…¨å¯è¦‹æ™‚+1è­·ç”²è±å…</div>
      <div class="terrain-item"><div class="terrain-color" style="background: #78716c;"></div> éšœç¤™ç‰© Barricadesï¼š3"å…§ä¸”ä¸å®Œå…¨å¯è¦‹æ™‚+1è­·ç”²è±å…</div>
      <div class="terrain-item"><div class="terrain-color" style="background: #854d0e;"></div> å½ˆå‘ Cratersï¼šå®Œå…¨åœ¨å…§æ™‚+1è­·ç”²è±å…</div>
      <div class="terrain-item"><div class="terrain-color" style="background: #1e40af;"></div> å»ºç¯‰ç‰© Buildingsï¼šé˜»æ“‹è¦–ç·šï¼Œå¯æä¾›æ©è­·</div>
      <div class="terrain-item"><div class="terrain-color" style="background: #fbbf24;"></div> ç›®æ¨™é» Objectivesï¼š3"ç¯„åœå…§ä»¥OCå€¼è¨ˆç®—æ§åˆ¶</div>
    </div>
    <p style="margin-top: 8px; font-size: 11px; color: var(--muted);">
      <b>æ©è­·è¦å‰‡ï¼š</b>æ©è­·æä¾›+1è­·ç”²è±å…ï¼ˆå°é ç¨‹æ”»æ“Šï¼‰ã€‚è­·ç”²3+æˆ–æ›´å¥½çš„æ¨¡å‹é¢å°AP0æ­¦å™¨æ™‚ä¸é©ç”¨æ©è­·åŠ æˆã€‚
    </p>
    <p style="margin-top: 4px; font-size: 11px; color: var(--muted);">
      <b>å‚·å®³è¡¨ï¼š</b>Sâ‰¥2Ã—T=2+ | S>T=3+ | S=T=4+ | S<T=5+ | Sâ‰¤T/2=6+
    </p>
  </div>

  <div class="setup-actions">
    <button class="start-game-btn" id="startGameBtn" onclick="startBattle()" disabled>
      âš”ï¸ é–‹å§‹æˆ°é¬¥ âš”ï¸
    </button>
    <p style="color: var(--muted); margin-top: 10px; font-size: 12px;">é›™æ–¹éƒ½éœ€è¦è‡³å°‘é¸æ“‡ä¸€å€‹å–®ä½</p>
  </div>
</div>

<!-- ===== éŠæˆ²ç•«é¢ ===== -->
<div class="game-screen" id="gameScreen">
  <div class="game-header">
    <div class="game-title">âš”ï¸ æˆ°éš 40K - å›åˆ <span id="roundNum">1</span></div>
    <div class="phase-indicator">
      <div class="phase-pip" data-phase="deployment">éƒ¨ç½²</div>
      <div class="phase-pip" data-phase="command">æŒ‡æ®</div>
      <div class="phase-pip" data-phase="movement">ç§»å‹•</div>
      <div class="phase-pip" data-phase="shooting">å°„æ“Š</div>
      <div class="phase-pip" data-phase="charge">è¡é‹’</div>
      <div class="phase-pip" data-phase="fight">è¿‘æˆ°</div>
    </div>
    <div style="font-size: 12px;">
      ç•¶å‰: <span id="currentPlayerName" style="color: var(--gold);">ç©å®¶ä¸€</span>
      <span id="aiIndicator" style="margin-left: 8px; padding: 2px 6px; background: var(--red); border-radius: 4px; font-size: 10px; display: none;">ğŸ¤– AIæ¨¡å¼</span>
      <span id="currentDetachment" style="margin-left: 8px; padding: 2px 6px; background: var(--green); border-radius: 4px; font-size: 10px;"></span>
    </div>
  </div>

  <div class="game-main">
    <!-- Left: Units List -->
    <div class="units-panel">
      <div class="panel-header">
        <span id="team1Label">ç©å®¶ä¸€</span>
        <span style="color: var(--green);">VP: <span id="vp1Display">0</span></span>
      </div>
      <div class="units-list" id="team1List"></div>

      <div class="panel-header" style="border-top: 1px solid var(--line);">
        <span id="team2Label">ç©å®¶äºŒ</span>
        <span style="color: var(--red);">VP: <span id="vp2Display">0</span></span>
      </div>
      <div class="units-list" id="team2List"></div>
    </div>

    <!-- Center: Battlefield -->
    <div class="battlefield-container">
      <div class="battlefield-toolbar">
        <button class="toolbar-btn success" id="btnStartRound" onclick="finishDeploymentAndStart()" style="display:none;">é–‹å§‹å›åˆ â–¶</button>
        <button class="toolbar-btn" id="btnSwitchDeploy" onclick="switchDeploySide()" style="display:none;">åˆ‡æ›éƒ¨ç½²æ–¹</button>
        <button class="toolbar-btn primary" id="btnNextPhase" onclick="nextPhase()">ä¸‹ä¸€éšæ®µ â–¶</button>
        <button class="toolbar-btn" id="btnMove" onclick="setAction('move')" disabled>ç§»å‹•</button>
        <button class="toolbar-btn" id="btnShoot" onclick="setAction('shoot')" disabled>å°„æ“Š</button>
        <button class="toolbar-btn" id="btnCharge" onclick="setAction('charge')" disabled>è¡é‹’</button>
        <button class="toolbar-btn" id="btnFight" onclick="setAction('fight')" disabled>è¿‘æˆ°</button>
        <button class="toolbar-btn" id="btnReroll" onclick="useCommandReroll()" disabled title="èŠ±è²»1CPé‡æ“²ä¸€é¡†éª°å­">ğŸ² æŒ‡æ®é‡æ“²</button>
        <span style="font-size: 11px; color: var(--gold); margin-left: 4px;">CP: <b id="cpDisplay">0</b></span>
        <button class="toolbar-btn danger" id="btnEndTurn" onclick="endTurn()">çµæŸå›åˆ</button>
        <div style="display: flex; align-items: center; gap: 6px; margin-left: 10px; padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 6px;">
          <span style="font-size: 16px; cursor: pointer;" onclick="toggleMute()" id="soundIcon">ğŸ”Š</span>
          <input type="range" id="volumeSlider" min="0" max="100" value="50"
            style="width: 60px; height: 4px; cursor: pointer; accent-color: var(--gold);"
            oninput="setVolume(this.value)" title="éŸ³é‡èª¿ç¯€">
          <span style="font-size: 10px; color: var(--muted); min-width: 28px;" id="volumeDisplay">50%</span>
        </div>
        <div style="display: flex; align-items: center; gap: 4px; margin-left: 10px; padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 6px;">
          <button onclick="zoomOut()" style="width: 24px; height: 24px; background: var(--panel); border: 1px solid var(--line); border-radius: 4px; color: var(--txt); cursor: pointer; font-size: 14px;" title="ç¸®å°">âˆ’</button>
          <span style="font-size: 10px; color: var(--muted); min-width: 36px; text-align: center;" id="zoomDisplay">100%</span>
          <button onclick="zoomIn()" style="width: 24px; height: 24px; background: var(--panel); border: 1px solid var(--line); border-radius: 4px; color: var(--txt); cursor: pointer; font-size: 14px;" title="æ”¾å¤§">+</button>
          <button onclick="zoomReset()" style="padding: 2px 6px; background: var(--panel); border: 1px solid var(--line); border-radius: 4px; color: var(--txt); cursor: pointer; font-size: 10px;" title="é‡ç½®ç¸®æ”¾">é‡ç½®</button>
        </div>
        <div class="action-hint" id="actionHint">é¸æ“‡ä¸€å€‹å–®ä½é–‹å§‹è¡Œå‹•</div>
      </div>
      <div class="battlefield-wrap">
        <canvas id="gameCanvas"></canvas>
      </div>
    </div>

    <!-- Right: Info Panel -->
    <div class="info-panel">
      <div class="selected-unit-info" id="selectedUnitInfo">
        <p style="color: var(--muted); text-align: center; padding: 20px;">é»æ“Šå–®ä½æŸ¥çœ‹è©³ç´°è³‡è¨Š</p>
      </div>

      <div class="panel-header">æˆ°é¬¥æ—¥èªŒ</div>
      <div class="combat-log">
        <div class="log-content" id="logContent"></div>
      </div>

      <!-- æˆ°ç•¥é¢æ¿ -->
      <div class="panel-header" style="cursor: pointer;" onclick="toggleStratagemPanel()">
        ğŸ´ æˆ°ç•¥ (Stratagems) <span id="stratagemToggle">â–¼</span>
      </div>
      <div id="stratagemPanel" style="max-height: 150px; overflow-y: auto; margin-bottom: 10px; display: none;">
        <div id="stratagemList" style="font-size: 11px; color: var(--txt);">
          <p style="color: var(--muted); padding: 8px;">é–‹å§‹éŠæˆ²å¾Œé¡¯ç¤ºå¯ç”¨æˆ°ç•¥</p>
        </div>
      </div>

      <div class="score-bar">
        <div class="score-item">
          <div class="score-label">å›åˆ</div>
          <div class="score-value" id="roundDisplay">1</div>
        </div>
        <div class="score-item">
          <div class="score-label">ç©å®¶ä¸€ VP</div>
          <div class="score-value" style="color: var(--blue);" id="p1VPDisplay">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">ç©å®¶äºŒ VP</div>
          <div class="score-value" style="color: var(--red);" id="p2VPDisplay">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">ç©å®¶ä¸€ CP</div>
          <div class="score-value" style="color: var(--blue);" id="p1CPDisplay">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">ç©å®¶äºŒ CP</div>
          <div class="score-value" style="color: var(--red);" id="p2CPDisplay">0</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- éª°å­è¦–è¦ºåŒ–è¦†è“‹å±¤ -->
<div class="dice-overlay" id="diceOverlay">
  <div class="dice-title" id="diceTitle">å‘½ä¸­æ“²éª°</div>
  <div class="dice-container" id="diceContainer"></div>
  <div class="dice-result" id="diceResult"></div>
</div>

<!-- æˆ°ç•¥é¸æ“‡å½ˆçª— -->
<div class="dice-overlay" id="stratagemPopup" style="display: none;">
  <div style="background: rgba(20,20,30,0.98); border: 2px solid var(--gold); border-radius: 12px; padding: 20px; max-width: 500px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
      <div style="font-size: 18px; font-weight: bold; color: var(--gold);">ğŸ´ <span id="stratagemPopupTitle">é¸æ“‡æˆ°ç•¥</span></div>
      <div style="font-size: 14px; color: var(--muted);">CP: <span id="stratagemPopupCP" style="color: var(--green); font-weight: bold;">0</span></div>
    </div>
    <div id="stratagemPopupPhase" style="font-size: 12px; color: var(--muted); margin-bottom: 15px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 6px;"></div>
    <div id="stratagemPopupList" style="display: flex; flex-direction: column; gap: 8px;"></div>
    <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: center;">
      <button onclick="closeStratagemPopup()" style="padding: 10px 30px; background: rgba(100,100,100,0.3); border: 1px solid var(--line); border-radius: 8px; color: var(--txt); cursor: pointer; font-size: 14px;">è·³é (ä¸ä½¿ç”¨æˆ°ç•¥)</button>
    </div>
  </div>
</div>

<script>
// ========== Firebase é€£ç·šç³»çµ± ==========
const firebaseConfig = {
  apiKey: "AIzaSyBfrS-b2dpZUt8yJvSYKDap0AjZsy8UJ0I",
  authDomain: "wh40k-game.firebaseapp.com",
  databaseURL: "https://wh40k-game-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "wh40k-game",
  storageBucket: "wh40k-game.firebasestorage.app",
  messagingSenderId: "1074789310261",
  appId: "1:1074789310261:web:4a1a81a63ef48e0589f67c"
};

// åˆå§‹åŒ– Firebase
firebase.initializeApp(firebaseConfig);
const database = firebase.database();

// é€£ç·šç‹€æ…‹
let isOnlineMode = false;
let currentRoomCode = null;
let isHost = false;  // æˆ¿ä¸» = ç©å®¶1
let onlinePlayerId = null;  // 1 æˆ– 2
let roomRef = null;
let gameStateRef = null;
let lastDiceTimestamp = 0;  // éª°å­åŒæ­¥æ™‚é–“æˆ³
let lastLogTimestamp = 0;   // ç´€éŒ„åŒæ­¥æ™‚é–“æˆ³

// ç”¢ç”Ÿéš¨æ©Ÿæˆ¿é–“ç¢¼
function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 6; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

// åˆ‡æ›éŠæˆ²æ¨¡å¼
function switchGameMode(mode) {
  isOnlineMode = (mode === 'online');
  document.getElementById('onlinePanel').style.display = isOnlineMode ? 'block' : 'none';

  const army1Builder = document.getElementById('army1Builder');
  const army2Builder = document.getElementById('army2Builder');

  // ç·šä¸Šæ¨¡å¼æ™‚éš±è—AIé¸é …
  if (isOnlineMode) {
    const ai1Toggle = document.getElementById('ai1ModeToggle');
    const ai2Toggle = document.getElementById('ai2ModeToggle');
    if (ai1Toggle) ai1Toggle.checked = false;
    if (ai2Toggle) ai2Toggle.checked = false;
    if (typeof toggleAI1Mode === 'function') toggleAI1Mode();
    if (typeof toggleAI2Mode === 'function') toggleAI2Mode();

    // æç¤ºï¼šå…ˆå»ºç«‹/åŠ å…¥æˆ¿é–“
    document.getElementById('p1ModeLabel').textContent = 'ç©å®¶ä¸€ï¼ˆæˆ¿ä¸»ï¼‰';
    document.getElementById('p2ModeLabel').textContent = 'ç©å®¶äºŒï¼ˆåŠ å…¥è€…ï¼‰';
  } else {
    // æœ¬åœ°æ¨¡å¼ï¼šæ¢å¾©æ­£å¸¸
    document.getElementById('p1ModeLabel').textContent = 'ç©å®¶ä¸€';
    document.getElementById('p2ModeLabel').textContent = 'ç©å®¶äºŒ';
    army1Builder.style.opacity = '1';
    army1Builder.style.pointerEvents = 'auto';
    army2Builder.style.opacity = '1';
    army2Builder.style.pointerEvents = 'auto';
  }
}

// æ ¹æ“šç©å®¶èº«ä»½é¡¯ç¤ºå°æ‡‰çš„è¨­å®šå€
function updateOnlineSetupUI() {
  if (!isOnlineMode) return;

  const army1Builder = document.getElementById('army1Builder');
  const army2Builder = document.getElementById('army2Builder');

  if (onlinePlayerId === 1) {
    // æˆ¿ä¸»ï¼šåªèƒ½ç·¨è¼¯ç©å®¶ä¸€
    army1Builder.style.opacity = '1';
    army1Builder.style.pointerEvents = 'auto';
    army2Builder.style.opacity = '0.5';
    army2Builder.style.pointerEvents = 'none';
    document.getElementById('p1ModeLabel').textContent = 'ğŸ‘¤ ä½ çš„è»éšŠ';
    document.getElementById('p2ModeLabel').textContent = 'â³ ç­‰å¾…å°æ‰‹...';
  } else if (onlinePlayerId === 2) {
    // åŠ å…¥è€…ï¼šåªèƒ½ç·¨è¼¯ç©å®¶äºŒ
    army1Builder.style.opacity = '0.5';
    army1Builder.style.pointerEvents = 'none';
    army2Builder.style.opacity = '1';
    army2Builder.style.pointerEvents = 'auto';
    document.getElementById('p1ModeLabel').textContent = 'ğŸ‘‘ å°æ‰‹è»éšŠ';
    document.getElementById('p2ModeLabel').textContent = 'ğŸ‘¤ ä½ çš„è»éšŠ';
  }
}

// å»ºç«‹æˆ¿é–“
async function createRoom() {
  currentRoomCode = generateRoomCode();
  isHost = true;
  onlinePlayerId = 1;
  isOnlineMode = true;  // ç¢ºä¿è¨­ç‚ºç·šä¸Šæ¨¡å¼
  console.log('[createRoom] å»ºç«‹æˆ¿é–“:', { currentRoomCode, isHost, onlinePlayerId, isOnlineMode });

  roomRef = database.ref('rooms/' + currentRoomCode);

  // å»ºç«‹æˆ¿é–“è³‡æ–™
  await roomRef.set({
    host: onlinePlayerId,
    status: 'waiting',
    createdAt: firebase.database.ServerValue.TIMESTAMP,
    players: {
      1: { ready: false, faction: document.getElementById('p1Faction').value }
    }
  });

  // ç›£è½æˆ¿é–“ç‹€æ…‹
  listenToRoom();

  // æ›´æ–°UI
  document.getElementById('roomLobby').style.display = 'none';
  document.getElementById('roomInfo').style.display = 'block';
  document.getElementById('roomCodeDisplay').textContent = currentRoomCode;
  document.getElementById('roomStatus').textContent = 'ç­‰å¾…å°æ‰‹åŠ å…¥...';
  document.getElementById('roomStatus').style.color = 'var(--gold)';

  // æ›´æ–°è»éšŠè¨­å®šUI
  updateOnlineSetupUI();

  // æ›´æ–°é–‹å§‹æŒ‰éˆ•
  checkStartButton();

  // æˆ¿é–“æ¸…ç†ï¼ˆæ–·ç·šæ™‚åˆªé™¤ï¼‰
  roomRef.onDisconnect().remove();

  log('æˆ¿é–“å·²å»ºç«‹: ' + currentRoomCode, 'info');
}

// åŠ å…¥æˆ¿é–“
async function joinRoom() {
  const code = document.getElementById('joinRoomCode').value.toUpperCase().trim();
  if (code.length !== 6) {
    alert('è«‹è¼¸å…¥6ä½æˆ¿é–“ç¢¼');
    return;
  }

  currentRoomCode = code;
  roomRef = database.ref('rooms/' + currentRoomCode);

  // æª¢æŸ¥æˆ¿é–“æ˜¯å¦å­˜åœ¨
  const snapshot = await roomRef.once('value');
  if (!snapshot.exists()) {
    alert('æ‰¾ä¸åˆ°æ­¤æˆ¿é–“');
    return;
  }

  const roomData = snapshot.val();
  if (roomData.status !== 'waiting') {
    alert('æ­¤æˆ¿é–“å·²é–‹å§‹éŠæˆ²');
    return;
  }

  isHost = false;
  onlinePlayerId = 2;
  isOnlineMode = true;  // ç¢ºä¿è¨­ç‚ºç·šä¸Šæ¨¡å¼
  console.log('[joinRoom] åŠ å…¥æˆ¿é–“:', { currentRoomCode, isHost, onlinePlayerId, isOnlineMode });

  // åŠ å…¥æˆ¿é–“
  await roomRef.child('players/2').set({
    ready: false,
    faction: document.getElementById('p2Faction').value
  });
  await roomRef.child('status').set('ready');

  // ç›£è½æˆ¿é–“ç‹€æ…‹
  listenToRoom();

  // æ›´æ–°UI
  document.getElementById('roomLobby').style.display = 'none';
  document.getElementById('roomInfo').style.display = 'block';
  document.getElementById('roomCodeDisplay').textContent = currentRoomCode;
  document.getElementById('roomStatus').textContent = 'å·²é€£æ¥ï¼ç­‰å¾…æˆ¿ä¸»é–‹å§‹...';
  document.getElementById('roomStatus').style.color = 'var(--green)';

  // æ›´æ–°è»éšŠè¨­å®šUI
  updateOnlineSetupUI();

  log('å·²åŠ å…¥æˆ¿é–“: ' + currentRoomCode, 'info');
}

// ç›£è½æˆ¿é–“ç‹€æ…‹
function listenToRoom() {
  if (!roomRef) return;

  roomRef.on('value', (snapshot) => {
    const data = snapshot.val();
    if (!data) {
      // æˆ¿é–“è¢«åˆªé™¤
      alert('æˆ¿é–“å·²é—œé–‰');
      leaveRoom();
      return;
    }

    // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
    if (data.status === 'ready' && isHost) {
      document.getElementById('roomStatus').textContent = 'å°æ‰‹å·²åŠ å…¥ï¼å¯ä»¥é–‹å§‹éŠæˆ²';
      document.getElementById('roomStatus').style.color = 'var(--green)';
      // æ›´æ–°é–‹å§‹æŒ‰éˆ•ç‹€æ…‹
      checkStartButton();
    }

    // å³æ™‚é¡¯ç¤ºå°æ‰‹çš„è»éšŠé…ç½®ï¼ˆè¨­å®šéšæ®µï¼‰
    const setupScreenEl = document.getElementById('setupScreen');
    console.log('[listenToRoom] å®Œæ•´è³‡æ–™:', JSON.stringify(data, null, 2));
    console.log('[listenToRoom] æ”¶åˆ°è³‡æ–™:', { hasArmies: !!data.armies, armies: data.armies, isHost, setupVisible: setupScreenEl?.style.display });
    if (setupScreenEl && setupScreenEl.style.display !== 'none' && data.armies) {
      const opponentId = isHost ? 2 : 1;
      console.log('[listenToRoom] æª¢æŸ¥å°æ‰‹è»éšŠ:', opponentId, data.armies[opponentId]);
      if (data.armies[opponentId] && data.armies[opponentId].roster) {
        console.log('[listenToRoom] é¡¯ç¤ºå°æ‰‹è»éšŠ:', data.armies[opponentId].roster.length, 'å€‹å–®ä½');
        displayOpponentArmy(opponentId, data.armies[opponentId]);
      }
    }

    // éŠæˆ²é–‹å§‹ - éæˆ¿ä¸»æ”¶åˆ°é–‹å§‹è¨Šè™Ÿ
    if (data.gameStarted && !isHost) {
      if (setupScreenEl && setupScreenEl.style.display !== 'none') {
        // ç¢ºä¿è‡ªå·±çš„è»éšŠå·²åŒæ­¥ï¼ˆä»¥é˜²è¬ä¸€ï¼‰
        syncArmyToFirebase(2);

        // è¼‰å…¥æˆ¿ä¸»çš„è»éšŠï¼ˆæ‡‰è©²å·²ç¶“å³æ™‚åŒæ­¥äº†ï¼‰
        roomRef.child('armies/1').once('value').then((snapshot) => {
          if (snapshot.exists()) {
            const hostArmy = snapshot.val();
            loadEnemyArmy(hostArmy, 1);
          }

          // é–‹å§‹éŠæˆ²
          document.getElementById("setupScreen").style.display = "none";
          document.getElementById("gameScreen").classList.add("active");
          resizeCanvas();
          initBattlefield();
          gameState.phase = "deployment";
          gameState.round = 1;
          gameState.currentPlayer = 1;
          log('=== æˆ¿ä¸»å·²é–‹å§‹éŠæˆ² ===', 'phase');
          updatePhaseDisplay();
          render();
        });
      }
    }

    // åŒæ­¥éª°å­å‹•ç•«
    if (data.diceRoll && data.diceRoll.timestamp !== lastDiceTimestamp) {
      lastDiceTimestamp = data.diceRoll.timestamp;
      showRemoteDice(data.diceRoll);
    }

    // åŒæ­¥æˆ°é¬¥ç´€éŒ„
    if (data.combatLog && data.combatLog.timestamp !== lastLogTimestamp) {
      lastLogTimestamp = data.combatLog.timestamp;
      log(data.combatLog.message, data.combatLog.type, false);  // false é˜²æ­¢é‡è¤‡åŒæ­¥
    }

    // åŒæ­¥è¦–è¦ºæ•ˆæœ
    if (data.visualEffect && data.visualEffect.timestamp !== lastEffectTimestamp) {
      lastEffectTimestamp = data.visualEffect.timestamp;
      handleRemoteVisualEffect(data.visualEffect);
    }

    // åŒæ­¥éŠæˆ²ç‹€æ…‹ï¼ˆé›™æ–¹éƒ½éœ€è¦æ¥æ”¶å°æ–¹çš„æ›´æ–°ï¼‰
    if (data.status === 'playing' && data.gameState) {
      // ç¸½æ˜¯åŒæ­¥éŠæˆ²ç‹€æ…‹ï¼Œç¢ºä¿é›™æ–¹ä¸€è‡´
      syncGameStateFromFirebase(data.gameState);
    }

    // ç›£è½éŠæˆ²å‹•ä½œ
    if (data.lastAction && data.lastAction.player !== onlinePlayerId) {
      handleRemoteAction(data.lastAction);
    }
  });
}

// é›¢é–‹æˆ¿é–“
function leaveRoom() {
  if (roomRef) {
    if (isHost) {
      roomRef.remove();
    } else {
      roomRef.child('players/2').remove();
      roomRef.child('status').set('waiting');
    }
    roomRef.off();
    roomRef = null;
  }

  currentRoomCode = null;
  isHost = false;
  onlinePlayerId = null;

  document.getElementById('roomLobby').style.display = 'block';
  document.getElementById('roomInfo').style.display = 'none';
  document.getElementById('joinRoomCode').value = '';
}

// åŒæ­¥éŠæˆ²ç‹€æ…‹åˆ° Firebase
function syncGameStateToFirebase() {
  if (!isOnlineMode || !roomRef) return;

  const stateToSync = {
    phase: gameState.phase,
    round: gameState.round,
    currentPlayer: gameState.currentPlayer,
    units: gameState.units.map(u => ({
      id: u.id,
      x: u.x,
      y: u.y,
      currentHP: u.currentHP,
      maxHP: u.maxHP,
      alive: u.alive,
      deployed: u.deployed,
      hasMoved: u.hasMoved,
      hasShot: u.hasShot,
      hasCharged: u.hasCharged,
      hasFought: u.hasFought,
      battleShocked: u.battleShocked || false,
      inCover: u.inCover || false,
      usedOneUseWeapons: u.usedOneUseWeapons || [],
      activeStratagemEffects: u.activeStratagemEffects || []
    })),
    vp: gameState.vp,
    cp: gameState.cp,
    objectives: gameState.objectives,
    deploy: gameState.deploy || { deployingPlayer: 1, p1Deployed: false, p2Deployed: false },
    timestamp: Date.now()
  };

  roomRef.child('gameState').set(stateToSync);
}

// å¾ Firebase åŒæ­¥éŠæˆ²ç‹€æ…‹
function syncGameStateFromFirebase(remoteState) {
  if (!remoteState) return;

  gameState.phase = remoteState.phase;
  gameState.round = remoteState.round;
  gameState.currentPlayer = remoteState.currentPlayer;
  gameState.vp = remoteState.vp || { 1: 0, 2: 0 };
  gameState.cp = remoteState.cp || { 1: 0, 2: 0 };
  if (remoteState.deploy) {
    gameState.deploy = remoteState.deploy;
  }

  // åŒæ­¥å–®ä½ç‹€æ…‹
  if (remoteState.units) {
    remoteState.units.forEach(remoteUnit => {
      const localUnit = gameState.units.find(u => u.id === remoteUnit.id);
      if (localUnit) {
        localUnit.x = remoteUnit.x;
        localUnit.y = remoteUnit.y;
        localUnit.currentHP = remoteUnit.currentHP;
        if (remoteUnit.maxHP) localUnit.maxHP = remoteUnit.maxHP;
        localUnit.alive = remoteUnit.alive;
        localUnit.deployed = remoteUnit.deployed;
        localUnit.hasMoved = remoteUnit.hasMoved;
        localUnit.hasShot = remoteUnit.hasShot;
        localUnit.hasCharged = remoteUnit.hasCharged;
        localUnit.hasFought = remoteUnit.hasFought;
        localUnit.battleShocked = remoteUnit.battleShocked || false;
        localUnit.inCover = remoteUnit.inCover || false;
        if (remoteUnit.usedOneUseWeapons) localUnit.usedOneUseWeapons = remoteUnit.usedOneUseWeapons;
        if (remoteUnit.activeStratagemEffects) localUnit.activeStratagemEffects = remoteUnit.activeStratagemEffects;
      }
    });
  }

  // æ›´æ–° UI å…ƒç´ 
  if (typeof updateUnitLists === 'function') updateUnitLists();
  if (typeof updateCPDisplay === 'function') updateCPDisplay();
  if (typeof updatePhaseIndicator === 'function') updatePhaseIndicator();
  document.getElementById("roundNum").textContent = gameState.round;
  document.getElementById("roundDisplay").textContent = gameState.round;

  // é¡¯ç¤ºç•¶å‰ç©å®¶
  const playerName = gameState.currentPlayer === 1 ? "ç©å®¶ä¸€" : "ç©å®¶äºŒ";
  document.getElementById("currentPlayerName").textContent = playerName;

  // æç¤ºæ˜¯å¦ç‚ºè‡ªå·±çš„å›åˆ
  if (isMyTurn()) {
    log(`è¼ªåˆ°ä½ çš„å›åˆï¼`, 'phase', false);  // æœ¬åœ°æç¤ºä¸åŒæ­¥
  }

  render();
}

// ç™¼é€å‹•ä½œåˆ° Firebase
function sendAction(action) {
  if (!isOnlineMode || !roomRef) return;

  roomRef.child('lastAction').set({
    ...action,
    player: onlinePlayerId,
    timestamp: firebase.database.ServerValue.TIMESTAMP
  });

  // åŒæ­¥éŠæˆ²ç‹€æ…‹
  syncGameStateToFirebase();
}

// è™•ç†é ç«¯å‹•ä½œ
function handleRemoteAction(action) {
  if (!action || action.player === onlinePlayerId) return;

  switch (action.type) {
    case 'move':
      const moveUnit = gameState.units.find(u => u.id === action.unitId);
      if (moveUnit) {
        moveUnit.x = action.x;
        moveUnit.y = action.y;
        moveUnit.hasMoved = true;
      }
      break;
    case 'attack':
      // æ”»æ“Šå‹•ä½œæœƒé€šé gameState åŒæ­¥
      break;
    case 'endTurn':
      // å›åˆçµæŸ
      break;
    case 'deploy':
      const deployUnit = gameState.units.find(u => u.id === action.unitId);
      if (deployUnit) {
        deployUnit.x = action.x;
        deployUnit.y = action.y;
        deployUnit.deployed = true;
      }
      break;
  }

  render();
}

// æª¢æŸ¥æ˜¯å¦ç‚ºç•¶å‰ç©å®¶çš„å›åˆ
function isMyTurn() {
  if (!isOnlineMode) return true;
  return gameState.currentPlayer === onlinePlayerId;
}

// åŒæ­¥éª°å­çµæœåˆ° Firebase
function syncDiceRoll(title, results, successCount, failCount) {
  if (!isOnlineMode || !roomRef) return;
  roomRef.child('diceRoll').set({
    title: title,
    results: results,
    successCount: successCount,
    failCount: failCount,
    timestamp: Date.now()
  });
}

// é¡¯ç¤ºé ç«¯éª°å­å‹•ç•«
function showRemoteDice(diceData) {
  if (!diceData) return;
  const overlay = document.getElementById('diceOverlay');
  const container = document.getElementById('diceContainer');
  const titleEl = document.getElementById('diceTitle');
  const resultEl = document.getElementById('diceResult');

  if (!overlay || !container) return;

  titleEl.textContent = diceData.title || 'éª°å­çµæœ';
  container.innerHTML = '';

  if (diceData.results && Array.isArray(diceData.results)) {
    diceData.results.forEach(r => {
      const dice = document.createElement('div');
      dice.className = 'dice ' + (r.success ? 'success' : 'fail');
      if (r.value === 6) dice.classList.add('critical');
      dice.textContent = r.value;
      container.appendChild(dice);
    });
  }

  resultEl.innerHTML = `<span class="success-count">${diceData.successCount || 0} æˆåŠŸ</span> / <span class="fail-count">${diceData.failCount || 0} å¤±æ•—</span>`;

  overlay.classList.add('active');
  setTimeout(() => overlay.classList.remove('active'), 1500);
}

// åŒæ­¥æˆ°é¬¥ç´€éŒ„åˆ° Firebase
function syncCombatLog(message, type) {
  if (!isOnlineMode || !roomRef) return;
  roomRef.child('combatLog').set({
    message: message,
    type: type,
    timestamp: Date.now()
  });
}

// åŒæ­¥è¦–è¦ºæ•ˆæœåˆ° Firebase
let lastEffectTimestamp = 0;
function syncVisualEffect(effectData) {
  if (!isOnlineMode || !roomRef) return;
  roomRef.child('visualEffect').set({
    ...effectData,
    timestamp: Date.now()
  });
}

// è™•ç†é ç«¯è¦–è¦ºæ•ˆæœ
function handleRemoteVisualEffect(effectData) {
  if (!effectData) return;
  switch (effectData.type) {
    case 'floatingText':
      showFloatingText(effectData.x, effectData.y, effectData.text, effectData.options || {}, false);
      break;
    case 'damageNumber':
      showDamageNumber(effectData.x, effectData.y, effectData.damage, effectData.isCrit || false, false);
      break;
  }
}

// ========== å¸¸æ•¸ ==========
// INCH = åƒç´ /è‹±å‹ï¼Œæ§åˆ¶æ•´é«”å ´æ™¯å¤§å°
// 10 = å°å ´æ™¯ï¼ˆé©åˆå°è¢å¹•ï¼‰, 15 = ä¸­ç­‰, 20 = å¤§å ´æ™¯
const INCH = 15;
let maxPoints = 1000; // å¯èª¿æ•´çš„é»æ•¸ä¸Šé™

// ========== éŸ³æ•ˆç³»çµ± ==========
let audioContext = null;
let masterVolume = 0.5;
let isMuted = false;

// åˆå§‹åŒ–éŸ³é »ä¸Šä¸‹æ–‡ï¼ˆéœ€è¦ç”¨æˆ¶äº¤äº’å¾Œæ‰èƒ½å•Ÿå‹•ï¼‰
function initAudio() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
}

// è¨­å®šéŸ³é‡
function setVolume(value) {
  masterVolume = value / 100;
  document.getElementById('volumeDisplay').textContent = value + '%';
  document.getElementById('soundIcon').textContent = value == 0 ? 'ğŸ”‡' : (value < 30 ? 'ğŸ”ˆ' : (value < 70 ? 'ğŸ”‰' : 'ğŸ”Š'));
  isMuted = (value == 0);
}

// éœéŸ³åˆ‡æ›
function toggleMute() {
  const slider = document.getElementById('volumeSlider');
  if (isMuted) {
    slider.value = 50;
    setVolume(50);
  } else {
    slider.value = 0;
    setVolume(0);
  }
}

// æ’­æ”¾éŸ³æ•ˆï¼ˆä½¿ç”¨ Web Audio API ç”Ÿæˆï¼‰
function playSound(type, options = {}) {
  if (isMuted || masterVolume <= 0) return;
  initAudio();
  if (!audioContext) return;

  const volume = (options.volume || 1) * masterVolume;

  switch (type) {
    case 'shoot':
      playShotSound(volume, options.weapon || 'rifle');
      break;
    case 'hit':
      playHitSound(volume);
      break;
    case 'explosion':
      playExplosionSound(volume, options.size || 'medium');
      break;
    case 'melee':
      playMeleeSound(volume);
      break;
    case 'miss':
      playMissSound(volume);
      break;
    case 'death':
      playDeathSound(volume);
      break;
    case 'heal':
      playHealSound(volume);
      break;
    case 'select':
      playSelectSound(volume);
      break;
    case 'click':
      playClickSound(volume);
      break;
    case 'roundStart':
      playRoundStartSound(volume);
      break;
    case 'victory':
      playVictorySound(volume);
      break;
    case 'charge':
      playChargeSound(volume);
      break;
    case 'dice':
      playDiceSound(volume);
      break;
  }
}

// å°„æ“ŠéŸ³æ•ˆ
function playShotSound(volume, weapon) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();
  const noise = createNoiseBuffer(0.15);

  // å™ªéŸ³éƒ¨åˆ†ï¼ˆæ§è²ä¸»é«”ï¼‰
  const noiseSource = audioContext.createBufferSource();
  noiseSource.buffer = noise;
  const noiseGain = audioContext.createGain();
  const noiseFilter = audioContext.createBiquadFilter();
  noiseFilter.type = 'bandpass';
  noiseFilter.frequency.value = weapon === 'laser' ? 2000 : 800;
  noiseFilter.Q.value = 1;

  noiseSource.connect(noiseFilter);
  noiseFilter.connect(noiseGain);
  noiseGain.connect(audioContext.destination);

  noiseGain.gain.setValueAtTime(volume * 0.4, audioContext.currentTime);
  noiseGain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.12);

  // éŸ³èª¿éƒ¨åˆ†
  osc.type = weapon === 'laser' ? 'sine' : 'sawtooth';
  osc.frequency.setValueAtTime(weapon === 'laser' ? 1200 : 150, audioContext.currentTime);
  osc.frequency.exponentialDecayTo(weapon === 'laser' ? 800 : 60, audioContext.currentTime + 0.1);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.2, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.1);

  osc.start();
  noiseSource.start();
  osc.stop(audioContext.currentTime + 0.15);
  noiseSource.stop(audioContext.currentTime + 0.15);
}

// å‘½ä¸­éŸ³æ•ˆ
function playHitSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sine';
  osc.frequency.setValueAtTime(400, audioContext.currentTime);
  osc.frequency.exponentialDecayTo(100, audioContext.currentTime + 0.1);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.15);

  osc.start();
  osc.stop(audioContext.currentTime + 0.15);
}

// çˆ†ç‚¸éŸ³æ•ˆ
function playExplosionSound(volume, size) {
  const duration = size === 'large' ? 0.6 : (size === 'small' ? 0.2 : 0.4);
  const noise = createNoiseBuffer(duration);
  const source = audioContext.createBufferSource();
  source.buffer = noise;

  const filter = audioContext.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.setValueAtTime(size === 'large' ? 400 : 600, audioContext.currentTime);
  filter.frequency.exponentialDecayTo(50, audioContext.currentTime + duration);

  const gain = audioContext.createGain();
  gain.gain.setValueAtTime(volume * 0.5, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + duration);

  source.connect(filter);
  filter.connect(gain);
  gain.connect(audioContext.destination);

  source.start();
  source.stop(audioContext.currentTime + duration);
}

// è¿‘æˆ°éŸ³æ•ˆ
function playMeleeSound(volume) {
  const noise = createNoiseBuffer(0.1);
  const source = audioContext.createBufferSource();
  source.buffer = noise;

  const filter = audioContext.createBiquadFilter();
  filter.type = 'highpass';
  filter.frequency.value = 2000;

  const gain = audioContext.createGain();
  gain.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.1);

  source.connect(filter);
  filter.connect(gain);
  gain.connect(audioContext.destination);

  source.start();
  source.stop(audioContext.currentTime + 0.1);
}

// æœªå‘½ä¸­éŸ³æ•ˆ
function playMissSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sine';
  osc.frequency.setValueAtTime(300, audioContext.currentTime);
  osc.frequency.linearRampToValueAtTime(100, audioContext.currentTime + 0.2);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.1, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.2);

  osc.start();
  osc.stop(audioContext.currentTime + 0.2);
}

// æ­»äº¡éŸ³æ•ˆ
function playDeathSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(200, audioContext.currentTime);
  osc.frequency.exponentialDecayTo(30, audioContext.currentTime + 0.5);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.25, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.5);

  osc.start();
  osc.stop(audioContext.currentTime + 0.5);
}

// æ²»ç™‚éŸ³æ•ˆ
function playHealSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sine';
  osc.frequency.setValueAtTime(400, audioContext.currentTime);
  osc.frequency.linearRampToValueAtTime(800, audioContext.currentTime + 0.1);
  osc.frequency.linearRampToValueAtTime(600, audioContext.currentTime + 0.2);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.15, audioContext.currentTime);
  gain.gain.linearRampToValueAtTime(volume * 0.2, audioContext.currentTime + 0.1);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.3);

  osc.start();
  osc.stop(audioContext.currentTime + 0.3);
}

// é¸æ“‡éŸ³æ•ˆ
function playSelectSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sine';
  osc.frequency.setValueAtTime(600, audioContext.currentTime);
  osc.frequency.linearRampToValueAtTime(800, audioContext.currentTime + 0.05);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.1, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.1);

  osc.start();
  osc.stop(audioContext.currentTime + 0.1);
}

// é»æ“ŠéŸ³æ•ˆ
function playClickSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sine';
  osc.frequency.value = 1000;

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.08, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.03);

  osc.start();
  osc.stop(audioContext.currentTime + 0.03);
}

// å›åˆé–‹å§‹éŸ³æ•ˆ
function playRoundStartSound(volume) {
  const notes = [523, 659, 784]; // C5, E5, G5
  notes.forEach((freq, i) => {
    setTimeout(() => {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();

      osc.type = 'sine';
      osc.frequency.value = freq;

      osc.connect(gain);
      gain.connect(audioContext.destination);
      gain.gain.setValueAtTime(volume * 0.15, audioContext.currentTime);
      gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.2);

      osc.start();
      osc.stop(audioContext.currentTime + 0.2);
    }, i * 100);
  });
}

// å‹åˆ©éŸ³æ•ˆ
function playVictorySound(volume) {
  const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
  notes.forEach((freq, i) => {
    setTimeout(() => {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();

      osc.type = 'sine';
      osc.frequency.value = freq;

      osc.connect(gain);
      gain.connect(audioContext.destination);
      gain.gain.setValueAtTime(volume * 0.2, audioContext.currentTime);
      gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.4);

      osc.start();
      osc.stop(audioContext.currentTime + 0.4);
    }, i * 150);
  });
}

// è¡é‹’éŸ³æ•ˆ
function playChargeSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(100, audioContext.currentTime);
  osc.frequency.linearRampToValueAtTime(300, audioContext.currentTime + 0.3);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.15, audioContext.currentTime);
  gain.gain.linearRampToValueAtTime(volume * 0.25, audioContext.currentTime + 0.2);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.35);

  osc.start();
  osc.stop(audioContext.currentTime + 0.35);
}

// éª°å­éŸ³æ•ˆ
function playDiceSound(volume) {
  for (let i = 0; i < 3; i++) {
    setTimeout(() => {
      const noise = createNoiseBuffer(0.05);
      const source = audioContext.createBufferSource();
      source.buffer = noise;

      const filter = audioContext.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 3000;

      const gain = audioContext.createGain();
      gain.gain.setValueAtTime(volume * 0.15, audioContext.currentTime);
      gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.05);

      source.connect(filter);
      filter.connect(gain);
      gain.connect(audioContext.destination);

      source.start();
      source.stop(audioContext.currentTime + 0.05);
    }, i * 50);
  }
}

// å‰µå»ºç™½å™ªéŸ³ç·©è¡å€
function createNoiseBuffer(duration) {
  const sampleRate = audioContext.sampleRate;
  const length = sampleRate * duration;
  const buffer = audioContext.createBuffer(1, length, sampleRate);
  const data = buffer.getChannelData(0);

  for (let i = 0; i < length; i++) {
    data[i] = Math.random() * 2 - 1;
  }

  return buffer;
}

// ç‚º GainNode æ·»åŠ æŒ‡æ•¸è¡°æ¸›æ–¹æ³•
AudioParam.prototype.exponentialDecayTo = function(value, endTime) {
  this.exponentialRampToValueAtTime(Math.max(0.001, value), endTime);
};

// ========== æˆ°å ´å°ºå¯¸è¨­å®š ==========
const BATTLEFIELD_SIZES = {
  "combat-patrol": { width: 44, height: 30, name: "Combat Patrol", desc: "å°å‹å°æˆ°ï¼Œé©åˆ 500 é»ä»¥ä¸‹", deployZone: 6 },
  "incursion": { width: 44, height: 30, name: "Incursion", desc: "å°å‹å°æˆ°ï¼Œé©åˆ 500-1000 é»", deployZone: 9 },
  "strike-force": { width: 60, height: 44, name: "Strike Force", desc: "æ¨™æº–å°æˆ°ï¼Œé©åˆ 1000-2000 é»", deployZone: 12 },
  "onslaught": { width: 90, height: 44, name: "Onslaught", desc: "å¤§å‹å°æˆ°ï¼Œé©åˆ 2000+ é»", deployZone: 12 }
};

// ========== åœ°åœ–å ´æ™¯è¨­å®š ==========
const MAP_SCENARIOS = {
  "standard": {
    name: "æ¨™æº–æˆ°å ´",
    desc: "å‡è¡¡é…ç½®çš„æ¨™æº–åœ°å½¢",
    generate: (w, h) => ({
      terrain: [
        { type: "ruins", x: w * 0.35, y: h * 0.3, width: 80, height: 60 },
        { type: "ruins", x: w * 0.65, y: h * 0.7, width: 80, height: 60 },
        { type: "woods", x: w * 0.2, y: h * 0.6, width: 70, height: 70 },
        { type: "woods", x: w * 0.8, y: h * 0.4, width: 70, height: 70 },
        { type: "crater", x: w * 0.5, y: h * 0.5, width: 50, height: 50 },
        { type: "barricade", x: w * 0.4, y: h * 0.15, width: 60, height: 20 },
        { type: "barricade", x: w * 0.6, y: h * 0.85, width: 60, height: 20 }
      ],
      objectives: [
        { id: 1, x: w * 0.5, y: h * 0.5 },
        { id: 2, x: w * 0.25, y: h * 0.3 },
        { id: 3, x: w * 0.25, y: h * 0.7 },
        { id: 4, x: w * 0.75, y: h * 0.3 },
        { id: 5, x: w * 0.75, y: h * 0.7 }
      ]
    })
  },
  "city": {
    name: "åŸå¸‚å»¢å¢Ÿ",
    desc: "å¯†é›†å»ºç¯‰å’Œæ©é«”ï¼Œé©åˆæ­¥å…µæˆ°",
    generate: (w, h) => ({
      terrain: [
        { type: "ruins", x: w * 0.2, y: h * 0.25, width: 90, height: 70 },
        { type: "ruins", x: w * 0.5, y: h * 0.2, width: 80, height: 60 },
        { type: "ruins", x: w * 0.8, y: h * 0.25, width: 90, height: 70 },
        { type: "ruins", x: w * 0.35, y: h * 0.5, width: 70, height: 50 },
        { type: "ruins", x: w * 0.65, y: h * 0.5, width: 70, height: 50 },
        { type: "ruins", x: w * 0.2, y: h * 0.75, width: 90, height: 70 },
        { type: "ruins", x: w * 0.5, y: h * 0.8, width: 80, height: 60 },
        { type: "ruins", x: w * 0.8, y: h * 0.75, width: 90, height: 70 },
        { type: "barricade", x: w * 0.3, y: h * 0.35, width: 40, height: 15 },
        { type: "barricade", x: w * 0.7, y: h * 0.65, width: 40, height: 15 }
      ],
      objectives: [
        { id: 1, x: w * 0.5, y: h * 0.5 },
        { id: 2, x: w * 0.3, y: h * 0.25 },
        { id: 3, x: w * 0.3, y: h * 0.75 },
        { id: 4, x: w * 0.7, y: h * 0.25 },
        { id: 5, x: w * 0.7, y: h * 0.75 }
      ]
    })
  },
  "forest": {
    name: "å¯†æ—åœ°å¸¶",
    desc: "å¤§ç‰‡æ£®æ—ï¼Œé™åˆ¶è¦–ç·šå’Œç§»å‹•",
    generate: (w, h) => ({
      terrain: [
        { type: "woods", x: w * 0.15, y: h * 0.3, width: 100, height: 90 },
        { type: "woods", x: w * 0.15, y: h * 0.7, width: 100, height: 90 },
        { type: "woods", x: w * 0.4, y: h * 0.5, width: 80, height: 80 },
        { type: "woods", x: w * 0.6, y: h * 0.5, width: 80, height: 80 },
        { type: "woods", x: w * 0.85, y: h * 0.3, width: 100, height: 90 },
        { type: "woods", x: w * 0.85, y: h * 0.7, width: 100, height: 90 },
        { type: "crater", x: w * 0.5, y: h * 0.25, width: 50, height: 50 },
        { type: "crater", x: w * 0.5, y: h * 0.75, width: 50, height: 50 }
      ],
      objectives: [
        { id: 1, x: w * 0.5, y: h * 0.5 },
        { id: 2, x: w * 0.2, y: h * 0.5 },
        { id: 3, x: w * 0.8, y: h * 0.5 },
        { id: 4, x: w * 0.5, y: h * 0.2 },
        { id: 5, x: w * 0.5, y: h * 0.8 }
      ]
    })
  },
  "wasteland": {
    name: "è’é‡æˆ°å ´",
    desc: "é–‹é—˜å¹³åŸï¼Œå°‘é‡æ©é«”ï¼Œé©åˆè¼‰å…·",
    generate: (w, h) => ({
      terrain: [
        { type: "crater", x: w * 0.25, y: h * 0.3, width: 60, height: 60 },
        { type: "crater", x: w * 0.75, y: h * 0.7, width: 60, height: 60 },
        { type: "crater", x: w * 0.5, y: h * 0.5, width: 70, height: 70 },
        { type: "barricade", x: w * 0.35, y: h * 0.6, width: 50, height: 20 },
        { type: "barricade", x: w * 0.65, y: h * 0.4, width: 50, height: 20 },
        { type: "ruins", x: w * 0.15, y: h * 0.5, width: 60, height: 50 },
        { type: "ruins", x: w * 0.85, y: h * 0.5, width: 60, height: 50 }
      ],
      objectives: [
        { id: 1, x: w * 0.5, y: h * 0.5 },
        { id: 2, x: w * 0.25, y: h * 0.25 },
        { id: 3, x: w * 0.25, y: h * 0.75 },
        { id: 4, x: w * 0.75, y: h * 0.25 },
        { id: 5, x: w * 0.75, y: h * 0.75 }
      ]
    })
  },
  "fortress": {
    name: "è¦å¡æ”»é˜²",
    desc: "ä¸€å´æœ‰å¤§å‹é˜²ç¦¦å·¥äº‹ï¼Œæ”»é˜²ä¸å°ç¨±",
    generate: (w, h) => ({
      terrain: [
        // é˜²å®ˆæ–¹ï¼ˆå³å´ï¼‰çš„è¦å¡
        { type: "building", x: w * 0.85, y: h * 0.5, width: 100, height: 150 },
        { type: "barricade", x: w * 0.7, y: h * 0.3, width: 80, height: 25 },
        { type: "barricade", x: w * 0.7, y: h * 0.7, width: 80, height: 25 },
        { type: "barricade", x: w * 0.7, y: h * 0.5, width: 80, height: 25 },
        // é€²æ”»æ–¹çš„æ©è­·
        { type: "crater", x: w * 0.3, y: h * 0.3, width: 60, height: 60 },
        { type: "crater", x: w * 0.3, y: h * 0.7, width: 60, height: 60 },
        { type: "crater", x: w * 0.45, y: h * 0.5, width: 50, height: 50 },
        { type: "ruins", x: w * 0.15, y: h * 0.5, width: 70, height: 60 }
      ],
      objectives: [
        { id: 1, x: w * 0.85, y: h * 0.5 },  // è¦å¡æ ¸å¿ƒ
        { id: 2, x: w * 0.6, y: h * 0.3 },   // è¦å¡å‰ç·š
        { id: 3, x: w * 0.6, y: h * 0.7 },   // è¦å¡å‰ç·š
        { id: 4, x: w * 0.3, y: h * 0.5 },   // ä¸­å ´
        { id: 5, x: w * 0.15, y: h * 0.5 }   // é€²æ”»æ–¹èµ·é»
      ]
    })
  },
  "random": {
    name: "éš¨æ©Ÿç”Ÿæˆ",
    desc: "éš¨æ©Ÿé…ç½®åœ°å½¢å’Œç›®æ¨™é»",
    generate: (w, h) => {
      const terrainTypes = ["ruins", "woods", "crater", "barricade", "building"];
      const terrain = [];
      const numTerrain = 5 + Math.floor(Math.random() * 5);

      for (let i = 0; i < numTerrain; i++) {
        const type = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
        terrain.push({
          type,
          x: w * (0.2 + Math.random() * 0.6),
          y: h * (0.15 + Math.random() * 0.7),
          width: 40 + Math.random() * 60,
          height: type === "barricade" ? 15 + Math.random() * 15 : 40 + Math.random() * 50
        });
      }

      const objectives = [
        { id: 1, x: w * 0.5, y: h * 0.5 }
      ];
      const numObjectives = 4;
      for (let i = 0; i < numObjectives; i++) {
        objectives.push({
          id: i + 2,
          x: w * (0.2 + Math.random() * 0.6),
          y: h * (0.2 + Math.random() * 0.6)
        });
      }

      return { terrain, objectives };
    }
  }
};

// ç•¶å‰é¸æ“‡çš„æˆ°å ´è¨­å®š
let selectedBattlefieldSize = "strike-force";
let selectedMapScenario = "standard";

// ========== ç¨®æ—è¦å‰‡ï¼ˆDetachment Rulesï¼‰==========
const DETACHMENT_RULES = {
  "necrons": {
    "awakened-dynasty": {
      name: "è¦ºé†’ç‹æœ Awakened Dynasty",
      description: "æŒ‡æ®å”è­°ï¼šç•¶è§’è‰²é ˜å°å–®ä½æ™‚ï¼Œè©²å–®ä½æ‰€æœ‰å‘½ä¸­æ“²éª°+1ã€‚",
      effect: "+1 to Hit when CHARACTER leads unit",
      stratagems: [
        { name: "æ°¸æ†äº¡è€…å”è­°", cp: 1, desc: "å¾©æ´»è¢«æ‘§æ¯€çš„è§’è‰²ï¼ˆåŠè¡€ï¼‰" },
        { name: "ä¸æ»…è»åœ˜å”è­°", cp: 1, desc: "æ•µæ–¹å°„æ“Š/è¿‘æˆ°å¾Œè§¸ç™¼å¾©æ´»å”è­°" },
        { name: "é£¢æ¸´è™›ç©ºå”è­°", cp: 1, desc: "è¿‘æˆ°S+1ï¼Œè§’è‰²é ˜å°æ™‚APæ”¹é€²" },
        { name: "çªè¥²é¢¨æš´å”è­°", cp: 1, desc: "é ç¨‹æ­¦å™¨ç²å¾—[çªæ“Š]ï¼Œè§’è‰²é ˜å°å¯é‡æ“²è¡åˆº" },
        { name: "å¾æœæš´å›å”è­°", cp: 1, desc: "åŠå°„ç¨‹å…§é‡æ“²å‘½ä¸­1ï¼Œè§’è‰²é ˜å°å…¨é‡æ“²" },
        { name: "å¾©ä»‡æ˜Ÿè¾°å”è­°", cp: 2, desc: "æ•µæ–¹æ‘§æ¯€é™„è¿‘å–®ä½å¾Œï¼Œè§’è‰²å–®ä½å¯å°„æ“Š" }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Character") || context.hasLeader) {
          return { hitBonus: 1 };
        }
        return {};
      }
    },
    "annihilation-legion": {
      name: "æ®²æ»…è»åœ˜ Annihilation Legion",
      description: "æ®²æ»…å”è­°ï¼šæ¯€æ»…è€…å’Œå‰çš®è€…å¯é‡æ“²è¡é‹’ï¼Œè‹¥ç›®æ¨™ä½æ–¼åŠè¡€å‰‡+1è¡é‹’ã€‚æ¯€æ»…è€…å°„æ“Šæœ€è¿‘ç›®æ¨™æ™‚AP+1ã€‚",
      effect: "Destroyer Cult/Flayed Ones re-roll charges, +1 if target below half. +1 AP vs closest",
      stratagems: [
        { name: "æ­»äº¡é¢å…·", cp: 1, desc: "æ•µæ–¹å‘½ä¸­-1" },
        { name: "è™›å¼±æ°£æ¯", cp: 1, desc: "æ”»æ“Šå—å‚·æ•µäººå‘½ä¸­/è‡´å‚·+1" },
        { name: "æ®ºæˆ®å¾©æ´»", cp: 1, desc: "æ‘§æ¯€æ•µäººå¾Œè§¸ç™¼å¾©æ´»å”è­°" },
        { name: "ç„¡æƒ…çµæ‰‹", cp: 1, desc: "å †ç–Š/æ•´åˆç§»å‹•æ“´å±•è‡³6\"" },
        { name: "è¡€è…¥æ®˜æš´", cp: 1, desc: "æ•µæ–¹æ’¤é€€æ™‚é€ æˆè‡´å‘½å‚·ä¸¦è¿½æ“Š" },
        { name: "ç˜‹ç‹‚ä¹‹æ€’", cp: 1, desc: "è¢«æ‘§æ¯€å¾Œå‘æ•µæ–¹ç§»å‹•" }
      ],
      apply: (attacker, target, context) => {
        const isDestroyer = attacker.keywords?.includes("Destroyer") || attacker.keywords?.includes("Flayed");
        if (isDestroyer) {
          let bonus = { rerollCharge: true };
          if (target && target.currentHP <= target.maxHP / 2) {
            bonus.chargeBonus = 1;
          }
          if (context.phase === "shooting" && context.isClosestTarget) {
            bonus.apBonus = 1;
          }
          return bonus;
        }
        return {};
      }
    },
    "canoptek-court": {
      name: "å¹½éˆæ§‹è£é«”æ³•åº­ Canoptek Court",
      description: "èƒ½é‡çŸ©é™£ï¼šç¥•è¡“å¸«å’Œå¹½éˆæ§‹è£é«”é‡æ“²å‘½ä¸­1ï¼Œå®Œå…¨åœ¨çŸ©é™£å…§å‰‡å…¨é‡æ“²ã€‚çŸ©é™£æ ¹æ“šç›®æ¨™æ§åˆ¶æ“´å¼µã€‚",
      effect: "Cryptek/Canoptek re-roll 1s, full re-roll in Power Matrix",
      stratagems: [
        { name: "ç¥•è¡“å¸«è©›å’’", cp: 1, desc: "ç¥•è¡“å¸«è¢«æ‘§æ¯€å¾Œå¹½éˆæ§‹è£é«”å‘½ä¸­/è‡´å‚·+1" },
        { name: "æ®²æ»…æ ¸å¿ƒ", cp: 2, desc: "çŸ©é™£å…§ç¥•è¡“å¸«/å¹½éˆæ§‹è£é«”ç²å¾—[æ¯€æ»…æ€§å‚·å£]" },
        { name: "å¤ªé™½è„ˆè¡", cp: 1, desc: "ç›®æ¨™æ¨™è¨˜é™„è¿‘æ­¦å™¨ç²å¾—[ç„¡è¦–æ©è­·]" },
        { name: "åæ‡‰å­ç¨‹åº", cp: 1, desc: "å¹½éˆæ§‹è£é«”å¢å¼·ç§»å‹•åæ‡‰" }
      ],
      apply: (attacker, target, context) => {
        const isCryptek = attacker.keywords?.includes("Cryptek");
        const isCanoptek = attacker.keywords?.includes("Canoptek");
        if (isCryptek || isCanoptek) {
          if (context.inPowerMatrix) {
            return { rerollAllHits: true };
          }
          return { rerollHitOnes: true };
        }
        return {};
      }
    },
    "hypercrypt-legion": {
      name: "è¶…ç¶­å¯†å®¤è»åœ˜ Hypercrypt Legion",
      description: "è¶…ç¶­ç›¸ç§»ï¼šå–®ä½å¯åœ¨ç§»å‹•éšæ®µæ¶ˆå¤±ä¸¦åœ¨å°„æ“Šéšæ®µå‰é‡æ–°å‡ºç¾æ–¼9\"å¤–ã€‚æ·±å…¥æ‰“æ“Šå¾Œå¯èŠ±è²»2CPè¡é‹’ã€‚",
      effect: "Units can hyperphase, 2CP to charge after deep strike",
      stratagems: [
        { name: "è¶…ç¶­ä½ç§»", cp: 1, desc: "ç§»å‹•éšæ®µç§»é™¤å–®ä½ï¼Œå°„æ“Šéšæ®µå‰9\"å¤–é‡æ–°éƒ¨ç½²" },
        { name: "é–ƒç¾è¡é‹’", cp: 2, desc: "æ·±å…¥æ‰“æ“Šå¾Œå¯è¡é‹’" },
        { name: "ç¶­åº¦è£‚éš™", cp: 1, desc: "æ•µæ–¹ç„¡æ³•å°å‰›å‡ºç¾çš„å–®ä½åæ‡‰å°„æ“Š" }
      ],
      apply: (attacker, target, context) => {
        return { canHyperphase: true };
      }
    },
    "starshatter-arsenal": {
      name: "æ˜Ÿç¢è»æ¢°åº« Starshatter Arsenal",
      description: "ç„¡æƒ…çŒ›æ”»ï¼šæ”»æ“Šç›®æ¨™æ¨™è¨˜ç¯„åœå…§çš„å–®ä½æ™‚ï¼Œå‘½ä¸­+1ã€‚è¼‰å…·å’Œé¨ä¹˜å–®ä½é ç¨‹æ­¦å™¨ç²å¾—[çªæ“Š]ã€‚",
      effect: "+1 Hit vs units near objectives, Vehicles/Mounted get Assault",
      stratagems: [
        { name: "é›†ä¸­ç«åŠ›", cp: 1, desc: "åŒä¸€ç›®æ¨™å¤šå–®ä½å°„æ“Šæ™‚è‡´å‚·+1" },
        { name: "æ¯€æ»…å…‰æŸ", cp: 2, desc: "ä¸€å€‹å–®ä½æ‰€æœ‰æ­¦å™¨ç²å¾—[æ¯€æ»…æ€§å‚·å£]" },
        { name: "å£“åˆ¶ç«åŠ›", cp: 1, desc: "è¢«å°„æ“Šçš„å–®ä½ä¸‹å›åˆç§»å‹•-2\"" }
      ],
      apply: (attacker, target, context) => {
        let bonus = {};
        if (context.phase === "shooting" && context.nearObjective) {
          bonus.hitBonus = 1;
        }
        if (attacker.keywords?.includes("Vehicle") || attacker.keywords?.includes("Mounted")) {
          bonus.assault = true;
        }
        return bonus;
      }
    },
    "cursed-legion": {
      name: "è©›å’’è»åœ˜ Cursed Legion",
      description: "å†·é…·ç‹‚ç†±ï¼šæ¯€æ»…è€…æ­¦å™¨S+2ã€‚æ¯€æ»…è€…æ®²æ»…æ•µè»å¾Œï¼Œå‹è»æ­»éˆæ­¦å™¨S+2ï¼ˆæŒçºŒåˆ°å›åˆçµæŸï¼‰ã€‚",
      effect: "+2 Strength for Destroyer Cult, spreads on kill",
      stratagems: [
        { name: "ç„¡æ­¢ç›¡æ†æ¨", cp: 1, desc: "æ¯€æ»…è€…æ”»æ“Šæ™‚é‡æ“²æ‰€æœ‰è‡´å‚·" },
        { name: "ç˜‹ç‹‚å± æ®º", cp: 2, desc: "è¿‘æˆ°é¡å¤–æ”»æ“Šæ¬¡æ•¸ç­‰æ–¼å·²é€ æˆå‚·å®³æ•¸" }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Destroyer")) {
          return { strengthBonus: 2 };
        }
        if (context.destroyerKilledThisTurn) {
          return { strengthBonus: 2 };
        }
        return {};
      }
    },
    "pantheon-of-woe": {
      name: "ç½ç¦è¬ç¥æ®¿ Pantheon of Woe",
      description: "å®‡å®™æ‰­æ›²ï¼šC'tanç¢ç‰‡å’Œæ€ªç¸å–®ä½ç²å¾—æ‰­æ›²åŠ›å ´å…‰ç’°ï¼š6\"å…§æ•µè»å—åˆ°æ”»æ“Šæ™‚AP+1ã€‚å¯å¸¶å¤šå€‹C'tanã€‚",
      effect: "C'tan/Monster aura: +1 AP vs enemies within 6\"",
      stratagems: [
        { name: "ç¾å¯¦æ’•è£‚", cp: 2, desc: "C'tançš„æ”»æ“Šè‡ªå‹•é€ æˆè‡´å‘½å‚·ï¼ˆæ›¿ä»£æ­£å¸¸å‚·å®³ï¼‰" },
        { name: "æ˜Ÿç¥ä¹‹åŠ›", cp: 1, desc: "C'tançš„éˆèƒ½æ­¦å™¨å‚·å®³+1" },
        { name: "æ­»éˆçš®è†šç¶å®š", cp: 1, desc: "C'tanå—å‚·æ™‚é™„è¿‘æ­»éˆå–®ä½å¯åˆ†æ“”å‚·å®³" }
      ],
      apply: (attacker, target, context) => {
        if (context.nearAllyMonster || context.nearAllyCtan) {
          return { apBonus: 1 };
        }
        return {};
      }
    }
  },
  "tyranids": {
    "invasion-fleet": {
      name: "å…¥ä¾µè‰¦éšŠ Invasion Fleet",
      description: "è¶…é©æ‡‰ï¼šæˆ°é¬¥é–‹å§‹é¸æ“‡ä¸€ç¨®é©æ‡‰ï¼šèœ‚æ¹§æœ¬èƒ½ï¼ˆå°æ­¥å…µ/èŸ²ç¾¤æŒçºŒå‘½ä¸­1ï¼‰ã€è¶…ç´šä¾µç•¥ï¼ˆå°æ€ªç¸/è¼‰å…·è‡´å‘½æ‰“æ“Šï¼‰ã€èŸ²å·¢çµæ‰‹ï¼ˆå°è§’è‰²ç²¾æº–æ‰“æ“Šï¼‰ã€‚",
      effect: "Choose: Sustained Hits 1 vs Infantry, Lethal Hits vs Monster/Vehicle, or Precision vs Characters",
      stratagems: [
        { name: "å¿«é€Ÿå†ç”Ÿ", cp: 1, desc: "ç²å¾—6+ç„¡æ‡¼æ­»äº¡ï¼ˆçªè§¸ç¯„åœå…§5+ï¼‰" },
        { name: "è…ä¸Šè…ºç´ æ¿€å¢", cp: 2, desc: "è¿‘æˆ°æœªä¿®æ­£5+ç‚ºè‡´å‘½æ‰“æ“Š" },
        { name: "ç„¡ç›¡èŸ²ç¾¤", cp: 1, desc: "ç„¡ç›¡ç¾¤é«”å–®ä½æ¢å¾©D3+3æ¨¡å‹" },
        { name: "ç‹‚æš´çªè¥²", cp: 1, desc: "è¡é‹’å¾Œè¿‘æˆ°å‘½ä¸­+1" },
        { name: "è¶…é©æ‡‰é€²åŒ–", cp: 1, desc: "æœ¬å›åˆæ”¹è®Šè¶…é©æ‡‰é¸æ“‡" }
      ],
      adaptations: {
        "swarming": { name: "èœ‚æ¹§æœ¬èƒ½", effect: "vs Infantry/Swarm: Sustained Hits 1" },
        "aggression": { name: "è¶…ç´šä¾µç•¥", effect: "vs Monster/Vehicle: Lethal Hits" },
        "predator": { name: "èŸ²å·¢çµæ‰‹", effect: "vs Characters: Precision" }
      },
      apply: (attacker, target, context) => {
        const adaptation = context.selectedAdaptation || "swarming";
        if (adaptation === "swarming" && (target?.keywords?.includes("Infantry") || target?.keywords?.includes("Swarm"))) {
          return { sustainedHits: 1 };
        }
        if (adaptation === "aggression" && (target?.keywords?.includes("Monster") || target?.keywords?.includes("Vehicle"))) {
          return { lethalHits: true };
        }
        if (adaptation === "predator" && target?.keywords?.includes("Character")) {
          return { precision: true };
        }
        return {};
      }
    },
    "crusher-stampede": {
      name: "ç¢¾å£“ç‹‚æ½® Crusher Stampede",
      description: "ç‹‚æ€’å·¨ç¸ï¼šæ€ªç¸å–®ä½ä½æ–¼èµ·å§‹æ¨¡å‹æ•¸æ™‚å‘½ä¸­+1ï¼Œä½æ–¼åŠè¡€æ™‚è‡´å‚·+1ã€‚æ»¿ç·¨æ™‚OC+2ã€‚",
      effect: "Monsters: +1 Hit if below starting, +1 Wound if below half, +2 OC at full",
      stratagems: [
        { name: "è…è•å…§è‡Ÿ", cp: 1, desc: "è‡´å‘½çˆ†ç™¼è‡ªå‹•é€ æˆè‡´å‘½å‚·" },
        { name: "ç‹‚æš´æ€ªç¸", cp: 1, desc: "è¿‘æˆ°é‡æ“²æ‰€æœ‰å‘½ä¸­" },
        { name: "å·¨å¤§è¡æ“Š", cp: 1, desc: "è¡é‹’å¾Œæ“²6D6ï¼Œ4+å„é€ æˆ1è‡´å‘½å‚·" },
        { name: "å …éŸŒå¤–æ®¼", cp: 1, desc: "æ€ªç¸ç²å¾—5+ç„¡æ‡¼æ­»äº¡" }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Monster")) {
          let bonus = {};
          if (attacker.currentHP < attacker.maxHP) {
            bonus.hitBonus = 1;
          }
          if (attacker.currentHP <= attacker.maxHP / 2) {
            bonus.woundBonus = 1;
          }
          if (attacker.currentHP === attacker.maxHP) {
            bonus.ocBonus = 2;
          }
          return bonus;
        }
        return {};
      }
    },
    "unending-swarm": {
      name: "ç„¡ç›¡èŸ²æ½® Unending Swarm",
      description: "ç„¡å¯é˜»æ“‹ï¼šç„¡ç›¡ç¾¤é«”å–®ä½è¢«å°„æ“Šå¾Œé€²è¡Œã€Œæ¹§å‹•ç§»å‹•ã€ï¼Œå‘æœ€è¿‘æ•µäººç§»å‹•D6\"ã€‚",
      effect: "Endless Multitude units Surge D6\" toward enemies after being shot",
      stratagems: [
        { name: "çªè§¸é©…ç­–", cp: 1, desc: "é‡æ“²æ¹§å‹•è·é›¢ï¼Œå¯æ”¹å‘ç›®æ¨™æ¨™è¨˜ç§»å‹•" },
        { name: "ç„¡ç›¡æ³¢æµª", cp: 2, desc: "è¢«æ‘§æ¯€çš„ç„¡ç›¡ç¾¤é«”è¿”å›æˆ°ç•¥é å‚™éšŠï¼ˆæ¯æˆ°ä¸€æ¬¡ï¼‰" },
        { name: "èœ‚æ¹§ç¾¤é«”", cp: 1, desc: "15+æ¨¡å‹æ™‚æŒçºŒå‘½ä¸­1ï¼Œ5+ç‚ºè‡´å‘½æ‰“æ“Š" },
        { name: "æ·¹æ²’æˆ°ç·š", cp: 1, desc: "ç„¡ç›¡ç¾¤é«”è¡é‹’æ™‚æ•µæ–¹ç„¡æ³•åæ‡‰å°„æ“Š" }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Endless Multitude")) {
          return { canSurge: true, surgeDistance: "D6" };
        }
        return {};
      }
    },
    "assimilation-swarm": {
      name: "åŒåŒ–èŸ²ç¾¤ Assimilation Swarm",
      description: "é¤µé¤ŠèŸ²ç¾¤ï¼šæ”¶å‰²è€…å–®ä½åœ¨ç›®æ¨™æ¨™è¨˜é™„è¿‘å¯é€²è¡Œå†ç”Ÿï¼Œæ¢å¾©å‚·å£æˆ–å¾©æ´»æ¨¡å‹ã€‚åŸºå› ç«Šå–è€…æ¯å¤šä¸€å–®ä½OC+1ã€‚",
      effect: "Harvesters regenerate near objectives, Genestealers +1 OC per unit",
      stratagems: [
        { name: "æ„ŸæŸ“å­˜åœ¨", cp: 1, desc: "åŸºå› ç«Šå–è€…æ”»æ“Šå¾Œæ•µäººå¿…é ˆæˆ°æ…„æ¸¬è©¦" },
        { name: "ç•°å½¢é£¢é¤“", cp: 1, desc: "æ”¶å‰²è€…æ®ºæ•µå¾Œæ¢å¾©D3å‚·å£" },
        { name: "æ•™åœ˜å´›èµ·", cp: 2, desc: "åŸºå› ç«Šå–è€…æ·±å…¥æ‰“æ“Šè·é›¢æ”¹ç‚º6\"" }
      ],
      apply: (attacker, target, context) => {
        if (attacker.name?.includes("åŸºå› ç«Šå–è€…") || attacker.name?.includes("Genestealers")) {
          return { ocBonus: context.genestealerUnitCount || 1 };
        }
        if (attacker.keywords?.includes("Harvester") && context.nearObjective) {
          return { canRegenerate: true };
        }
        return {};
      }
    },
    "synaptic-nexus": {
      name: "çªè§¸ç¯€é» Synaptic Nexus",
      description: "çªè§¸å‘½ä»¤ï¼šæ¯å€‹æŒ‡æ®éšæ®µå¯å•Ÿå‹•å¼·å¤§çš„çªè§¸èƒ½åŠ›ï¼Œå½±éŸ¿çªè§¸ç¯„åœå…§æ‰€æœ‰å–®ä½ã€‚",
      effect: "Activate powerful Synaptic Imperatives each Command phase",
      stratagems: [
        { name: "èŸ²å·¢æ„å¿—", cp: 1, desc: "çªè§¸å–®ä½å’Œç¯„åœå…§å–®ä½é‡æ“²å‘½ä¸­1" },
        { name: "é©æ‡‰æœ¬èƒ½", cp: 1, desc: "é¸æ“‡å–®ä½ç²å¾—ä¸€ç¨®æ­¦å™¨é—œéµå­—åˆ°å›åˆçµæŸ" },
        { name: "éˆèƒ½å°–å˜¯", cp: 2, desc: "6\"å…§æ•µäºº-1é ˜å°å€¼ä¸¦å—D3è‡´å‘½å‚·" },
        { name: "èŸ²å·¢è­·ç›¾", cp: 1, desc: "çªè§¸ç¯„åœå…§å–®ä½ç²å¾—5+ç„¡æ‡¼æ­»äº¡" }
      ],
      imperatives: {
        "aggression": { name: "ä¾µç•¥å‘½ä»¤", effect: "è¿‘æˆ°æ”»æ“Š+1" },
        "adaptation": { name: "é©æ‡‰å‘½ä»¤", effect: "è­·ç”²è±å…+1" },
        "dominion": { name: "çµ±å¾¡å‘½ä»¤", effect: "OCç¿»å€" }
      },
      apply: (attacker, target, context) => {
        if (context.inSynapseRange) {
          const imperative = context.activeImperative || "aggression";
          if (imperative === "aggression") return { attackBonus: 1 };
          if (imperative === "adaptation") return { saveBonus: 1 };
          if (imperative === "dominion") return { ocMultiplier: 2 };
        }
        return {};
      }
    },
    "vanguard-onslaught": {
      name: "å…ˆé‹’æ”»å‹¢ Vanguard Onslaught",
      description: "æœå°‹è§¸é¬šï¼šä¼æ“Šè€…å’Œç¥ç¶“ä¼æ“Šè€…ç²å¾—å¢å¼·ç§»å‹•å’Œæ›´é çš„æ»²é€éƒ¨ç½²ã€‚",
      effect: "Lictors/Neurolictors enhanced infiltrate and movement",
      stratagems: [
        { name: "éš±åŒ¿æ½›ä¼è€…", cp: 1, desc: "ä¼æ“Šè€…åœ¨æ©è­·ä¸­-1è¢«å‘½ä¸­" },
        { name: "æš—å½±çªè¥²", cp: 1, desc: "æ·±å…¥æ‰“æ“Šå¾Œå¯å°„æ“Šä¸¦è¡é‹’" },
        { name: "ææ‡¼ä¹‹æº", cp: 2, desc: "æ•µæ–¹å–®ä½å¿…é ˆé€²è¡Œæˆ°æ…„æ¸¬è©¦æˆ–ç„¡æ³•åæ‡‰" }
      ],
      apply: (attacker, target, context) => {
        if (attacker.name?.includes("ä¼æ“Šè€…") || attacker.name?.includes("Lictor")) {
          return { enhancedInfiltrate: true, extraMove: 2 };
        }
        return {};
      }
    },
    "subterranean-assault": {
      name: "åœ°åº•çªè¥² Subterranean Assault",
      description: "çªæ“Šéš§é“ï¼šç©¿åœ°ç¸å’Œå·¨å£ç¸å¯å‰µå»ºéš§é“æ¨™è¨˜ã€‚å…¶ä»–é‘½åœ°è€…å¯å¾éš§é“éƒ¨ç½²ã€‚æ”»æ“Šæ™‚é‡æ“²å‘½ä¸­1ã€‚",
      effect: "Trygon/Mawloc create tunnels, Burrowers deploy from them, re-roll 1s to Hit",
      stratagems: [
        { name: "åœ°åº•ä¼æ“Š", cp: 2, desc: "å¾éš§é“éƒ¨ç½²çš„å–®ä½æœ¬å›åˆå¯è¡é‹’" },
        { name: "ææ€–çªç¾", cp: 1, desc: "å·¨å£ç¸æ·±å…¥æ‰“æ“Šæ™‚å°3\"å…§æ•µäººé€ æˆD3+3è‡´å‘½å‚·" },
        { name: "éš§é“ç¶²çµ¡", cp: 1, desc: "é‘½åœ°è€…å¯åœ¨éš§é“é–“å‚³é€" }
      ],
      apply: (attacker, target, context) => {
        return { rerollHitOnes: true };
      }
    },
    "warrior-bioform-onslaught": {
      name: "æˆ°å£«ç”Ÿé«”æ”»å‹¢ Warrior Bioform Onslaught",
      description: "é ˜è¢–å·¨ç¸ï¼šæ³°å€«æˆ°å£«ã€èŸ²æ—æˆ°å£«é¦–é ˜å’Œé£›ç¿¼é¦–é ˜ç²å¾—5+ç„¡æ•µè±å…å’Œçªè§¸èƒ½åŠ›ã€‚",
      effect: "Warriors/Prime get 5+ invulnerable save and Synapse",
      stratagems: [
        { name: "ç”Ÿé«”é©æ‡‰", cp: 1, desc: "æˆ°å£«å–®ä½ç²å¾—ä¸€ç¨®æ­¦å™¨é—œéµå­—" },
        { name: "èŸ²ç¾¤é ˜è¢–", cp: 1, desc: "æˆ°å£«é ˜å°çš„å–®ä½é‡æ“²å‘½ä¸­1" },
        { name: "å¼·åŒ–ç”²æ®¼", cp: 1, desc: "æˆ°å£«ç²å¾—4+ç„¡æ•µè±å…åˆ°å›åˆçµæŸ" }
      ],
      apply: (attacker, target, context) => {
        if (attacker.name?.includes("æˆ°å£«") || attacker.name?.includes("Warriors") || attacker.name?.includes("Prime")) {
          return { invSave: 5, hasSynapse: true };
        }
        return {};
      }
    }
  },
  "space-marines": {
    "gladius-task-force": {
      name: "æ ¼æ‹‰è¿ªçƒæ–¯ç‰¹é£éšŠ",
      description: "æ•™æ¢è¦å‰‡ï¼šæ”»æ“Šæ™‚é‡æ“²è‡´å‚·1ã€‚",
      effect: "Re-roll Wound rolls of 1",
      apply: () => ({ rerollWoundOnes: true })
    }
  },
  "chaos": {
    "slaves-to-darkness": {
      name: "é»‘æš—å¥´åƒ•",
      description: "Let the Galaxy Burnï¼šæ”»æ“Šç›®æ¨™æ¨™è¨˜ç¯„åœå…§å–®ä½æ™‚è‡´å‚·+1ã€‚",
      effect: "+1 to Wound vs units near objectives",
      apply: (attacker, target, context) => {
        if (context.nearObjective) return { woundBonus: 1 };
        return {};
      }
    }
  },
  "orks": {
    "waaagh-tribe": {
      name: "WAAAGH!éƒ¨æ—",
      description: "Waaagh!ï¼šè¡é‹’æˆåŠŸæ™‚æ”»æ“Š+1ï¼ŒS+1ã€‚",
      effect: "+1 Attack and +1 Strength on successful charge",
      apply: (attacker, target, context) => {
        if (context.charged) return { attackBonus: 1, strengthBonus: 1 };
        return {};
      }
    }
  }
};

// ç©å®¶é¸æ“‡çš„ç¨®æ—è¦å‰‡
let playerDetachments = { 1: null, 2: null };

// ========== å–®ä½è³‡æ–™åº«ï¼ˆæ ¹æ“šå®˜æ–¹10ç‰ˆè¦å‰‡æ›´æ–°ï¼‰==========
const UNIT_DATABASE = {
  "space-marines": {
    name: "æ˜Ÿéš›æˆ°å£«",
    color: "#3b82f6",
    units: [
      {
        id: "sm-captain",
        name: "é€£é•· Captain",
        points: 80,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/f/f6/SMCaptain10th.jpg/250px-SMCaptain10th.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 5, Ld: 6, OC: 1 },
        inv: 4,
        weapons: {
          ranged: { name: "é‡å‹çˆ†çŸ¢æ§", range: 30, A: 4, skill: 2, S: 5, AP: -1, D: 2 },
          melee: { name: "å‹•åŠ›åŠ", A: 5, skill: 2, S: 5, AP: -2, D: 2 }
        },
        abilities: ["é ˜è¢–: 6\"å…§å‹è»é‡æ“²å‘½ä¸­1", "Oath of Moment"]
      },
      {
        id: "sm-intercessors",
        name: "å…ˆé‹’æˆ°å£«Ã—5 Intercessors",
        points: 80,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/2/2a/Intercessor_Models_10E.jpg/300px-Intercessor_Models_10E.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 10, Ld: 6, OC: 2 },
        inv: null,
        weapons: {
          ranged: { name: "çˆ†çŸ¢æ­¥æ§ Bolt Rifle", range: 24, A: 2, skill: 3, S: 4, AP: -1, D: 1, keywords: ["Assault", "Heavy"] },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 3, skill: 3, S: 4, AP: 0, D: 1 }
        },
        abilities: ["ç›®æ¨™é–å®š: é¸å®šç›®æ¨™æ™‚+2æ”»æ“Š"]
      },
      {
        id: "sm-tactical",
        name: "æˆ°è¡“å°éšŠÃ—5 Tactical Squad",
        points: 85,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/5/55/TacticalSquad10.jpg/300px-TacticalSquad10.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 10, Ld: 6, OC: 2 },
        inv: null,
        weapons: {
          ranged: { name: "çˆ†çŸ¢æ§ Boltgun", range: 24, A: 2, skill: 3, S: 4, AP: 0, D: 1 },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 2, skill: 3, S: 4, AP: 0, D: 1 }
        },
        abilities: ["éˆæ´»éƒ¨ç½²: å¯å¾Œå‚™éƒ¨ç½²"]
      },
      {
        id: "sm-hellblasters",
        name: "åœ°ç„ç«æ§å…µÃ—5 Hellblasters",
        points: 115,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/6/6e/HellblasterMini10th.jpg/180px-HellblasterMini10th.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 10, Ld: 6, OC: 2 },
        inv: null,
        weapons: {
          ranged: { name: "ç­‰é›¢å­æ®²æ»…æ§ Plasma Incinerator", range: 24, A: 2, skill: 3, S: 7, AP: -2, D: 2, keywords: ["Hazardous"] },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 2, skill: 3, S: 4, AP: 0, D: 1 }
        },
        abilities: ["éè¼‰: Hazardousæ­¦å™¨"]
      },
      {
        id: "sm-dreadnought",
        name: "ç„¡ç•æ©Ÿç”² Redemptor Dreadnought",
        points: 210,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/c/c6/Redemptor8th.jpeg/220px-Redemptor8th.jpeg",
        stats: { M: 8, T: 10, Sv: 2, W: 12, Ld: 6, OC: 4 },
        inv: null,
        keywords: ["Vehicle", "Walker"],
        weapons: {
          ranged: { name: "é‡å‹ç ²å½ˆåŠ è¾²ç ²", range: 48, A: 6, skill: 3, S: 9, AP: -2, D: 3 },
          melee: { name: "ç„¡ç•ä¹‹æ‹³", A: 5, skill: 3, S: 12, AP: -3, D: 3 }
        },
        abilities: ["å …å®šä¸ç§»: è¡°æ¸›æª”æ¡ˆ"]
      }
    ]
  },
  "necrons": {
    name: "æ­»éˆ",
    color: "#22c55e",
    units: [
      { id: "nc-overlord", name: "éœ¸ä¸» Overlord", points: 85, img: "img/Necron/99070110006_OverlordTachyonArrow1.jpg", stats: { M: 5, T: 5, Sv: 2, W: 6, Ld: 6, OC: 1 }, inv: 4, weapons: { ranged: { name: "è¶…å…‰é€Ÿç®­", range: 72, A: 1, skill: 2, S: 16, AP: -5, D: "D6+2", oneUse: true }, melee: { name: "è™›ç©ºä¹‹åˆƒ", A: 4, skill: 2, S: 8, AP: -3, D: 2 } }, abilities: ["é ˜å°å…‰ç’°", "å¾©æ´»å”è­°"] },
      { id: "nc-silentking", name: "æ²‰é»˜ä¹‹ç‹ Silent King", points: 400, img: "img/Necron/99120110047_NECSzarekhSilentKingLead.jpg", stats: { M: 8, T: 10, Sv: 2, W: 16, Ld: 6, OC: 6 }, inv: 4, weapons: { ranged: { name: "æ®²æ»…å…‰æŸ", range: 36, A: 6, skill: 2, S: 12, AP: -4, D: 3 }, melee: { name: "æ°¸æ†æ¬Šæ–", A: 6, skill: 2, S: 10, AP: -4, D: 3 } }, abilities: ["æˆ‘çš„æ„å¿—å³æ³•ä»¤", "å¾©æ´»å”è­°"] },
      { id: "nc-ctan-nightbringer", name: "å¤œé­˜æ˜Ÿç¥ Nightbringer", points: 315, img: "img/Necron/99120110088_NecronsCtanShardOfTheNightbringer01.jpg", stats: { M: 10, T: 11, Sv: 3, W: 16, Ld: 6, OC: 4 }, inv: 4, keywords: ["Monster", "C'tan"], weapons: { ranged: { name: "æ­»äº¡å‡è¦–", range: 18, A: "D3", skill: 2, S: 12, AP: -3, D: "D6+3" }, melee: { name: "æ”¶å‰²ä¹‹é®", A: 6, skill: 2, S: 14, AP: -4, D: "D6+2" } }, abilities: ["å¸å–ç”Ÿå‘½: è¿‘æˆ°å¾Œæ•µè»D3è‡´å‘½å‚·", "ä¸æ»…é‡‘å±¬: å‚·å®³-1", "å¾©æ´»å”è­°"] },
      { id: "nc-ctan-deceiver", name: "æ¬ºè©è€…æ˜Ÿç¥ Deceiver", points: 285, img: "img/Necron/99810110003_TheDeceiverNEW01.jpg", stats: { M: 8, T: 11, Sv: 3, W: 16, Ld: 6, OC: 4 }, inv: 4, keywords: ["Monster", "C'tan"], weapons: { ranged: { name: "å®‡å®™ç˜‹ç‹‚", range: 18, A: 3, skill: 2, S: 10, AP: -3, D: 3 }, melee: { name: "é‡‘è‰²çˆª", A: 6, skill: 2, S: 10, AP: -3, D: 3 } }, abilities: ["æ¬ºè©å¤§å¸«", "å¹»å½±", "ä¸æ»…é‡‘å±¬: å‚·å®³-1"] },
      { id: "nc-skorpekh-lord", name: "æ¯€æ»…è€…é ˜ä¸» Skorpekh Lord", points: 90, img: "img/Necron/99120110051_SkorpekhDestroyersLead.jpg", stats: { M: 8, T: 7, Sv: 3, W: 7, Ld: 6, OC: 2 }, inv: 4, keywords: ["Destroyer"], weapons: { ranged: null, melee: { name: "è¶…ç›¸ä½æ”¶å‰²å™¨", A: 6, skill: 2, S: 8, AP: -3, D: 2 } }, abilities: ["æ¯€æ»…ç‹‚ç†±", "å¾©æ´»å”è­°"] },
      { id: "nc-chronomancer", name: "æ™‚ç©ºè¡“å£« Chronomancer", points: 65, img: "img/Necron/99070110003_NECChronomancerLead.jpg", stats: { M: 5, T: 4, Sv: 4, W: 4, Ld: 6, OC: 1 }, inv: 4, keywords: ["Cryptek"], weapons: { ranged: null, melee: { name: "æ°¸æ†ä¹‹æ–", A: 3, skill: 3, S: 5, AP: -2, D: 2 } }, abilities: ["æ™‚é–“æ“æ§: 5+ç„¡è¦–å‚·å®³", "å¾©æ´»å”è­°"] },
      { id: "nc-technomancer", name: "æŠ€è¡“è¡“å£« Technomancer", points: 80, img: "img/Necron/99070110005_NECCryptekLead.jpg", stats: { M: 10, T: 4, Sv: 4, W: 4, Ld: 6, OC: 1 }, inv: null, keywords: ["Cryptek"], weapons: { ranged: { name: "å…‰æ–", range: 18, A: 2, skill: 3, S: 5, AP: -2, D: 1 }, melee: { name: "å…‰æ–", A: 2, skill: 3, S: 5, AP: -2, D: 1 } }, abilities: ["ä¿®å¾©å”è­°", "å¾©æ´»å”è­°"] },
      { id: "nc-immortals", name: "ä¸æœ½è€…Ã—5 Immortals", points: 70, img: "img/Necron/99120110057_NECImmortalsLead.jpg", stats: { M: 5, T: 5, Sv: 3, W: 5, Ld: 7, OC: 2 }, inv: null, weapons: { ranged: { name: "é«˜æ–¯çˆ†èƒ½æ§", range: 24, A: 2, skill: 3, S: 5, AP: -1, D: 1 }, melee: { name: "æ©Ÿæ¢°çˆª", A: 2, skill: 3, S: 4, AP: 0, D: 1 } }, abilities: ["è‡´å‘½å‘½ä¸­", "å¾©æ´»å”è­°"] },
      { id: "nc-warriors", name: "æˆ°å£«Ã—10 Warriors", points: 90, img: "img/Necron/99120110052_NecronWarriorsLead.jpg", stats: { M: 5, T: 4, Sv: 4, W: 10, Ld: 7, OC: 2 }, inv: null, weapons: { ranged: { name: "é«˜æ–¯é•·ç¬›", range: 24, A: 1, skill: 4, S: 4, AP: 0, D: 1 }, melee: { name: "æ©Ÿæ¢°çˆª", A: 1, skill: 4, S: 4, AP: 0, D: 1 } }, abilities: ["è‡´å‘½å‘½ä¸­", "å¾©æ´»å”è­°"] },
      { id: "nc-lychguard", name: "æš—è¡›Ã—5 Lychguard", points: 85, img: "img/Necron/99120110058_TriarchLychguardLead.jpg", stats: { M: 5, T: 5, Sv: 3, W: 10, Ld: 7, OC: 1 }, inv: 4, weapons: { ranged: null, melee: { name: "æˆ°é®", A: 2, skill: 3, S: 8, AP: -3, D: 2 } }, abilities: ["è­·è¡›å”è­°", "å¾©æ´»å”è­°"] },
      { id: "nc-skorpekh", name: "æ¯€æ»…è€…Ã—3 Skorpekh Destroyers", points: 90, img: "img/Necron/99120110051_SkorpekhDestroyersLead.jpg", stats: { M: 8, T: 6, Sv: 3, W: 9, Ld: 7, OC: 2 }, inv: null, keywords: ["Destroyer"], weapons: { ranged: null, melee: { name: "è¶…ç›¸ä½æ­¦å™¨", A: 4, skill: 3, S: 7, AP: -2, D: 2 } }, abilities: ["æ¯€æ»…ç‹‚ç†±", "å¾©æ´»å”è­°"] },
      { id: "nc-deathmarks", name: "æ­»äº¡æ¨™è¨˜Ã—5 Deathmarks", points: 60, img: "img/Necron/99120110057_NECImmortalsGroup2.jpg", stats: { M: 5, T: 5, Sv: 3, W: 5, Ld: 7, OC: 1 }, inv: null, weapons: { ranged: { name: "çªè§¸ç“¦è§£æ§", range: 36, A: 1, skill: 3, S: 5, AP: -2, D: 2 }, melee: { name: "æ©Ÿæ¢°çˆª", A: 1, skill: 4, S: 4, AP: 0, D: 1 } }, abilities: ["ç‹™æ“Š", "æ·±å…¥æ‰“æ“Š"] },
      { id: "nc-flayed", name: "å‰çš®è€…Ã—5 Flayed Ones", points: 60, img: "img/Necron/99120110056_NECFlayedOnesLead.jpg", stats: { M: 5, T: 4, Sv: 4, W: 5, Ld: 7, OC: 1 }, inv: null, weapons: { ranged: null, melee: { name: "å‰çš®çˆª", A: 4, skill: 3, S: 4, AP: -1, D: 1 } }, abilities: ["ææ‡¼", "æ·±å…¥æ‰“æ“Š"] },
      { id: "nc-triarch", name: "ä¸‰çš‡ç¦è¡›Ã—5 Triarch Praetorians", points: 90, img: "img/Necron/99120110058_NecronsTriarchPraetoriansLead.jpg", stats: { M: 10, T: 5, Sv: 3, W: 10, Ld: 7, OC: 1 }, inv: null, weapons: { ranged: { name: "è–ç´„ä¹‹æ–", range: 12, A: 2, skill: 3, S: 5, AP: -2, D: 1 }, melee: { name: "è–ç´„ä¹‹æ–", A: 3, skill: 3, S: 5, AP: -2, D: 1 } }, abilities: ["é£›è¡Œ", "å¾©æ´»å”è­°"] },
      { id: "nc-ophydian", name: "è›‡å½¢æ¯€æ»…è€…Ã—3 Ophydian Destroyers", points: 80, img: "img/Necron/99120110053_NECOphydianDestroyersLead.jpg", stats: { M: 10, T: 5, Sv: 4, W: 9, Ld: 7, OC: 2 }, inv: null, keywords: ["Destroyer"], weapons: { ranged: null, melee: { name: "è¶…ç›¸ä½æ­¦å™¨", A: 5, skill: 3, S: 6, AP: -2, D: 2 } }, abilities: ["æ·±å…¥æ‰“æ“Š", "å¾©æ´»å”è­°"] },
      { id: "nc-wraiths", name: "å¹½éˆÃ—3 Canoptek Wraiths", points: 110, img: "img/Necron/99120110060_NECCanoptekWraithsLead.jpg", stats: { M: 10, T: 6, Sv: 3, W: 12, Ld: 8, OC: 2 }, inv: 4, keywords: ["Canoptek"], weapons: { ranged: null, melee: { name: "æƒ¡æ¯’çˆª", A: 4, skill: 3, S: 6, AP: -2, D: 2 } }, abilities: ["ç›¸ä½å½¢æ…‹: ç©¿ç‰†", "å¾©æ´»å”è­°"] },
      { id: "nc-scarabs", name: "ç”²èŸ²ç¾¤Ã—3 Scarab Swarms", points: 40, img: "img/Necron/99120110061_CanoptekSpyderLead.jpg", stats: { M: 10, T: 2, Sv: 6, W: 12, Ld: 8, OC: 0 }, inv: null, keywords: ["Canoptek"], weapons: { ranged: null, melee: { name: "é¤µé£Ÿé¡", A: 6, skill: 5, S: 2, AP: 0, D: 1 } }, abilities: ["è‡ªçˆ†æ”»æ“Š"] },
      { id: "nc-doomstalker", name: "æœ«æ—¥è¡Œè€… Doomstalker", points: 140, img: "img/Necron/99120110045_CanoptekDoomstalkerLead.jpg", stats: { M: 8, T: 8, Sv: 3, W: 12, Ld: 8, OC: 4 }, inv: 4, keywords: ["Vehicle", "Canoptek"], weapons: { ranged: { name: "æœ«æ—¥çˆ†èƒ½ç ²", range: 48, A: "D6+1", skill: 4, S: 14, AP: -3, D: 3 }, melee: { name: "æ©Ÿæ¢°è‚¢", A: 3, skill: 4, S: 6, AP: 0, D: 1 } }, abilities: ["é‡ç«åŠ›æ¨¡å¼"] },
      { id: "nc-doomsdayark", name: "æœ«æ—¥æ–¹èˆŸ Doomsday Ark", points: 200, img: "img/Necron/99120110063_NECDoomsdayArkLead.jpg", stats: { M: 10, T: 9, Sv: 3, W: 14, Ld: 7, OC: 5 }, inv: 4, keywords: ["Vehicle"], weapons: { ranged: { name: "æœ«æ—¥ç ²", range: 48, A: "D6+2", skill: 4, S: 15, AP: -4, D: 4 }, melee: { name: "æ©Ÿæ¢°è‚¢", A: 3, skill: 4, S: 6, AP: 0, D: 1 } }, abilities: ["é‡ç«åŠ›å¹³å°"] },
      { id: "nc-annihilation", name: "æ®²æ»…é§èˆ¹ Annihilation Barge", points: 105, img: "img/Necron/99120110064_CatacombAnnihilationBargeLead.jpg", stats: { M: 10, T: 8, Sv: 3, W: 9, Ld: 7, OC: 3 }, inv: null, keywords: ["Vehicle"], weapons: { ranged: { name: "é›™è¯ç‰¹æ–¯æ‹‰æ¯€æ»…è€…", range: 24, A: 8, skill: 4, S: 8, AP: 0, D: 2 }, melee: { name: "æ©Ÿæ¢°è‚¢", A: 3, skill: 4, S: 6, AP: 0, D: 1 } }, abilities: ["æŒçºŒå‘½ä¸­2"] },
      { id: "nc-ghostark", name: "å¹½éˆæ–¹èˆŸ Ghost Ark", points: 115, img: "img/Necron/99120110063_NECGhostArkLead.jpg", stats: { M: 10, T: 9, Sv: 3, W: 14, Ld: 7, OC: 3 }, inv: null, keywords: ["Vehicle"], weapons: { ranged: { name: "é«˜æ–¯é•·ç¬›é™£åˆ—", range: 24, A: 20, skill: 4, S: 4, AP: 0, D: 1 }, melee: { name: "æ©Ÿæ¢°è‚¢", A: 3, skill: 4, S: 6, AP: 0, D: 1 } }, abilities: ["é‹è¼¸: 10æ¨¡å‹", "ä¿®å¾©å”è­°"] },
      { id: "nc-monolith", name: "é‡‘å­—å¡” Monolith", points: 400, img: "img/Necron/99120110043_NECMonolithLead.jpg", stats: { M: 8, T: 13, Sv: 2, W: 22, Ld: 7, OC: 8 }, inv: 4, keywords: ["Vehicle", "Titanic"], weapons: { ranged: { name: "ç²’å­é­", range: 24, A: 6, skill: 3, S: 12, AP: -3, D: 3 }, melee: { name: "å·¨å‹æ©Ÿæ¢°è‚¢", A: 6, skill: 4, S: 10, AP: -2, D: 2 } }, abilities: ["å‚³é€é–€", "ä¸å¯æ‘§æ¯€"] },
      { id: "nc-lokhust", name: "é‡å‹æ¯€æ»…è€… Lokhust Heavy Destroyers", points: 55, img: "img/Necron/99120110044_LokhustHeavyDestroyerLead.jpg", stats: { M: 8, T: 6, Sv: 3, W: 4, Ld: 7, OC: 2 }, inv: null, keywords: ["Destroyer", "Mounted"], weapons: { ranged: { name: "é«˜æ–¯æ¯€æ»…è€…", range: 36, A: 2, skill: 3, S: 10, AP: -3, D: 4 }, melee: { name: "æ©Ÿæ¢°çˆª", A: 2, skill: 4, S: 5, AP: 0, D: 1 } }, abilities: ["é‡ç«åŠ›", "å¾©æ´»å”è­°"] },
      { id: "nc-triarchstalker", name: "ä¸‰çš‡è¿½çµè€… Triarch Stalker", points: 110, img: "img/Necron/99120110058_NecronTriarchStalkerLead.jpg", stats: { M: 8, T: 8, Sv: 3, W: 12, Ld: 7, OC: 4 }, inv: null, keywords: ["Vehicle", "Walker"], weapons: { ranged: { name: "ç†±èƒ½å°„ç·š", range: 18, A: 2, skill: 3, S: 12, AP: -4, D: "D6" }, melee: { name: "å·¨çˆª", A: 4, skill: 4, S: 8, AP: -2, D: 2 } }, abilities: ["ç›®æ¨™é–å®š", "å¾©æ´»å”è­°"] },
      // ===== Faction Pack æ–°å–®ä½ =====
      { id: "nc-ctan-voiddragon", name: "è™›ç©ºé¾æ˜Ÿç¥ Void Dragon", points: 295, img: "img/Necron/99120110054_CTanShardoftheVoidDragonLead.jpg", stats: { M: 10, T: 11, Sv: 3, W: 16, Ld: 6, OC: 4 }, inv: 4, keywords: ["Monster", "C'tan"], weapons: { ranged: { name: "è™›ç©ºä¹‹çŸ›", range: 12, A: "D3", skill: 2, S: 8, AP: -3, D: "D6+2", keywords: ["Anti-Vehicle 2+"] }, melee: { name: "è™›ç©ºä¹‹çŸ›", A: 5, skill: 2, S: 12, AP: -4, D: "D6+2" } }, abilities: ["ç‰©è³ªå¸æ”¶", "ä¸æ»…é‡‘å±¬", "å¾©æ´»å”è­°"] },
      { id: "nc-ctan-transcendent", name: "è¶…è¶Šæ˜Ÿç¥ Transcendent C'tan", points: 270, img: "img/Necron/99120110026_NecronTesseract01.jpg", stats: { M: 8, T: 11, Sv: 3, W: 16, Ld: 6, OC: 4 }, inv: 4, keywords: ["Monster", "C'tan"], weapons: { ranged: { name: "åœ°éœ‡æ”»æ“Š", range: 12, A: 6, skill: 2, S: 8, AP: -2, D: 2 }, melee: { name: "è£‚ç¸«è§¸æ‰‹", A: 8, skill: 2, S: 10, AP: -3, D: "D6" } }, abilities: ["è·¨ç¶­å‚³é€", "ä¸æ»…é‡‘å±¬", "å¾©æ´»å”è­°"] },
      { id: "nc-macrocytes", name: "å·¨ç´°èƒç¾¤Ã—5 Canoptek Macrocytes", points: 60, img: "img/Necron/99120110061_CanoptekSpyderLead.jpg", stats: { M: 8, T: 3, Sv: 4, W: 5, Ld: 8, OC: 1 }, inv: null, keywords: ["Beast", "Fly", "Canoptek"], weapons: { ranged: { name: "é«˜æ–¯è§£å‰–åˆ€", range: 18, A: 1, skill: 4, S: 4, AP: -1, D: 1, keywords: ["Lethal Hits"] }, melee: { name: "çˆªç‰™", A: 2, skill: 4, S: 4, AP: -1, D: 1 } }, abilities: ["åµå¯Ÿ8\"", "é¨·æ“¾ç¾¤: 3\"å…§æ•µè»-1å‘½ä¸­", "å¾©æ´»å”è­°"] },
      { id: "nc-tombcrawlers", name: "å¢“ç©´çˆ¬è¡Œè€…Ã—2 Tomb Crawlers", points: 50, img: "img/Necron/99120110061_CanoptekSpyderLead.jpg", stats: { M: 5, T: 4, Sv: 3, W: 6, Ld: 8, OC: 1 }, inv: null, keywords: ["Beast", "Canoptek"], weapons: { ranged: { name: "é›™è¯é«˜æ–¯æ”¶å‰²è€…", range: 12, A: 2, skill: 4, S: 4, AP: -1, D: 1 }, melee: { name: "çˆªç‰™", A: 4, skill: 4, S: 6, AP: -1, D: 1 } }, abilities: ["æ­¦å™¨å“¨å…µ: 12\"å…§ç„¡è¦–ä¿®æ­£", "å¾©æ´»å”è­°"] },
      { id: "nc-geomancer", name: "åœ°è¡“å£« Geomancer", points: 70, img: "img/Necron/99070110005_NECCryptekLead.jpg", stats: { M: 8, T: 4, Sv: 4, W: 4, Ld: 6, OC: 1 }, inv: null, keywords: ["Infantry", "Character", "Cryptek"], weapons: { ranged: { name: "éœ‡é¡«æˆŸ-å°„ç·š", range: 18, A: 2, skill: 4, S: 8, AP: -2, D: 2, keywords: ["Melta 2"] }, melee: { name: "éœ‡é¡«æˆŸ", A: 2, skill: 4, S: 8, AP: -2, D: 2 } }, abilities: ["åœ°éœ‡æ³¢å‹•: æ•µè»-2ç§»å‹•å’Œè¡é‹’", "é ˜å°è€…", "å¾©æ´»å”è­°"] },
      { id: "nc-nekrosor", name: "æ­»äº¡é ˜ä¸» Nekrosor Ammentar", points: 150, img: "img/Necron/99120110089_NecronsNekrosorAmmentar01.jpg", stats: { M: 10, T: 8, Sv: 3, W: 9, Ld: 6, OC: 3 }, inv: 4, keywords: ["Infantry", "Character", "Epic Hero", "Destroyer"], weapons: { ranged: { name: "æ¯€æ»…ç“¦è§£å™¨", range: 18, A: 4, skill: 2, S: 6, AP: -2, D: 1, keywords: ["Pistol", "Ignores Cover", "Sustained Hits 2"] }, melee: { name: "æ¯€æ»…æ‰‹å¥—", A: 6, skill: 2, S: 10, AP: -3, D: 3 } }, abilities: ["æ¯€æ»…ç‹‚ç†±å…‰ç’°: 6\"å…§æŒçºŒå‘½ä¸­1", "æ·±å…¥æ‰“æ“Š", "å…ˆæ”»", "å¾©æ´»å”è­°"] },
      // ===== æ›´å¤šå–®ä½ =====
      { id: "nc-hexmark", name: "å…­æ¨™æ¯€æ»…è€… Hexmark Destroyer", points: 70, img: "img/Necron/99120110048_HexmarkDestroyerLead.jpg", stats: { M: 7, T: 5, Sv: 3, W: 4, Ld: 7, OC: 1 }, inv: null, keywords: ["Infantry", "Character", "Destroyer"], weapons: { ranged: { name: "ç£è»Œæ‰‹æ§Ã—6", range: 18, A: 6, skill: 2, S: 6, AP: -1, D: 1, keywords: ["Pistol", "Precision"] }, melee: { name: "æ©Ÿæ¢°çˆª", A: 3, skill: 3, S: 5, AP: 0, D: 1 } }, abilities: ["å¤šç›®æ¨™å”è­°: å¯å°„æ“Š6å€‹ä¸åŒç›®æ¨™", "æ·±å…¥æ‰“æ“Š", "å¾©æ´»å”è­°"] },
      { id: "nc-royalwarden", name: "çš‡å®¶ç›£å¯Ÿå®˜ Royal Warden", points: 40, img: "img/Necron/99070110007_RoyalWarden1.jpg", stats: { M: 5, T: 5, Sv: 3, W: 4, Ld: 6, OC: 1 }, inv: null, keywords: ["Infantry", "Character"], weapons: { ranged: { name: "é«˜æ–¯çˆ†èƒ½æ§", range: 24, A: 2, skill: 3, S: 5, AP: -1, D: 1 }, melee: { name: "æ©Ÿæ¢°çˆª", A: 3, skill: 3, S: 5, AP: 0, D: 1 } }, abilities: ["æ’¤é€€é–‹ç«", "é ˜å°è€…", "å¾©æ´»å”è­°"] },
      { id: "nc-psychomancer", name: "éˆèƒ½è¡“å£« Psychomancer", points: 50, img: "img/Necron/99120110073_NECPsychomancerLead.jpg", stats: { M: 5, T: 4, Sv: 4, W: 4, Ld: 6, OC: 1 }, inv: 4, keywords: ["Infantry", "Character", "Cryptek"], weapons: { ranged: { name: "å¹»ç›¸æŠ•å°„å™¨", range: 18, A: "D6", skill: 3, S: 4, AP: -1, D: 1, keywords: ["Torrent"] }, melee: { name: "å¹»å½±ä¹‹åˆƒ", A: 3, skill: 3, S: 5, AP: -2, D: 1 } }, abilities: ["ææ‡¼å…‰ç’°: æ•µè»-1é ˜å°", "é ˜å°è€…", "å¾©æ´»å”è­°"] },
      { id: "nc-tombblades", name: "å¢“ç©´åˆ€é‹’Ã—3 Tomb Blades", points: 75, img: "img/Necron/99120110059_NECTombBladesLead.jpg", stats: { M: 12, T: 5, Sv: 3, W: 6, Ld: 7, OC: 2 }, inv: null, keywords: ["Mounted", "Fly"], weapons: { ranged: { name: "é›™è¯é«˜æ–¯çˆ†èƒ½æ§", range: 24, A: 4, skill: 3, S: 5, AP: -1, D: 1, keywords: ["Twin-linked"] }, melee: { name: "æ©Ÿæ¢°è‚¢", A: 2, skill: 4, S: 4, AP: 0, D: 1 } }, abilities: ["åµå¯Ÿ12\"", "å¾©æ´»å”è­°"] },
      { id: "nc-doomscythe", name: "æœ«æ—¥é®åˆ€ Doom Scythe", points: 200, img: "img/Necron/99120110065_DoomScytheLead.jpg", stats: { M: 20, T: 9, Sv: 3, W: 12, Ld: 7, OC: 0 }, inv: 4, keywords: ["Vehicle", "Aircraft", "Fly"], weapons: { ranged: { name: "æ­»äº¡å°„ç·š", range: 36, A: 1, skill: 3, S: 16, AP: -4, D: "D6+2", keywords: ["Blast"] }, melee: null }, abilities: ["è‡´å‘½æœ«æ—¥D6", "æ‡¸åœ"] },
      { id: "nc-commandbarge", name: "æŒ‡æ®é§èˆ¹ Catacomb Command Barge", points: 130, img: "img/Necron/99120110064_CatacombCommandBargeLead.jpg", stats: { M: 9, T: 8, Sv: 3, W: 9, Ld: 6, OC: 3 }, inv: 4, keywords: ["Vehicle", "Character"], weapons: { ranged: { name: "ç‰¹æ–¯æ‹‰ç ²", range: 24, A: 4, skill: 3, S: 7, AP: 0, D: 2, keywords: ["Sustained Hits 2"] }, melee: { name: "è™›ç©ºä¹‹åˆƒ", A: 4, skill: 2, S: 8, AP: -3, D: 2 } }, abilities: ["æˆ‘çš„æ„å¿—å³æ³•ä»¤", "å¾©æ´»å”è­°"] },
      { id: "nc-spyder", name: "åè«¾åŒ¹å…‹èœ˜è›› Canoptek Spyder", points: 75, img: "img/Necron/99120110061_CanoptekSpyderLead.jpg", stats: { M: 8, T: 7, Sv: 3, W: 6, Ld: 8, OC: 2 }, inv: null, keywords: ["Monster", "Canoptek"], weapons: { ranged: { name: "ç²’å­æŠ•å°„å™¨", range: 12, A: "D6", skill: 4, S: 6, AP: 0, D: 1, keywords: ["Blast"] }, melee: { name: "è‡ªå‹•ä¿®å¾©çˆª", A: 4, skill: 4, S: 8, AP: -2, D: 2 } }, abilities: ["ä¿®å¾©å”è­°: æ¯å›åˆæ²»ç™‚D3", "è£½é€ ç”²èŸ²", "å¾©æ´»å”è­°"] },
      { id: "nc-lokhust-destroyers", name: "æ´›åº«æ–¯ç‰¹æ¯€æ»…è€…Ã—3 Lokhust Destroyers", points: 90, img: "img/Necron/99120110071_NecronDestroyerretoolGroup.jpg", stats: { M: 8, T: 6, Sv: 3, W: 9, Ld: 7, OC: 2 }, inv: null, keywords: ["Mounted", "Fly", "Destroyer"], weapons: { ranged: { name: "é«˜æ–¯åŠ è¾²ç ²", range: 24, A: 3, skill: 3, S: 6, AP: -1, D: 2 }, melee: { name: "æ©Ÿæ¢°çˆª", A: 2, skill: 4, S: 5, AP: 0, D: 1 } }, abilities: ["æ¯€æ»…ç‹‚ç†±", "å¾©æ´»å”è­°"] },
      // ===== å‚³å¥‡è‹±é›„ =====
      { id: "nc-imotekh", name: "ä¼Šè«æ³°å…‹é¢¨æš´é ˜ä¸» Imotekh", points: 100, img: "img/Necron/99120110078_NECImotekhTheStormlord01.jpg", stats: { M: 5, T: 5, Sv: 2, W: 6, Ld: 5, OC: 1 }, inv: 4, keywords: ["Infantry", "Character", "Epic Hero"], weapons: { ranged: { name: "é¢¨æš´å¬å–š", range: 24, A: 6, skill: 2, S: 6, AP: -2, D: 2, keywords: ["Devastating Wounds"] }, melee: { name: "æˆ°é®", A: 4, skill: 2, S: 8, AP: -3, D: 2 } }, abilities: ["é¢¨æš´é ˜ä¸»: å‹è»6\"å…§+1å‘½ä¸­", "æˆ‘çš„æ„å¿—å³æ³•ä»¤", "å¾©æ´»å”è­°"] },
      { id: "nc-trazyn", name: "ç‰¹æ‹‰æ´¥ç„¡ç›¡è€… Trazyn the Infinite", points: 75, img: "img/Necron/99800110009_TrazynTheInfiniteNEW01.jpg", stats: { M: 5, T: 5, Sv: 2, W: 6, Ld: 6, OC: 1 }, inv: 4, keywords: ["Infantry", "Character", "Epic Hero"], weapons: { ranged: null, melee: { name: "æ™‚é–“ä¹‹çŸ›", A: 4, skill: 2, S: 8, AP: -3, D: 3 } }, abilities: ["æ”¶è—å®¶: æ“Šæ®ºè§’è‰²ç²å¾—1VP", "æ›¿èº«: å¯å°‡å‚·å®³è½‰ç§»çµ¦å‹è»", "å¾©æ´»å”è­°"] },
      { id: "nc-orikan", name: "å¥§é‡Œåå åœè€… Orikan the Diviner", points: 80, img: "img/Necron/99120110081_OrikanDiviner1.jpg", stats: { M: 5, T: 4, Sv: 4, W: 4, Ld: 6, OC: 1 }, inv: 4, keywords: ["Infantry", "Character", "Epic Hero", "Cryptek"], weapons: { ranged: { name: "æ™‚é–“åˆº", range: 18, A: 3, skill: 2, S: 6, AP: -2, D: 2 }, melee: { name: "æ™‚é–“ä¹‹æ–", A: 3, skill: 3, S: 5, AP: -2, D: "D3" } }, abilities: ["é è¨€: å¯é‡æ“²ä»»ä½•1æ¬¡æ“²éª°", "æ˜Ÿç¥åŒ–èº«: å›åˆ3+å¯å‡ç´šæ•¸æ“š", "å¾©æ´»å”è­°"] },
      { id: "nc-szeras", name: "ä¼Šé­¯ç±³è«¾Â·å¡æ‹‰æ–¯ Illuminor Szeras", points: 105, img: "img/Necron/99120110049_IlluminorSzerasLead.jpg", stats: { M: 7, T: 6, Sv: 3, W: 7, Ld: 6, OC: 2 }, inv: 4, keywords: ["Monster", "Character", "Epic Hero", "Cryptek"], weapons: { ranged: { name: "éˆèƒ½æ‰“æ“Š", range: 18, A: 2, skill: 2, S: 9, AP: -3, D: 3 }, melee: { name: "æ”¹é€ çˆª", A: 5, skill: 3, S: 6, AP: -2, D: 2 } }, abilities: ["æ©Ÿæ¢°ç”Ÿç‰©å¢å¼·: æ¯å›åˆ+1å‹è»æ•¸æ“š", "é ˜å°è€…", "å¾©æ´»å”è­°"] }
    ]
  },
  "tyranids": {
    name: "æ³°å€«èŸ²æ—",
    color: "#a855f7",
    units: [
      { id: "ty-swarmlord", name: "èŸ²ç¾¤éœ¸ä¸» Swarmlord", points: 220, img: "img/Tyranids/99120106060_SwarmlordLead.jpg", stats: { M: 8, T: 10, Sv: 2, W: 10, Ld: 7, OC: 3 }, inv: 4, weapons: { ranged: { name: "çªè§¸è„ˆè¡", range: 18, A: 3, skill: 2, S: 8, AP: -2, D: 3 }, melee: { name: "éª¨åŠ", A: 8, skill: 2, S: 9, AP: -2, D: 3 } }, abilities: ["èŸ²å·¢éœ¸ä¸»", "Synapse"] },
      { id: "ty-hivetyrant", name: "èŸ²å·¢æš´å› Hive Tyrant", points: 195, img: "img/Tyranids/99120106060_HiveTyrantLead.jpg", stats: { M: 8, T: 10, Sv: 2, W: 10, Ld: 7, OC: 3 }, inv: 4, weapons: { ranged: { name: "é‡æ¯’æ¶²ç ²", range: 36, A: 3, skill: 2, S: 9, AP: -2, D: 3 }, melee: { name: "å·¨å‹éª¨åŠ", A: 6, skill: 2, S: 9, AP: -2, D: 3 } }, abilities: ["Synapse", "æš—å½±ç± ç½©"] },
      { id: "ty-flyrant", name: "é£›ç¿¼æš´å› Winged Hive Tyrant", points: 170, img: "img/Tyranids/99120106060_WingedHiveTyrantLead.jpg", stats: { M: 12, T: 9, Sv: 2, W: 10, Ld: 7, OC: 3 }, inv: 4, keywords: ["Fly"], weapons: { ranged: { name: "é‡æ¯’æ¶²ç ²", range: 36, A: 3, skill: 2, S: 9, AP: -2, D: 3 }, melee: { name: "å·¨å‹éª¨åŠ", A: 6, skill: 2, S: 9, AP: -2, D: 3 } }, abilities: ["Synapse", "é£›è¡Œ"] },
      { id: "ty-broodlord", name: "è‚²æ¯èŸ² Broodlord", points: 80, img: "img/Tyranids/99120106059_BroodlordLead.jpg", stats: { M: 8, T: 5, Sv: 4, W: 6, Ld: 7, OC: 1 }, inv: 4, weapons: { ranged: null, melee: { name: "è‚²æ¯èŸ²çˆªç‰™", A: 6, skill: 2, S: 6, AP: -2, D: 2 } }, abilities: ["Synapse", "å‚¬çœ å‡è¦–"] },
      { id: "ty-neurotyrant", name: "ç¥ç¶“æš´å› Neurotyrant", points: 105, img: "img/Tyranids/99120106072_Neurolictor1.jpg", stats: { M: 6, T: 8, Sv: 4, W: 9, Ld: 7, OC: 3 }, inv: 4, weapons: { ranged: { name: "éˆèƒ½å°–å˜¯", range: 18, A: "D6", skill: 3, S: 5, AP: -1, D: 2 }, melee: { name: "å°¾åˆº", A: 3, skill: 4, S: 5, AP: 0, D: 1 } }, abilities: ["Synapse", "éˆèƒ½æ”¾å¤§"] },
      { id: "ty-tervigon", name: "ç¹æ®–ç¸ Tervigon", points: 160, img: "img/Tyranids/99120106066_Termagaunts2.jpg", stats: { M: 8, T: 11, Sv: 2, W: 16, Ld: 7, OC: 5 }, inv: null, weapons: { ranged: { name: "åˆºé‡é½Šå°„", range: 24, A: 8, skill: 3, S: 5, AP: 0, D: 1 }, melee: { name: "å·¨çˆª", A: 4, skill: 4, S: 10, AP: -2, D: "D6" } }, abilities: ["å­µåŒ–ç™½èŸ»", "Synapse"] },
      { id: "ty-termagants", name: "ç™½èŸ»Ã—10 Termagants", points: 60, img: "img/Tyranids/99120106066_Termagaunts2.jpg", stats: { M: 6, T: 3, Sv: 5, W: 10, Ld: 8, OC: 2 }, inv: null, weapons: { ranged: { name: "è‚‰èŸ²æ§", range: 18, A: 1, skill: 4, S: 5, AP: 0, D: 1 }, melee: { name: "ç”²æ®¼çˆªç‰™", A: 1, skill: 4, S: 3, AP: 0, D: 1 } }, abilities: ["æ½›è¡Œææ‡¼"] },
      { id: "ty-hormagaunts", name: "åˆºèŸ²Ã—10 Hormagaunts", points: 65, img: "img/Tyranids/99120106073_Hormagaunts2.jpg", stats: { M: 10, T: 3, Sv: 5, W: 10, Ld: 8, OC: 2 }, inv: null, weapons: { ranged: null, melee: { name: "åˆºèŸ²çˆª", A: 3, skill: 4, S: 3, AP: -1, D: 1 } }, abilities: ["èœ‚æ¹§è·³èº: Advanceå¾Œå¯è¡é‹’"] },
      { id: "ty-gargoyles", name: "ç¿¼èŸ²Ã—10 Gargoyles", points: 85, img: "img/Tyranids/99120106052_TYRGargoylesLead.jpg", stats: { M: 12, T: 3, Sv: 6, W: 10, Ld: 8, OC: 2 }, inv: null, keywords: ["Fly"], weapons: { ranged: { name: "è‚‰èŸ²æ§", range: 18, A: 1, skill: 4, S: 4, AP: 0, D: 1 }, melee: { name: "çˆªç‰™", A: 1, skill: 4, S: 3, AP: 0, D: 1 } }, abilities: ["é£›è¡Œ", "åµå¯Ÿ"] },
      { id: "ty-genestealers", name: "åŸºå› ç«Šå–è€…Ã—5 Genestealers", points: 75, img: "img/Tyranids/99120106068_Genestealers2.jpg", stats: { M: 8, T: 4, Sv: 5, W: 10, Ld: 7, OC: 1 }, inv: 5, weapons: { ranged: null, melee: { name: "åŸºå› ç«Šå–è€…çˆªç‰™", A: 4, skill: 2, S: 4, AP: -2, D: 1 } }, abilities: ["åµå¯Ÿ8\"", "å…ˆé‹’çµæ‰‹"] },
      { id: "ty-warriors", name: "èŸ²æ—æˆ°å£«Ã—3 Warriors", points: 65, img: "img/Tyranids/99120106058_TYRWarriorsLeadPrime.jpg", stats: { M: 6, T: 5, Sv: 4, W: 9, Ld: 7, OC: 2 }, inv: null, weapons: { ranged: { name: "æ­»äº¡å™´å°„", range: 18, A: 2, skill: 4, S: 5, AP: -1, D: 1 }, melee: { name: "æ¯’ç‰™åˆ©çˆª", A: 4, skill: 3, S: 5, AP: -2, D: 1 } }, abilities: ["Synapseç¯€é»"] },
      { id: "ty-zoanthropes", name: "éˆèƒ½ç¸Ã—3 Zoanthropes", points: 100, img: "img/Tyranids/99120106057_NeurothropesLead.jpg", stats: { M: 5, T: 5, Sv: 5, W: 9, Ld: 7, OC: 1 }, inv: 4, weapons: { ranged: { name: "æ‰­æ›²çˆ†ç‚¸", range: 24, A: "D3", skill: 3, S: 10, AP: -3, D: "D3+1" }, melee: { name: "çˆªç‰™", A: 3, skill: 4, S: 4, AP: 0, D: 1 } }, abilities: ["Synapse", "éˆèƒ½è­·ç›¾"] },
      { id: "ty-venomthropes", name: "æ¯’æ°£ç¸Ã—3 Venomthropes", points: 70, img: "img/Tyranids/99120106057_VenomthropesLead.jpg", stats: { M: 6, T: 5, Sv: 4, W: 9, Ld: 8, OC: 1 }, inv: null, weapons: { ranged: null, melee: { name: "æ¯’é­", A: 6, skill: 3, S: 4, AP: 0, D: 1 } }, abilities: ["æ¯’éœ§: 6\"å…§å‹è»-1è¢«å‘½ä¸­"] },
      { id: "ty-raveners", name: "æ å¥ªè€…Ã—5 Raveners", points: 125, img: "img/Tyranids/60010199057_LeviathanEXTRA15.jpg", stats: { M: 10, T: 5, Sv: 4, W: 15, Ld: 8, OC: 1 }, inv: null, keywords: ["Infantry", "Burrowers"], weapons: { ranged: null, melee: { name: "æ å¥ªè€…çˆªç‰™", A: 3, skill: 3, S: 5, AP: -2, D: 2, keywords: ["Twin-linked"] } }, abilities: ["æ·±å…¥æ‰“æ“Š", "åœ°åº•æ’¤é€€: å›åˆçµæŸå¯è¿”å›æˆ°ç•¥é å‚™éšŠ"] },
      { id: "ty-lictors", name: "ä¼æ“Šè€… Lictor", points: 60, img: "img/Tyranids/99120106069_Lictor1.jpg", stats: { M: 8, T: 6, Sv: 4, W: 6, Ld: 7, OC: 1 }, inv: null, weapons: { ranged: null, melee: { name: "ä¼æ“Šè€…çˆªç‰™", A: 6, skill: 2, S: 7, AP: -2, D: 2 } }, abilities: ["æ·±å…¥æ‰“æ“Š", "éš±åŒ¿çµæ‰‹"] },
      { id: "ty-carnifex", name: "å± æ®ºç¸ Carnifex", points: 90, img: "img/Tyranids/99120106031_CarnifexBrood01.jpg", stats: { M: 8, T: 9, Sv: 2, W: 8, Ld: 8, OC: 3 }, inv: null, weapons: { ranged: { name: "ç”ŸåŒ–ç ²", range: 12, A: "D3", skill: 4, S: 8, AP: -3, D: 2 }, melee: { name: "ç ´ç¢çˆª", A: 4, skill: 4, S: 12, AP: -3, D: "D6+1" } }, abilities: ["ä¸å¯é˜»æ“‹: è¡é‹’æ™‚+1å‚·å®³"] },
      { id: "ty-screamer", name: "å°–å˜¯æ®ºæ‰‹ Screamer-Killer", points: 125, img: "img/Tyranids/99120106031_ScreamerKillerBrood01.jpg", stats: { M: 8, T: 9, Sv: 2, W: 10, Ld: 8, OC: 3 }, inv: null, weapons: { ranged: { name: "ç”ŸåŒ–ç­‰é›¢å­å°–å˜¯", range: 18, A: "D6+3", skill: 4, S: 8, AP: -2, D: 2 }, melee: { name: "å°–å˜¯æ®ºæ‰‹çˆª", A: 6, skill: 4, S: 10, AP: -3, D: 3 } }, abilities: ["ææ‡¼å°–å˜¯"] },
      { id: "ty-exocrine", name: "å™´å°„ç¸ Exocrine", points: 140, img: "img/Tyranids/99120106056_ExocreneLead.jpg", stats: { M: 8, T: 10, Sv: 3, W: 14, Ld: 8, OC: 4 }, inv: null, weapons: { ranged: { name: "ç”ŸåŒ–ç­‰é›¢å­ç ²", range: 36, A: 6, skill: 3, S: 10, AP: -3, D: 3 }, melee: { name: "å¼·åŠ›çˆª", A: 3, skill: 4, S: 8, AP: -2, D: 2 } }, abilities: ["é‡ç«åŠ›æ¨¡å¼"] },
      { id: "ty-haruspex", name: "åå™¬ç¸ Haruspex", points: 125, img: "img/Tyranids/99120106026_Haruspex01.jpg", stats: { M: 8, T: 11, Sv: 3, W: 14, Ld: 8, OC: 4 }, inv: null, weapons: { ranged: null, melee: { name: "åå™¬ä¹‹é¡", A: 8, skill: 3, S: 12, AP: -3, D: 3 } }, abilities: ["åå™¬æ¢å¾©: é€ æˆå‚·å®³æ¢å¾©HP"] },
      { id: "ty-maleceptor", name: "æƒ¡æ„ç¸ Maleceptor", points: 170, img: "img/Tyranids/99120106033_Maleceptor01.jpg", stats: { M: 8, T: 11, Sv: 3, W: 14, Ld: 7, OC: 4 }, inv: 4, weapons: { ranged: { name: "éˆèƒ½éè¼‰", range: 18, A: "D6", skill: 3, S: 9, AP: -2, D: 3 }, melee: { name: "å·¨çˆª", A: 4, skill: 4, S: 9, AP: -2, D: 3 } }, abilities: ["Synapse", "éˆèƒ½å£“åˆ¶"] },
      { id: "ty-trygon", name: "ç©¿åœ°ç¸ Trygon", points: 140, img: "img/Tyranids/99120106019_TrygonNEW01.jpg", stats: { M: 10, T: 10, Sv: 3, W: 14, Ld: 8, OC: 4 }, inv: null, weapons: { ranged: { name: "ç”Ÿé›»è„ˆè¡", range: 12, A: 6, skill: 4, S: 5, AP: 0, D: 1 }, melee: { name: "ç©¿åœ°ç¸çˆª", A: 6, skill: 3, S: 10, AP: -2, D: 3 } }, abilities: ["æ·±å…¥æ‰“æ“Š", "åœ°åº•é€šé“"] },
      { id: "ty-mawloc", name: "å·¨å£ç¸ Mawloc", points: 135, img: "img/Tyranids/99120106019_MawlocNEW01.jpg", stats: { M: 10, T: 10, Sv: 3, W: 14, Ld: 8, OC: 4 }, inv: null, weapons: { ranged: null, melee: { name: "å·¨å£ä¹‹é¡", A: 12, skill: 4, S: 6, AP: -1, D: 1 } }, abilities: ["ææ€–çªç¾: æ·±å…¥æ‰“æ“Šæ™‚é€ æˆè‡´å‘½å‚·å®³"] },
      { id: "ty-tyrannofex", name: "æš´å›ç¸ Tyrannofex", points: 200, img: "img/Tyranids/99120106054_TYRTyrannofexLead.jpg", stats: { M: 9, T: 12, Sv: 2, W: 16, Ld: 8, OC: 5 }, inv: null, weapons: { ranged: { name: "ç ´è£‚ç ²", range: 48, A: 2, skill: 4, S: 18, AP: -4, D: "2D6" }, melee: { name: "å¼·åŠ›çˆª", A: 4, skill: 4, S: 10, AP: -2, D: 3 } }, abilities: ["é‡ç«åŠ›å¹³å°"] },
      { id: "ty-nornemissary", name: "å¤è€ä½¿è€… Norn Emissary", points: 260, img: "img/Tyranids/99120106064_NornEmissary1.jpg", stats: { M: 10, T: 11, Sv: 2, W: 16, Ld: 7, OC: 5 }, inv: 4, weapons: { ranged: { name: "éˆèƒ½è§¸é¬š", range: 18, A: "D6+1", skill: 2, S: 8, AP: -2, D: 2 }, melee: { name: "å·¨çˆª", A: 6, skill: 2, S: 12, AP: -3, D: "D6+2" } }, abilities: ["Synapse", "å¤è€æ™ºæ…§"] },
      { id: "ty-hive-guard", name: "èŸ²å·¢å®ˆè¡›Ã—3 Hive Guard", points: 90, img: "img/Tyranids/99120106055_TYRHiveGuardLead.jpg", stats: { M: 6, T: 7, Sv: 3, W: 12, Ld: 8, OC: 1 }, inv: null, weapons: { ranged: { name: "ç©¿åˆºç ²", range: 36, A: 2, skill: 3, S: 9, AP: -2, D: 3 }, melee: { name: "çˆªç‰™", A: 3, skill: 4, S: 5, AP: 0, D: 1 } }, abilities: ["ç„¡éœ€è¦–ç·š"] },
      { id: "ty-tyrantguard", name: "æš´å›è­·è¡›Ã—3 Tyrant Guard", points: 80, img: "img/Tyranids/60010199057_LeviathanEXTRA16.jpg", stats: { M: 6, T: 8, Sv: 3, W: 12, Ld: 8, OC: 1 }, inv: null, weapons: { ranged: null, melee: { name: "è£‚çˆª", A: 4, skill: 3, S: 7, AP: -2, D: 2 } }, abilities: ["è­·è¡›: å¯ç‚ºæš´å›æ‰¿å—å‚·å®³"] },
      { id: "ty-harpy", name: "é³¥å¦– Harpy", points: 215, img: "img/Tyranids/99120106024_Harpies01.jpg", stats: { M: 20, T: 9, Sv: 3, W: 12, Ld: 8, OC: 0 }, inv: null, keywords: ["Fly", "Aircraft"], weapons: { ranged: { name: "é›™è¯çµæ®ºç ²", range: 36, A: 8, skill: 4, S: 7, AP: -1, D: 2 }, melee: { name: "çˆªç‰™", A: 4, skill: 4, S: 6, AP: -1, D: 2 } }, abilities: ["é£›è¡Œå™¨", "æŠ•å½ˆ"] },
      // ===== Faction Pack æ–°å–®ä½ =====
      { id: "ty-hyperraveners", name: "è¶…é©æ‡‰æ å¥ªè€… Hyperadapted Raveners", points: 165, img: "img/Tyranids/60010199057_LeviathanEXTRA15.jpg", stats: { M: 10, T: 5, Sv: 4, W: 15, Ld: 7, OC: 1 }, inv: null, keywords: ["Infantry", "Burrowers", "Synapse", "Leader"], weapons: { ranged: { name: "æ¯’æ¶²å½ˆ", range: 12, A: "D6+3", skill: 0, S: 6, AP: -1, D: 1, keywords: ["Assault", "Ignores Cover", "Torrent"] }, melee: { name: "æ å¥ªè€…é‡çˆª", A: 6, skill: 3, S: 5, AP: -2, D: 2, keywords: ["Anti-Monster 5+", "Anti-Vehicle 5+", "Twin-linked"] } }, abilities: ["æ·±å…¥æ‰“æ“Š", "é ˜å°è€…", "æŒçºŒå‘½ä¸­1", "è¶…æ„Ÿå®˜"] },
      { id: "ty-harridan", name: "ç¿¼é­” Harridan", points: 550, img: "img/Tyranids/99120106024_Harpies01.jpg", stats: { M: 20, T: 10, Sv: 3, W: 30, Ld: 8, OC: 0 }, inv: null, keywords: ["Monster", "Titanic", "Fly", "Aircraft", "Transport"], weapons: { ranged: { name: "ææ€–ç”ŸåŒ–ç ²", range: 48, A: "D6+6", skill: 3, S: 10, AP: -3, D: 3, keywords: ["Blast"] }, melee: { name: "å·¨å‹é®çˆª", A: 6, skill: 3, S: 14, AP: -2, D: "D6" } }, abilities: ["è‡´å‘½æœ«æ—¥2D6", "æ‡¸åœ", "ç‹‚æš´ä»£è¬: +1è‡´å‚·ä½†å—D3å‚·å®³", "é‹è¼¸: 20ç¿¼èŸ²"] },
      { id: "ty-hierophant", name: "ç¥­å¸ç¸ Hierophant", points: 700, img: "img/Tyranids/99120106054_TYRTyrannofexLead.jpg", stats: { M: 12, T: 14, Sv: 2, W: 30, Ld: 8, OC: 12 }, inv: 5, keywords: ["Monster", "Titanic", "Towering", "Transport"], weapons: { ranged: { name: "ææ€–ç”ŸåŒ–ç ²Ã—2", range: 48, A: "2D6+12", skill: 3, S: 10, AP: -3, D: 3, keywords: ["Blast"] }, melee: { name: "å·¨å‹é®çˆª", A: 8, skill: 3, S: 20, AP: -2, D: "D6+1" } }, abilities: ["è‡´å‘½æœ«æ—¥2D6", "Synapse", "å·¨ç¸: +1å‘½ä¸­vsæˆ°æ…„å–®ä½", "è¸è¸å‰é€²: å¯è¶Šé4\"ä»¥ä¸‹æ¨¡å‹"] },
      // ===== é¡å¤–å¯ç”¨åœ–ç‰‡çš„å–®ä½ =====
      { id: "ty-deathleaper", name: "æ­»äº¡æ½›è¡Œè€… Deathleaper", points: 80, img: "img/Tyranids/99120106067_Deathleaper1.jpg", stats: { M: 8, T: 6, Sv: 4, W: 7, Ld: 7, OC: 1 }, inv: 4, weapons: { ranged: null, melee: { name: "æ­»ç¥çˆªç‰™", A: 6, skill: 2, S: 8, AP: -2, D: 3 } }, abilities: ["æ·±å…¥æ‰“æ“Š", "éš±åŒ¿å¤§å¸«", "ææ‡¼ä¹‹æº"] },
      { id: "ty-psychophage", name: "éˆå™¬ç¸ Psychophage", points: 125, img: "img/Tyranids/99120106074_Psychophage1.jpg", stats: { M: 8, T: 9, Sv: 3, W: 10, Ld: 8, OC: 3 }, inv: null, weapons: { ranged: { name: "éˆèƒ½çˆ†ç™¼", range: 12, A: "D6", skill: 4, S: 6, AP: -1, D: 2 }, melee: { name: "å•ƒå™¬åˆ©çˆª", A: 5, skill: 3, S: 10, AP: -2, D: 3 } }, abilities: ["éˆå™¬: é€ æˆå‚·å®³æ¢å¾©HP"] },
      { id: "ty-biovore", name: "ç”ŸåŒ–æŠ•å°„ç¸ Biovore", points: 50, img: "img/Tyranids/99120106065_Biovore1.jpg", stats: { M: 5, T: 5, Sv: 4, W: 4, Ld: 8, OC: 1 }, inv: null, weapons: { ranged: { name: "å­¢å­åœ°é›·", range: 48, A: 1, skill: 4, S: 5, AP: -1, D: 2, keywords: ["Blast", "Indirect Fire"] }, melee: { name: "çˆªç‰™", A: 2, skill: 4, S: 4, AP: 0, D: 1 } }, abilities: ["é–“æ¥ç«åŠ›"] },
      { id: "ty-pyrovore", name: "ç†”å²©èŸ² Pyrovore", points: 35, img: "img/Tyranids/99120106065_Pyrovore1.jpg", stats: { M: 5, T: 6, Sv: 3, W: 5, Ld: 8, OC: 1 }, inv: null, weapons: { ranged: { name: "é…¸æ¶²å™´å°„", range: 12, A: "D6", skill: 0, S: 5, AP: -1, D: 1, keywords: ["Torrent", "Ignores Cover"] }, melee: { name: "çˆªç‰™", A: 3, skill: 4, S: 5, AP: 0, D: 1 } }, abilities: ["çˆ†ç‚¸æ­»äº¡"] },
      { id: "ty-prime", name: "èŸ²æ—æˆ°å£«é¦–é ˜ Tyranid Prime", points: 75, img: "img/Tyranids/99120106075_Prime1.jpg", stats: { M: 6, T: 5, Sv: 4, W: 6, Ld: 7, OC: 1 }, inv: null, keywords: ["Leader"], weapons: { ranged: { name: "æ­»äº¡å™´å°„", range: 18, A: 3, skill: 3, S: 5, AP: -1, D: 1 }, melee: { name: "éª¨åŠé­çˆª", A: 5, skill: 2, S: 6, AP: -2, D: 2 } }, abilities: ["Synapse", "é ˜å°è€…", "æˆ°å£«ç¾¤åŠ æˆ"] },
      { id: "ty-parasite", name: "è«ç‰¹é›·æ–¯å¯„ç”ŸèŸ² Parasite of Mortrex", points: 90, img: "img/Tyranids/99120106050_TYRParasiteofMortrexLead.jpg", stats: { M: 12, T: 5, Sv: 4, W: 5, Ld: 7, OC: 1 }, inv: null, keywords: ["Fly"], weapons: { ranged: null, melee: { name: "å¯„ç”Ÿçˆªç‰™", A: 6, skill: 2, S: 5, AP: -1, D: 2 } }, abilities: ["é£›è¡Œ", "å¯„ç”Ÿç”¢åµ: æ“Šæ®ºæ•µäººç”ŸæˆèŸ²ç¾¤"] },
      { id: "ty-hivecrone", name: "èŸ²å·¢å¥³å¦– Hive Crone", points: 200, img: "img/Tyranids/99120106024_HiveCrone01.jpg", stats: { M: 20, T: 9, Sv: 3, W: 12, Ld: 8, OC: 0 }, inv: null, keywords: ["Fly", "Aircraft"], weapons: { ranged: { name: "è§¸æ‰‹é­", range: 18, A: 4, skill: 3, S: 7, AP: -2, D: 2 }, melee: { name: "å·¨çˆª", A: 5, skill: 3, S: 8, AP: -2, D: 3 } }, abilities: ["é£›è¡Œå™¨", "é…¸æ¶²å™´å°„"] },
      { id: "ty-nornassimilator", name: "å¤è€åŒåŒ–è€… Norn Assimilator", points: 290, img: "img/Tyranids/99120106064_NornAssimilator1.jpg", stats: { M: 10, T: 11, Sv: 2, W: 18, Ld: 7, OC: 5 }, inv: 4, weapons: { ranged: { name: "æ¯’ç´ å™´å°„", range: 12, A: "2D6", skill: 0, S: 7, AP: -2, D: 2, keywords: ["Torrent"] }, melee: { name: "åŒåŒ–å·¨çˆª", A: 8, skill: 2, S: 14, AP: -3, D: "D6+2" } }, abilities: ["Synapse", "åŒåŒ–æ¢å¾©"] }
    ]
  },
  "chaos": {
    name: "æ··æ²Œæˆ°å£«",
    color: "#dc2626",
    units: [
      {
        id: "ch-lord",
        name: "æ··æ²Œé ˜ä¸» Chaos Lord",
        points: 75,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/0/04/ChaosLord8th.jpg/180px-ChaosLord8th.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 5, Ld: 6, OC: 1 },
        inv: 4,
        weapons: {
          ranged: { name: "ç­‰é›¢å­æ§ Plasma Pistol", range: 12, A: 1, skill: 2, S: 7, AP: -2, D: 2 },
          melee: { name: "æƒ¡é­”ä¹‹åŠ Daemon Blade", A: 6, skill: 2, S: 6, AP: -2, D: 2 }
        },
        abilities: ["é»‘æš—å…‰ç’°: 6\"å…§é‡æ“²è‡´å‚·1", "Let the Galaxy Burn"]
      },
      {
        id: "ch-legionaries",
        name: "è»åœ˜æˆ°å£«Ã—5 Legionaries",
        points: 90,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/1/1c/ChaosLegionariesMini10th.jpg/250px-ChaosLegionariesMini10th.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 10, Ld: 6, OC: 2 },
        inv: null,
        weapons: {
          ranged: { name: "æ··æ²Œçˆ†çŸ¢æ§ Boltgun", range: 24, A: 2, skill: 3, S: 4, AP: 0, D: 1 },
          melee: { name: "æ··æ²Œè¿‘æˆ°æ­¦å™¨", A: 3, skill: 3, S: 4, AP: 0, D: 1 }
        },
        abilities: ["ä»‡æ¨èª“è¨€: +1å‘½ä¸­vs Imperium"]
      },
      {
        id: "ch-havocs",
        name: "æµ©åŠ«æˆ°å£«Ã—5 Havocs",
        points: 140,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/e/e9/Havocs8thED.jpg/200px-Havocs8thED.jpg",
        stats: { M: 5, T: 4, Sv: 3, W: 10, Ld: 6, OC: 1 },
        inv: null,
        weapons: {
          ranged: { name: "ç†”å²©æ§ Lascannon", range: 48, A: 1, skill: 3, S: 12, AP: -3, D: "D6+1" },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 2, skill: 3, S: 4, AP: 0, D: 1 }
        },
        abilities: ["å£“åˆ¶ç«åŠ›: ç›®æ¨™-2ç§»å‹•"]
      },
      {
        id: "ch-berzerkers",
        name: "ä¹è¡€ç‹‚æˆ°å£«Ã—5 Khorne Berzerkers",
        points: 90,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/5/5a/Berzerkers8thMini.jpg/220px-Berzerkers8thMini.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 10, Ld: 6, OC: 2 },
        inv: null,
        weapons: {
          ranged: { name: "çˆ†çŸ¢æ‰‹æ§", range: 12, A: 1, skill: 3, S: 4, AP: 0, D: 1 },
          melee: { name: "éˆæ–§ Chainaxe", A: 4, skill: 3, S: 5, AP: -1, D: 1 }
        },
        abilities: ["è¡€ä¹‹æ†¤æ€’: Fightéšæ®µå¯æ”»æ“Šå…©æ¬¡"]
      },
      {
        id: "ch-helbrute",
        name: "åœ°ç„è »å…µ Helbrute",
        points: 130,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/0/00/Hellbrute7th.jpg/200px-Hellbrute7th.jpg",
        stats: { M: 6, T: 9, Sv: 2, W: 8, Ld: 6, OC: 3 },
        inv: null,
        keywords: ["Vehicle", "Walker"],
        weapons: {
          ranged: { name: "å¤šç†”å²©ç ² Multi-melta", range: 18, A: 2, skill: 3, S: 9, AP: -4, D: "D6", keywords: ["Melta 2"] },
          melee: { name: "å‹•åŠ›é‰— Power Scourge", A: 5, skill: 3, S: 12, AP: -2, D: 3 }
        },
        abilities: ["ç‹‚æš´: å—å‚·å¾Œ+1æ”»æ“Š", "Helbrute Frenzy"]
      }
    ]
  },
  "orks": {
    name: "æ­å…‹è »äºº",
    color: "#84cc16",
    units: [
      {
        id: "or-warboss",
        name: "æˆ°çˆ­é ­é ­ Warboss",
        points: 70,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/6/61/WarbossMega.jpg/200px-WarbossMega.jpg",
        stats: { M: 6, T: 5, Sv: 4, W: 7, Ld: 6, OC: 1 },
        inv: 5,
        weapons: {
          ranged: { name: "å¤§çˆ†æ§ Kombi-weapon", range: 24, A: 1, skill: 5, S: 4, AP: 0, D: 1 },
          melee: { name: "å‹•åŠ›çˆª Power Klaw", A: 4, skill: 3, S: 10, AP: -2, D: 2 }
        },
        abilities: ["WAAAGH!: å…¨è»è¡é‹’+1", "Might is Right"]
      },
      {
        id: "or-boyz",
        name: "æ­å…‹ç”·å­©Ã—10 Boyz",
        points: 80,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/0/0d/OrkBoyzMini10th.jpg/220px-OrkBoyzMini10th.jpg",
        stats: { M: 6, T: 5, Sv: 5, W: 11, Ld: 7, OC: 2 },
        inv: null,
        weapons: {
          ranged: { name: "ç²—ç³™æ§ Shoota", range: 18, A: 2, skill: 5, S: 4, AP: 0, D: 1 },
          melee: { name: "ç åˆ€ Choppa", A: 3, skill: 3, S: 4, AP: -1, D: 1 }
        },
        abilities: ["äººå¤šåŠ›é‡å¤§: 10+æ¨¡å‹æ™‚+1æ”»æ“Š"]
      },
      {
        id: "or-nobz",
        name: "é ­é ­Ã—5 Nobz",
        points: 100,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/d/dd/NobzMini10th.jpg/200px-NobzMini10th.jpg",
        stats: { M: 6, T: 5, Sv: 4, W: 10, Ld: 7, OC: 2 },
        inv: null,
        weapons: {
          ranged: { name: "çˆ†æ§ Slugga", range: 12, A: 1, skill: 5, S: 4, AP: 0, D: 1 },
          melee: { name: "å¤§ç åˆ€ Big Choppa", A: 3, skill: 3, S: 7, AP: -1, D: 2 }
        },
        abilities: ["Da Boss is Watching"]
      },
      {
        id: "or-meganobz",
        name: "å·¨ç”²é ­é ­Ã—3 Meganobz",
        points: 100,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/f/f9/MegaNobz.jpg/220px-MegaNobz.jpg",
        stats: { M: 5, T: 6, Sv: 2, W: 9, Ld: 7, OC: 2 },
        inv: null,
        weapons: {
          ranged: { name: "é›™é€£çˆ†æ§ Kombi-rokkit", range: 24, A: "D3", skill: 5, S: 9, AP: -2, D: 3 },
          melee: { name: "å‹•åŠ›çˆª Power Klaw", A: 3, skill: 3, S: 9, AP: -2, D: 2 }
        },
        abilities: ["Krumpin' Time"]
      },
      {
        id: "or-deffkoptas",
        name: "æ­»äº¡ç›´å‡æ©ŸÃ—3 Deffkoptas",
        points: 110,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/a/a8/DeffKoptaMini10th.jpg/200px-DeffKoptaMini10th.jpg",
        stats: { M: 14, T: 6, Sv: 4, W: 9, Ld: 7, OC: 2 },
        inv: null,
        keywords: ["Fly", "Vehicle"],
        weapons: {
          ranged: { name: "ç«ç®­ Rokkits", range: 24, A: 3, skill: 5, S: 9, AP: -2, D: 3 },
          melee: { name: "æ—‹è½‰åˆ€ç‰‡ Spinnin' Blades", A: 6, skill: 3, S: 5, AP: -1, D: 1 }
        },
        abilities: ["Deep Strike"]
      }
    ]
  }
};

// ========== åœ°å½¢å®šç¾© ==========
const TERRAIN_TYPES = {
  ruins: { name: "å»¢å¢Ÿ", color: "#4a5568", coverBonus: true, blockLOS: true },
  woods: { name: "æ¨¹æ—", color: "#2d5a27", coverBonus: true, blockLOS: false },
  barricade: { name: "éšœç¤™ç‰©", color: "#78716c", coverBonus: true, blockLOS: false },
  crater: { name: "å½ˆå‘", color: "#854d0e", coverBonus: true, blockLOS: false },
  building: { name: "å»ºç¯‰ç‰©", color: "#1e40af", coverBonus: true, blockLOS: true }
};

// ========== éŠæˆ²ç‹€æ…‹ ==========
let gameState = {
  phase: "setup", // setup, deployment, command, movement, shooting, charge, fight
  round: 1,
  currentPlayer: 1,
  vp: { 1: 0, 2: 0 },
  cp: { 1: 0, 2: 0 },
  deploy: {
    deployingPlayer: 1,
    p1Deployed: false,
    p2Deployed: false
  },
  units: [],
  terrain: [],
  objectives: [],
  selectedUnit: null,
  targetUnit: null,
  currentAction: null,
  movedUnits: [],
  shotUnits: [],
  chargedUnits: [],
  foughtUnits: [],
  pendingReroll: null  // ç”¨æ–¼æŒ‡æ®é‡æ“²
};

let armyRosters = { 1: [], 2: [] };
let canvas, ctx;
let ai1Enabled = false;  // ç©å®¶ä¸€AI
let ai2Enabled = true;   // ç©å®¶äºŒAI
let aiDifficulty = "normal";

// ========== è¦–åœ–ç¸®æ”¾ç³»çµ± ==========
let viewZoom = 1.0;        // ç•¶å‰ç¸®æ”¾æ¯”ä¾‹
let viewOffsetX = 0;       // è¦–åœ–åç§»X
let viewOffsetY = 0;       // è¦–åœ–åç§»Y
let isDragging = false;    // æ˜¯å¦æ­£åœ¨æ‹–æ›³
let dragStartX = 0;
let dragStartY = 0;
const MIN_ZOOM = 0.5;
const MAX_ZOOM = 3.0;
const ZOOM_STEP = 0.1;

// ========== å–®ä½åœ–åƒç·©å­˜ ==========
const unitImageCache = {};
const imageLoadAttempted = {}; // è¿½è¹¤å·²å˜—è©¦è¼‰å…¥çš„åœ–ç‰‡

function loadUnitImage(unit) {
  if (!unit.img) return null;
  if (unitImageCache[unit.img]) return unitImageCache[unit.img];
  if (imageLoadAttempted[unit.img]) return null; // å·²å˜—è©¦éï¼Œä¸å†é‡è¤‡

  imageLoadAttempted[unit.img] = true;
  const img = new Image();
  img.src = unit.img;
  img.onload = () => { unitImageCache[unit.img] = img; };
  img.onerror = () => { unitImageCache[unit.img] = null; };
  unitImageCache[unit.img] = img;
  return img;
}

// ========== å–®ä½åº•æ¿å¤§å°è¨ˆç®— ==========
// æ ¹æ“š WH40K å®˜æ–¹åº•æ¿å°ºå¯¸è¦ç¯„
// åº•æ¿å°ºå¯¸æ›ç®—: 25mm â‰ˆ 1", 32mm â‰ˆ 1.25", 40mm â‰ˆ 1.6", 50mm â‰ˆ 2",
//              60mm â‰ˆ 2.4", 80mm â‰ˆ 3.15", 100mm â‰ˆ 4", 130mm â‰ˆ 5"
// å›å‚³å€¼ç‚ºåŠå¾‘(åƒç´ )ï¼Œéœ€ä¹˜ä»¥ INCH/10 ä¾†å°æ‡‰å¯¦éš›æ¯”ä¾‹
function getUnitBaseSize(unit) {
  // å¦‚æœå–®ä½æœ‰è‡ªå®šç¾©åº•æ¿å¤§å°ï¼Œä½¿ç”¨å®ƒ
  if (unit.baseSize) return unit.baseSize;

  const keywords = unit.keywords || [];
  const name = unit.name || "";
  const stats = unit.stats || {};
  const scale = INCH / 10; // æ ¹æ“šINCHç¸®æ”¾

  // æ³°å¦ç´š (130mm+ / 5"+) - æœ€å¤§
  if (keywords.includes("Titanic") || name.includes("é‡‘å­—å¡”") || name.includes("Monolith") ||
      name.includes("æ²‰é»˜ä¹‹ç‹") || name.includes("Silent King") ||
      name.includes("Hierophant") || name.includes("ç¥­å¸ç¸")) {
    return Math.round(25 * scale); // 5" ç›´å¾‘ = 2.5" åŠå¾‘
  }

  // å¤§å‹æ€ªç¸/è¼‰å…· (100mm / 4") - C'tanã€å¤§å‹æ€ªç¸
  if (keywords.includes("C'tan") ||
      (keywords.includes("Monster") && stats.W >= 14) ||
      name.includes("æ˜Ÿç¥") || name.includes("Norn") || name.includes("å¤è€") ||
      name.includes("æš´å›ç¸") || name.includes("Tyrannofex") ||
      name.includes("ç©¿åœ°ç¸") || name.includes("Trygon") ||
      name.includes("å·¨å£ç¸") || name.includes("Mawloc")) {
    return Math.round(20 * scale); // 4" ç›´å¾‘ = 2" åŠå¾‘
  }

  // ä¸­å‹æ€ªç¸/è¼‰å…· (60-80mm / 2.4"-3.15")
  if ((keywords.includes("Monster") && stats.W >= 8) ||
      keywords.includes("Vehicle") ||
      name.includes("å± æ®ºç¸") || name.includes("Carnifex") ||
      name.includes("å™´å°„ç¸") || name.includes("Exocrine") ||
      name.includes("åå™¬ç¸") || name.includes("Haruspex") ||
      name.includes("æƒ¡æ„ç¸") || name.includes("Maleceptor") ||
      name.includes("æœ«æ—¥") || name.includes("Doomsday") || name.includes("Doomstalker") ||
      name.includes("æ–¹èˆŸ") || name.includes("Ark") ||
      name.includes("ç„¡ç•") || name.includes("Dreadnought") ||
      name.includes("èŸ²å·¢æš´å›") || name.includes("Hive Tyrant") ||
      name.includes("èŸ²ç¾¤éœ¸ä¸»") || name.includes("Swarmlord") ||
      name.includes("ç¹æ®–ç¸") || name.includes("Tervigon")) {
    return Math.round(15 * scale); // 3" ç›´å¾‘ = 1.5" åŠå¾‘
  }

  // ä¸­å‹æ­¥å…µ/å°å‹æ€ªç¸ (50mm / 2")
  if ((keywords.includes("Monster") && stats.W >= 5) ||
      name.includes("æ¯€æ»…è€…") || name.includes("Destroyer") ||
      name.includes("å¹½éˆ") || name.includes("Wraith") ||
      name.includes("éˆèƒ½ç¸") || name.includes("Zoanthrope") ||
      name.includes("ä¼æ“Šè€…") || name.includes("Lictor") ||
      name.includes("è‚²æ¯èŸ²") || name.includes("Broodlord") ||
      name.includes("éœ¸ä¸»") || name.includes("Overlord") ||
      name.includes("é ˜ä¸»") || name.includes("Lord")) {
    return Math.round(10 * scale); // 2" ç›´å¾‘ = 1" åŠå¾‘
  }

  // è§’è‰²/ç²¾è‹± (40mm / 1.6")
  if (keywords.includes("Character") ||
      name.includes("è¡“å£«") || name.includes("mancer") ||
      name.includes("é€£é•·") || name.includes("Captain") ||
      name.includes("æš—è¡›") || name.includes("Lychguard") ||
      name.includes("æˆ°å£«Ã—3") || name.includes("WarriorsÃ—3") ||
      name.includes("èŸ²æ—æˆ°å£«") || name.includes("Tyranid Warriors")) {
    return Math.round(8 * scale); // 1.6" ç›´å¾‘ = 0.8" åŠå¾‘
  }

  // åŸºç¤æ­¥å…µ (25-32mm / 1"-1.25")
  if (name.includes("Ã—10") || name.includes("Ã—5") ||
      name.includes("ç™½èŸ»") || name.includes("Termagant") ||
      name.includes("åˆºèŸ²") || name.includes("Hormagaunt") ||
      name.includes("ç¿¼èŸ²") || name.includes("Gargoyle") ||
      name.includes("æˆ°å£«Ã—10") || name.includes("WarriorsÃ—10") ||
      name.includes("ä¸æœ½è€…") || name.includes("Immortal") ||
      name.includes("ç”²èŸ²") || name.includes("Scarab")) {
    return Math.round(5 * scale); // 1" ç›´å¾‘ = 0.5" åŠå¾‘
  }

  // é è¨­å¤§å° (32mm / 1.25")
  return Math.round(6 * scale); // 1.25" ç›´å¾‘ = 0.625" åŠå¾‘
}

// ========== æ™ºèƒ½éƒ¨ç½²ç³»çµ± ==========
// æª¢æŸ¥ä½ç½®æ˜¯å¦èˆ‡å·²éƒ¨ç½²å–®ä½é‡ç–Š
function isPositionValid(x, y, baseSize, deployedUnits, minGap = 5) {
  for (const other of deployedUnits) {
    const otherSize = getUnitBaseSize(other);
    const minDist = baseSize + otherSize + minGap; // å…©å–®ä½åº•æ¿ + é–“éš™
    const dist = Math.hypot(x - other.x, y - other.y);
    if (dist < minDist) return false;
  }
  return true;
}

// æ™ºèƒ½éƒ¨ç½²å–®ä½ï¼Œé¿å…é‡ç–Š
function smartDeployUnits(units, player, deployZoneWidth, canvasWidth, canvasHeight) {
  // æŒ‰åº•æ¿å¤§å°æ’åºï¼ˆå¤§çš„å…ˆéƒ¨ç½²ï¼Œæ–¹ä¾¿å®‰æ’ç©ºé–“ï¼‰
  const sortedUnits = [...units].sort((a, b) => getUnitBaseSize(b) - getUnitBaseSize(a));
  const deployedInThisCall = [];

  const margin = 15; // é‚Šç•Œå®‰å…¨è·é›¢
  const maxAttempts = 50; // æœ€å¤§å˜—è©¦æ¬¡æ•¸

  for (const unit of sortedUnits) {
    const baseSize = getUnitBaseSize(unit);
    let placed = false;

    // è¨ˆç®—éƒ¨ç½²å€åŸŸç¯„åœï¼ˆç¢ºä¿æœ‰æ•ˆç¯„åœï¼‰
    let xMin, xMax;
    if (player === 1) {
      xMin = margin + baseSize;
      xMax = Math.max(xMin + baseSize, deployZoneWidth - baseSize - margin);
    } else {
      xMin = canvasWidth - deployZoneWidth + margin + baseSize;
      xMax = Math.max(xMin + baseSize, canvasWidth - margin - baseSize);
    }

    const yMin = margin + baseSize;
    const yMax = Math.max(yMin + baseSize, canvasHeight - margin - baseSize);

    // å·²éƒ¨ç½²å–®ä½ï¼ˆåŒ…æ‹¬å…¶ä»–ç©å®¶çš„å’Œæœ¬æ¬¡éƒ¨ç½²çš„ï¼‰
    const allDeployed = [...deployedInThisCall, ...units.filter(u => u !== unit && u.deployed)];

    // æ–¹æ³•1ï¼šç¶²æ ¼æƒææ‰¾åˆ°åˆé©ä½ç½®
    const gridStep = baseSize * 1.5; // ç¶²æ ¼é–“è·
    for (let y = yMin; y <= yMax && !placed; y += gridStep) {
      for (let x = xMin; x <= xMax && !placed; x += gridStep) {
        if (isPositionValid(x, y, baseSize, allDeployed)) {
          unit.x = x;
          unit.y = y;
          placed = true;
        }
      }
    }

    // æ–¹æ³•2ï¼šå¦‚æœç¶²æ ¼æ²’æ‰¾åˆ°ï¼Œéš¨æ©Ÿå˜—è©¦
    if (!placed) {
      for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
        const x = xMin + Math.random() * (xMax - xMin);
        const y = yMin + Math.random() * (yMax - yMin);
        if (isPositionValid(x, y, baseSize, allDeployed, 2)) { // æ¸›å°‘é–“éš™è¦æ±‚
          unit.x = x;
          unit.y = y;
          placed = true;
        }
      }
    }

    // æ–¹æ³•3ï¼šå¼·åˆ¶æ”¾ç½®ï¼ˆæœ€å¾Œæ‰‹æ®µï¼Œå…è¨±å¾®å°é‡ç–Šï¼‰
    if (!placed) {
      // æ‰¾åˆ°é‡ç–Šæœ€å°‘çš„ä½ç½®
      let bestX = xMin, bestY = yMin, minOverlap = Infinity;
      for (let y = yMin; y <= yMax; y += gridStep / 2) {
        for (let x = xMin; x <= xMax; x += gridStep / 2) {
          let totalOverlap = 0;
          for (const other of allDeployed) {
            const otherSize = getUnitBaseSize(other);
            const minDist = baseSize + otherSize;
            const dist = Math.hypot(x - other.x, y - other.y);
            if (dist < minDist) {
              totalOverlap += (minDist - dist);
            }
          }
          if (totalOverlap < minOverlap) {
            minOverlap = totalOverlap;
            bestX = x;
            bestY = y;
          }
        }
      }
      unit.x = bestX;
      unit.y = bestY;
    }

    unit.deployed = true;
    unit.visible = true;
    deployedInThisCall.push(unit);
  }
}

// ========== æˆ°å ´è¦–è¦ºç‰¹æ•ˆç³»çµ± ==========
const visualEffects = {
  floatingTexts: [],    // æµ®å‹•æ–‡å­—ï¼ˆæŠ€èƒ½åç¨±ã€å‚·å®³æ•¸å­—ï¼‰
  attackLines: [],      // æ”»æ“Šå°„ç·š
  explosions: []        // çˆ†ç‚¸æ•ˆæœ
};

// è¦–è¦ºç‰¹æ•ˆä¸Šé™ï¼ˆé˜²æ­¢è¨˜æ†¶é«”æ´©æ¼ï¼‰
const MAX_VISUAL_EFFECTS = {
  floatingTexts: 20,
  attackLines: 10,
  explosions: 10
};

// å®šæœŸæ¸…ç†è¨˜æ†¶é«”ï¼ˆæ¯30ç§’åŸ·è¡Œä¸€æ¬¡ï¼‰
let lastCleanupTime = 0;
function periodicCleanup() {
  const now = Date.now();
  if (now - lastCleanupTime < 30000) return;
  lastCleanupTime = now;

  // æ¸…ç†éæœŸçš„ç‰¹æ•ˆ
  clearAllVisualEffects();

  // å¼·åˆ¶åƒåœ¾å›æ”¶æç¤ºï¼ˆç€è¦½å™¨å¯èƒ½ä¸æœƒç«‹å³åŸ·è¡Œï¼‰
  if (window.gc) window.gc();
}

// æ¸…ç†éé‡çš„è¦–è¦ºç‰¹æ•ˆ
function trimVisualEffects() {
  if (visualEffects.floatingTexts.length > MAX_VISUAL_EFFECTS.floatingTexts) {
    visualEffects.floatingTexts = visualEffects.floatingTexts.slice(-MAX_VISUAL_EFFECTS.floatingTexts);
  }
  if (visualEffects.attackLines.length > MAX_VISUAL_EFFECTS.attackLines) {
    visualEffects.attackLines = visualEffects.attackLines.slice(-MAX_VISUAL_EFFECTS.attackLines);
  }
  if (visualEffects.explosions.length > MAX_VISUAL_EFFECTS.explosions) {
    visualEffects.explosions = visualEffects.explosions.slice(-MAX_VISUAL_EFFECTS.explosions);
  }
}

// å®Œå…¨æ¸…é™¤æ‰€æœ‰è¦–è¦ºç‰¹æ•ˆ
function clearAllVisualEffects() {
  visualEffects.floatingTexts = [];
  visualEffects.attackLines = [];
  visualEffects.explosions = [];
}

// éš±è—éª°å­ä»‹é¢
function hideDiceOverlay() {
  const overlay = document.getElementById("diceOverlay");
  if (overlay) {
    overlay.classList.remove("active");
    const container = document.getElementById("diceContainer");
    const resultEl = document.getElementById("diceResult");
    if (container) container.innerHTML = "";
    if (resultEl) resultEl.innerHTML = "";
  }
}

// æ¸…é™¤æ‰€æœ‰UIç‰¹æ•ˆï¼ˆéšæ®µåˆ‡æ›æ™‚èª¿ç”¨ï¼‰
function clearAllUIEffects() {
  clearAllVisualEffects();
  hideDiceOverlay();

  // é—œé–‰æˆ°ç•¥å½ˆçª—ï¼ˆå¦‚æœé–‹è‘—ï¼‰
  const stratagemPopup = document.getElementById("stratagemPopup");
  if (stratagemPopup && stratagemPopup.style.display !== "none") {
    stratagemPopup.style.display = "none";
    if (stratagemPopupCallback) {
      stratagemPopupCallback();
      stratagemPopupCallback = null;
    }
  }
}

// åœ¨å–®ä½é ­ä¸Šé¡¯ç¤ºæµ®å‹•æ–‡å­—
function showFloatingText(x, y, text, options = {}, sync = true) {
  const effect = {
    x: x,
    y: y - 40,
    text: text,
    color: options.color || "#fbbf24",
    fontSize: options.fontSize || 14,
    outline: options.outline || "#000",
    startTime: performance.now(),
    duration: options.duration || 800, // ç¸®çŸ­é¡¯ç¤ºæ™‚é–“
    offsetY: 0,
    opacity: 1,
    scale: options.scale || 1,
    type: options.type || "skill"
  };
  visualEffects.floatingTexts.push(effect);

  // ç·šä¸ŠåŒæ­¥è¦–è¦ºæ•ˆæœ
  if (sync && isOnlineMode && roomRef && isMyTurn()) {
    syncVisualEffect({ type: 'floatingText', x, y, text, options });
  }
}

// é¡¯ç¤ºå‚·å®³æ•¸å­—ï¼ˆç‰¹æ®Šæ¨£å¼ï¼‰
function showDamageNumber(x, y, damage, isCrit = false, sync = true) {
  const effect = {
    x: x + (Math.random() - 0.5) * 20,
    y: y - 30,
    text: `-${damage}`,
    color: isCrit ? "#ff0000" : "#ef4444",
    fontSize: isCrit ? 24 : 18,
    outline: "#000",
    startTime: performance.now(),
    duration: 600, // ç¸®çŸ­é¡¯ç¤ºæ™‚é–“
    offsetY: 0,
    opacity: 1,
    scale: isCrit ? 1.3 : 1,
    type: "damage",
    bounce: true
  };
  visualEffects.floatingTexts.push(effect);

  // ç·šä¸ŠåŒæ­¥å‚·å®³æ•¸å­—
  if (sync && isOnlineMode && roomRef && isMyTurn()) {
    syncVisualEffect({ type: 'damageNumber', x, y, damage, isCrit });
  }
}

// é¡¯ç¤ºæ”»æ“Šç·š/å°„ç·š
function showAttackLine(fromX, fromY, toX, toY, options = {}) {
  const effect = {
    fromX: fromX,
    fromY: fromY,
    toX: toX,
    toY: toY,
    color: options.color || "#ffaa00",
    width: options.width || 3,
    startTime: performance.now(),
    duration: options.duration || 400,
    progress: 0,
    type: options.type || "beam" // "beam", "bullet", "melee"
  };

  visualEffects.attackLines.push(effect);
}

// é¡¯ç¤ºçˆ†ç‚¸/å‘½ä¸­æ•ˆæœï¼ˆç°¡åŒ–ç‰ˆï¼‰
function showExplosion(x, y, options = {}) {
  const effect = {
    x: x,
    y: y,
    radius: options.radius || 20,
    color: options.color || "#ff6600",
    startTime: performance.now(),
    duration: options.duration || 250
  };

  visualEffects.explosions.push(effect);
}

// æ›´æ–°ä¸¦æ¸²æŸ“æ‰€æœ‰è¦–è¦ºç‰¹æ•ˆ
function renderVisualEffects() {
  const now = performance.now();

  // æ¸…ç†éé‡ç‰¹æ•ˆ
  trimVisualEffects();

  // æ¸²æŸ“æ”»æ“Šå°„ç·š
  visualEffects.attackLines = visualEffects.attackLines.filter(line => {
    const elapsed = now - line.startTime;
    if (elapsed >= line.duration) return false;

    const progress = elapsed / line.duration;
    const easeProgress = 1 - Math.pow(1 - progress, 3); // easeOutCubic

    ctx.save();

    if (line.type === "beam") {
      // å…‰æŸæ•ˆæœï¼ˆç°¡åŒ–ç‰ˆï¼Œç§»é™¤æ¼¸å±¤å’Œé™°å½±ä»¥æå‡æ€§èƒ½ï¼‰
      const currentX = line.fromX + (line.toX - line.fromX) * easeProgress;
      const currentY = line.fromY + (line.toY - line.fromY) * easeProgress;

      // ä¸»å°„ç·š
      ctx.beginPath();
      ctx.moveTo(line.fromX, line.fromY);
      ctx.lineTo(currentX, currentY);
      ctx.strokeStyle = line.color;
      ctx.lineWidth = line.width;
      ctx.lineCap = "round";
      ctx.stroke();

      // ç°¡åŒ–çš„ç™¼å…‰æ•ˆæœï¼ˆç”¨è¼ƒç²—çš„åŠé€æ˜ç·šä»£æ›¿é™°å½±ï¼‰
      ctx.beginPath();
      ctx.moveTo(line.fromX, line.fromY);
      ctx.lineTo(currentX, currentY);
      ctx.strokeStyle = `rgba(255, 200, 100, ${0.3 * (1 - progress)})`;
      ctx.lineWidth = line.width * 2;
      ctx.stroke();

    } else if (line.type === "melee") {
      // è¿‘æˆ°æ–¬æ“Šæ•ˆæœï¼ˆç°¡åŒ–ç‰ˆï¼‰
      ctx.beginPath();
      ctx.moveTo(line.fromX, line.fromY);
      ctx.lineTo(line.toX, line.toY);
      ctx.strokeStyle = `rgba(255, 100, 100, ${1 - progress})`;
      ctx.lineWidth = 3;
      ctx.lineCap = "round";
      ctx.stroke();
    }

    ctx.restore();
    return true;
  });

  // æ¸²æŸ“çˆ†ç‚¸æ•ˆæœï¼ˆç°¡åŒ–ç‰ˆï¼‰
  visualEffects.explosions = visualEffects.explosions.filter(exp => {
    const elapsed = now - exp.startTime;
    if (elapsed >= exp.duration) return false;

    const progress = elapsed / exp.duration;
    const alpha = 1 - progress;
    const currentRadius = exp.radius * (0.5 + progress * 0.5);

    // å–®åœˆæ“´æ•£æ•ˆæœ
    ctx.beginPath();
    ctx.arc(exp.x, exp.y, currentRadius, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 150, 50, ${alpha})`;
    ctx.lineWidth = 3 * (1 - progress);
    ctx.stroke();

    // ä¸­å¿ƒé–ƒå…‰
    if (progress < 0.3) {
      ctx.beginPath();
      ctx.arc(exp.x, exp.y, exp.radius * 0.2 * (1 - progress * 3), 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 200, ${1 - progress * 3})`;
      ctx.fill();
    }

    return true;
  });

  // æ¸²æŸ“æµ®å‹•æ–‡å­—
  visualEffects.floatingTexts = visualEffects.floatingTexts.filter(ft => {
    const elapsed = now - ft.startTime;
    if (elapsed >= ft.duration) return false;

    const progress = elapsed / ft.duration;

    // è¨ˆç®—å‹•ç•«
    if (ft.type === "damage") {
      // å‚·å®³æ•¸å­—ï¼šå‘ä¸Šè·³å‹•ç„¶å¾Œä¸‹è½
      if (ft.bounce) {
        const bounceProgress = Math.min(1, progress * 3);
        ft.offsetY = -40 * Math.sin(bounceProgress * Math.PI);
      } else {
        ft.offsetY = -30 * progress;
      }
      ft.opacity = progress < 0.7 ? 1 : 1 - (progress - 0.7) / 0.3;
      ft.scale = 1 + Math.sin(progress * Math.PI) * 0.3;
    } else {
      // æŠ€èƒ½æ–‡å­—ï¼šç·©æ…¢ä¸Šå‡ä¸¦æ·¡å‡º
      ft.offsetY = -50 * progress;
      ft.opacity = progress < 0.6 ? 1 : 1 - (progress - 0.6) / 0.4;
      ft.scale = 1 + (1 - progress) * 0.2;
    }

    ctx.save();
    ctx.globalAlpha = ft.opacity;
    ctx.font = `bold ${ft.fontSize * ft.scale}px "Microsoft JhengHei", sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    const drawX = ft.x;
    const drawY = ft.y + ft.offsetY;

    // æé‚Š
    ctx.strokeStyle = ft.outline;
    ctx.lineWidth = 3;
    ctx.strokeText(ft.text, drawX, drawY);

    // å¡«å……
    ctx.fillStyle = ft.color;
    ctx.fillText(ft.text, drawX, drawY);

    ctx.restore();
    return true;
  });
}

// ========== éª°å­è¦–è¦ºåŒ–ç³»çµ± ==========
let diceAnimationQueue = [];
let isDiceAnimating = false;

async function showDiceRoll(title, rolls, targetNumber, options = {}) {
  const overlay = document.getElementById("diceOverlay");
  const titleEl = document.getElementById("diceTitle");
  const container = document.getElementById("diceContainer");
  const resultEl = document.getElementById("diceResult");

  titleEl.textContent = title;
  container.innerHTML = "";
  resultEl.innerHTML = "";

  // å‰µå»ºéª°å­å…ƒç´ 
  rolls.forEach((_, i) => {
    const die = document.createElement("div");
    die.className = "dice rolling";
    die.id = `die-${i}`;
    die.textContent = "?";
    container.appendChild(die);
  });

  overlay.classList.add("active");

  // éŸ³æ•ˆï¼šéª°å­
  playSound('dice');

  // éª°å­å‹•ç•«
  await delay(300);

  let successCount = 0;
  let critCount = 0;

  for (let i = 0; i < rolls.length; i++) {
    const die = document.getElementById(`die-${i}`);
    die.classList.remove("rolling");
    die.textContent = rolls[i];

    if (rolls[i] >= targetNumber) {
      successCount++;
      if (rolls[i] === 6) {
        die.className = "dice critical";
        critCount++;
      } else {
        die.className = "dice success";
      }
    } else {
      die.className = "dice fail";
    }

    await delay(50);
  }

  // é¡¯ç¤ºçµæœ
  const failCount = rolls.length - successCount;
  resultEl.innerHTML = `éœ€è¦ ${targetNumber}+ | <span class="success-count">${successCount} æˆåŠŸ</span>${critCount > 0 ? ` (${critCount}æš´æ“Š)` : ""} / <span class="fail-count">${failCount} å¤±æ•—</span>`;

  // ç·šä¸Šæ¨¡å¼åŒæ­¥éª°å­çµæœ
  if (isOnlineMode && roomRef && isMyTurn()) {
    const diceResults = rolls.map((r, i) => ({
      value: r,
      success: r >= targetNumber
    }));
    syncDiceRoll(title, diceResults, successCount, failCount);
  }

  // ç­‰å¾…å¾Œè‡ªå‹•é—œé–‰
  await delay(options.duration || 800);
  overlay.classList.remove("active");

  return { successes: successCount, criticals: critCount, rolls };
}

async function showChargeRoll(roll1, roll2, needed) {
  const overlay = document.getElementById("diceOverlay");
  const titleEl = document.getElementById("diceTitle");
  const container = document.getElementById("diceContainer");
  const resultEl = document.getElementById("diceResult");

  titleEl.textContent = "è¡é‹’æ“²éª° 2D6";
  container.innerHTML = "";

  const die1 = document.createElement("div");
  die1.className = "dice rolling";
  die1.textContent = "?";
  container.appendChild(die1);

  const die2 = document.createElement("div");
  die2.className = "dice rolling";
  die2.textContent = "?";
  container.appendChild(die2);

  overlay.classList.add("active");

  await delay(400);

  die1.classList.remove("rolling");
  die1.textContent = roll1;
  die1.className = "dice success";

  await delay(200);

  die2.classList.remove("rolling");
  die2.textContent = roll2;
  die2.className = "dice success";

  const total = roll1 + roll2;
  const success = total >= needed;

  resultEl.innerHTML = `${roll1} + ${roll2} = <b>${total}"</b> (éœ€è¦ ${needed.toFixed(1)}") â†’ <span class="${success ? 'success-count' : 'fail-count'}">${success ? 'æˆåŠŸ!' : 'å¤±æ•—'}</span>`;

  // ç·šä¸Šæ¨¡å¼åŒæ­¥è¡é‹’éª°
  if (isOnlineMode && roomRef && isMyTurn()) {
    syncDiceRoll(`è¡é‹’æ“²éª° 2D6 (éœ€${needed.toFixed(1)}")`, [
      { value: roll1, success: true },
      { value: roll2, success: true }
    ], success ? 1 : 0, success ? 0 : 1);
  }

  await delay(1000);
  overlay.classList.remove("active");

  return success;
}

// ========== AI ç³»çµ± ==========
let ai1Difficulty = "normal";  // ç©å®¶ä¸€AIé›£åº¦

function toggleAI1Mode() {
  ai1Enabled = document.getElementById("ai1ModeToggle")?.checked ?? false;
  document.getElementById("p1ModeLabel").textContent = ai1Enabled ? "AI-1" : "ç©å®¶ä¸€";

  // é¡¯ç¤º/éš±è—é›£åº¦é¸æ“‡
  const diffWrapper = document.getElementById("ai1DifficultyWrapper");
  if (diffWrapper) {
    diffWrapper.style.display = ai1Enabled ? "block" : "none";
  }

  checkAutoBattle();
}

function toggleAIMode() {
  ai2Enabled = document.getElementById("aiModeToggle")?.checked ?? true;
  document.getElementById("p2ModeLabel").textContent = ai2Enabled ? "AIå°æ‰‹" : "ç©å®¶äºŒ";
  checkAutoBattle();
}

// ç²å–ç•¶å‰ç©å®¶çš„AIé›£åº¦
function getAIDifficulty() {
  if (gameState.currentPlayer === 1) {
    return document.getElementById("ai1Difficulty")?.value || ai1Difficulty;
  } else {
    return document.getElementById("aiDifficulty")?.value || aiDifficulty;
  }
}

function checkAutoBattle() {
  const autoBattleHint = document.getElementById("autoBattleHint");
  if (ai1Enabled && ai2Enabled) {
    if (!autoBattleHint) {
      const hint = document.createElement("div");
      hint.id = "autoBattleHint";
      hint.style.cssText = "text-align: center; margin-top: 10px; padding: 10px; background: linear-gradient(135deg, var(--blue), var(--red)); border-radius: 8px; color: #fff; font-weight: bold;";
      hint.innerHTML = "ğŸ¤– VS ğŸ¤– AIè‡ªå‹•å°æˆ°æ¨¡å¼";
      document.querySelector(".setup-actions")?.prepend(hint);
    }
  } else {
    document.getElementById("autoBattleHint")?.remove();
  }
}

// AIä¸»æ§åˆ¶å‡½æ•¸
async function runAITurn() {
  const isAI = (gameState.currentPlayer === 1 && ai1Enabled) || (gameState.currentPlayer === 2 && ai2Enabled);
  if (!isAI) return;

  // æ¸…é™¤ä¹‹å‰çš„ç‰¹æ•ˆ
  clearAllVisualEffects();
  hideDiceOverlay();

  const aiPlayer = gameState.currentPlayer;
  aiDifficulty = getAIDifficulty();
  log(`ğŸ¤– AI-${aiPlayer} æ­£åœ¨æ€è€ƒ... (é›£åº¦: ${aiDifficulty})`, "info");

  await delay(500);

  // ä¾ç…§éšæ®µåŸ·è¡ŒAIè¡Œå‹•
  const phases = ["command", "movement", "shooting", "charge", "fight"];

  for (const phase of phases) {
    try {
      if (gameState.phase !== phase) {
        gameState.phase = phase;
        updatePhaseDisplay();
        log(`ğŸ¤– AIé€²å…¥ã€${getPhaseNameChinese(phase)}ã€‘`, "phase");
        await delay(300);
      }

      switch (phase) {
        case "command":
          await aiCommandPhase();
          break;
        case "movement":
          await aiMovementPhase();
          break;
        case "shooting":
          await aiShootingPhase();
          break;
        case "charge":
          await aiChargePhase();
          break;
        case "fight":
          await aiFightPhase();
          break;
      }

      await delay(200);
    } catch (error) {
      console.error(`AI ${phase} phase error:`, error);
      log(`âš ï¸ AI ${phase} éšæ®µç™¼ç”ŸéŒ¯èª¤ï¼Œè·³é`, "miss");
    }
  }

  log("ğŸ¤– AIå›åˆçµæŸ", "info");
  await delay(500);
  endTurn();
}

// AIæŒ‡æ®éšæ®µï¼šè™•ç†æ‰€æœ‰æŒ‡æ®éšæ®µé‚è¼¯
async function aiCommandPhase() {
  const aiPlayer = gameState.currentPlayer;

  // æŒ‡æ®éšæ®µé–‹å§‹ï¼Œé›™æ–¹å„+1 CP
  gainCPAtCommandStart();

  // æ‡‰ç”¨å›åˆé–‹å§‹çš„å†ç”Ÿèƒ½åŠ›ï¼ˆæ´»é‡‘å±¬ç­‰ï¼‰
  applyRegenerationAbilities();

  // è¨ˆç®—ç›®æ¨™æ§åˆ¶å’ŒVP
  computeObjectiveControl();
  const gain = scorePrimary(aiPlayer);
  const prevVP = gameState.vp[aiPlayer];
  gameState.vp[aiPlayer] += gain;
  updateVPDisplay();

  const controlCount = gameState.objectives.filter(o => o.control === aiPlayer).length;
  if (gain > 0) {
    log(`ğŸ† AI-${aiPlayer}æ§åˆ¶ ${controlCount} å€‹ç›®æ¨™ â†’ +${gain} VP (ç¸½è¨ˆ: ${prevVP} â†’ ${gameState.vp[aiPlayer]})`, "phase");
  } else {
    log(`âš ï¸ AI-${aiPlayer}æœªæ§åˆ¶ä»»ä½•ç›®æ¨™ï¼Œæœ¬å›åˆ+0 VP`, "info");
  }

  // æˆ°æ…„æ¸¬è©¦
  const currentUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive);
  for (const unit of currentUnits) {
    if (unit.currentHP <= unit.maxHP / 2) {
      const roll = rollD6() + rollD6();
      if (roll >= unit.stats.Ld) {
        unit.battleShocked = false;
      } else {
        unit.battleShocked = true;
        log(`${unit.name} æˆ°æ…„ï¼OCè®Šç‚º0`, "miss");
      }
    }
  }

  // ä½¿ç”¨æ–°çš„æ™ºæ…§æˆ°ç•¥ç³»çµ±
  await aiConsiderStratagem("command", {});

  updateCPDisplay();
}

// ========== AI æ™ºæ…§æˆ°ç•¥ä½¿ç”¨ç³»çµ± ==========
// ç²å–ç•¶å‰ç©å®¶å¯ç”¨çš„æˆ°ç•¥åˆ—è¡¨
function getAvailableStratagems(player) {
  const faction = armyRosters[player]?.[0]?.faction;
  const detachment = playerDetachments[player]?.detachmentId;

  if (!faction || !detachment || !DETACHMENT_RULES[faction]?.[detachment]) {
    return [];
  }

  return DETACHMENT_RULES[faction][detachment].stratagems || [];
}

// AI è©•ä¼°ä¸¦ä½¿ç”¨æˆ°ç•¥ï¼ˆå„éšæ®µé€šç”¨ï¼‰
async function aiConsiderStratagem(phase, context = {}) {
  const aiPlayer = gameState.currentPlayer;
  const currentCP = gameState.cp[aiPlayer];

  // ç°¡å–®é›£åº¦ï¼šåªæœ‰ 20% æ©Ÿç‡è€ƒæ…®ä½¿ç”¨æˆ°ç•¥
  // æ™®é€šé›£åº¦ï¼š50% æ©Ÿç‡
  // å›°é›£é›£åº¦ï¼š80% æ©Ÿç‡
  const useChance = aiDifficulty === "easy" ? 0.2 : (aiDifficulty === "hard" ? 0.8 : 0.5);
  if (Math.random() > useChance) return null;

  if (currentCP < 1) return null;

  const stratagems = getAvailableStratagems(aiPlayer);
  if (stratagems.length === 0) return null;

  const gameEval = evaluateGameState(aiPlayer);
  const myUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive);
  const enemyUnits = gameState.units.filter(u => u.player !== aiPlayer && u.alive);

  // æ ¹æ“šéšæ®µå’Œæƒ…æ³è©•ä¼°æ¯å€‹æˆ°ç•¥çš„åƒ¹å€¼
  let bestStratagem = null;
  let bestScore = 0;

  for (const strat of stratagems) {
    if (strat.cp > currentCP) continue;

    let score = 0;
    const desc = strat.desc.toLowerCase();

    // === æŒ‡æ®éšæ®µæˆ°ç•¥ ===
    if (phase === "command") {
      // å¾©æ´»/æ¢å¾©é¡æˆ°ç•¥
      if (desc.includes("å¾©æ´»") || desc.includes("æ¢å¾©") || desc.includes("å›å¾©")) {
        const lowHPUnits = myUnits.filter(u => u.currentHP < u.maxHP * 0.5);
        const deadCharacters = gameState.units.filter(u => u.player === aiPlayer && !u.alive && u.keywords?.includes("Character"));
        if (lowHPUnits.length > 0) score = 60 + lowHPUnits.length * 10;
        if (deadCharacters.length > 0 && desc.includes("è§’è‰²")) score = 80;
      }
    }

    // === ç§»å‹•éšæ®µæˆ°ç•¥ ===
    if (phase === "movement") {
      // ç§»å‹•å¢å¼·é¡
      if (desc.includes("ç§»å‹•") || desc.includes("æ¨é€²") || desc.includes("è¡åˆº")) {
        // å¦‚æœéœ€è¦æ¶ç›®æ¨™ï¼Œç§»å‹•å¢å¼·å¾ˆæœ‰åƒ¹å€¼
        if (gameEval.strategy === "objective_rush") score = 70;
        else score = 40;
      }
      // æ·±å…¥æ‰“æ“Š/å‚³é€é¡
      if (desc.includes("éƒ¨ç½²") || desc.includes("å‚³é€") || desc.includes("ä½ç§»")) {
        score = 50;
      }
    }

    // === å°„æ“Šéšæ®µæˆ°ç•¥ ===
    if (phase === "shooting") {
      const attacker = context.attacker;
      const target = context.target;

      // å‘½ä¸­/è‡´å‚·åŠ æˆ
      if (desc.includes("+1") || desc.includes("å‘½ä¸­") || desc.includes("è‡´å‚·")) {
        score = 50;
        // å¦‚æœç›®æ¨™æ˜¯é‡è¦å–®ä½ï¼Œæ›´å€¼å¾—ä½¿ç”¨
        if (target?.keywords?.includes("Character")) score += 20;
        if (target?.currentHP > 6) score += 15;
      }
      // é‡æ“²é¡
      if (desc.includes("é‡æ“²") || desc.includes("reroll")) {
        score = 45;
      }
      // æ¯€æ»…æ€§å‚·å£
      if (desc.includes("æ¯€æ»…æ€§") || desc.includes("è‡´å‘½å‚·")) {
        score = 65;
        if (target?.stats?.Sv <= 3) score += 20; // å°é«˜è­·ç”²æ›´æœ‰æ•ˆ
      }
      // ç„¡è¦–æ©è­·
      if (desc.includes("ç„¡è¦–æ©è­·") || desc.includes("æ©è­·")) {
        if (target?.inCover) score = 60;
        else score = 20;
      }
      // å‚·å®³åŠ æˆ
      if (desc.includes("å‚·å®³+") || desc.includes("damage")) {
        score = 55;
      }
      // é›†ä¸­ç«åŠ›ï¼ˆå¤šå–®ä½å°„æ“ŠåŒç›®æ¨™ï¼‰
      if (desc.includes("é›†ä¸­ç«åŠ›")) {
        score = 50;
      }
    }

    // === è¡é‹’éšæ®µæˆ°ç•¥ ===
    if (phase === "charge") {
      const charger = context.charger;
      const target = context.target;

      // è¡é‹’åŠ æˆ
      if (desc.includes("è¡é‹’") || desc.includes("charge")) {
        score = 55;
        // æ·±å…¥æ‰“æ“Šå¾Œè¡é‹’ç‰¹åˆ¥æœ‰åƒ¹å€¼
        if (desc.includes("æ·±å…¥") || desc.includes("æ‰“æ“Šå¾Œ")) score = 70;
      }
      // é‡æ“²è¡é‹’éª°
      if (desc.includes("é‡æ“²")) {
        score = 50;
      }
    }

    // === æˆ°é¬¥éšæ®µæˆ°ç•¥ ===
    if (phase === "fight") {
      const attacker = context.attacker;
      const target = context.target;

      // è¿‘æˆ°åŠ æˆ
      if (desc.includes("è¿‘æˆ°") || desc.includes("æ”»æ“Š") || desc.includes("fight")) {
        score = 50;
      }
      // S+1/åŠ›é‡åŠ æˆ
      if (desc.includes("s+") || desc.includes("åŠ›é‡")) {
        score = 55;
        if (target && attacker && attacker.weapons?.melee?.S <= target.stats?.T) score += 20;
      }
      // é¡å¤–æ”»æ“Š
      if (desc.includes("é¡å¤–æ”»æ“Š") || desc.includes("æ”»æ“Šæ¬¡æ•¸")) {
        score = 60;
      }
      // è‡´å‘½æ‰“æ“Š
      if (desc.includes("è‡´å‘½æ‰“æ“Š") || desc.includes("lethal")) {
        score = 55;
      }
    }

    // === é˜²ç¦¦æ€§æˆ°ç•¥ï¼ˆä»»ä½•éšæ®µéƒ½å¯èƒ½æœ‰ç”¨ï¼‰===
    if (desc.includes("å‘½ä¸­-1") || desc.includes("æ•µæ–¹å‘½ä¸­")) {
      // å¦‚æœæœ‰é‡è¦å–®ä½å¯èƒ½è¢«æ”»æ“Š
      const valuableUnits = myUnits.filter(u => u.keywords?.includes("Character") || u.currentHP > 8);
      if (valuableUnits.length > 0) score = Math.max(score, 45);
    }
    if (desc.includes("ç„¡æ‡¼æ­»äº¡") || desc.includes("fnp") || desc.includes("6+")) {
      const lowHPUnits = myUnits.filter(u => u.currentHP < u.maxHP * 0.6);
      if (lowHPUnits.length > 0) score = Math.max(score, 50);
    }

    // === æ ¹æ“šå±€å‹¢èª¿æ•´ ===
    // è½å¾Œæ™‚æ›´ç©æ¥µä½¿ç”¨é€²æ”»æˆ°ç•¥
    if (gameEval.vpDiff < -5) {
      if (desc.includes("å‚·å®³") || desc.includes("æ”»æ“Š") || desc.includes("+1")) {
        score += 15;
      }
    }
    // é ˜å…ˆæ™‚æ›´æ³¨é‡é˜²ç¦¦æˆ°ç•¥
    if (gameEval.vpDiff > 5) {
      if (desc.includes("é˜²è­·") || desc.includes("-1") || desc.includes("æ¢å¾©")) {
        score += 15;
      }
    }

    // CPæ•ˆç‡ï¼šä¾¿å®œçš„æˆ°ç•¥ç¨å¾®åŠ åˆ†
    if (strat.cp === 1) score += 5;

    // å›°é›£æ¨¡å¼ï¼šæ›´ç²¾ç¢ºçš„è©•ä¼°
    if (aiDifficulty === "hard") {
      score *= 1.2;
    }

    if (score > bestScore) {
      bestScore = score;
      bestStratagem = strat;
    }
  }

  // æ±ºå®šæ˜¯å¦ä½¿ç”¨ï¼ˆåˆ†æ•¸éœ€è¦å¤ é«˜ï¼‰
  const threshold = aiDifficulty === "easy" ? 60 : (aiDifficulty === "hard" ? 35 : 45);

  if (bestStratagem && bestScore >= threshold) {
    if (spendCP(aiPlayer, bestStratagem.cp)) {
      playSound('click');
      log(`ğŸ´ AIä½¿ç”¨ã€${bestStratagem.name}ã€‘(${bestStratagem.cp}CP)`, "phase");
      log(`   â†’ ${bestStratagem.desc}`, "info");

      // åœ¨æˆ°å ´ä¸­å¤®é¡¯ç¤ºæˆ°ç•¥åç¨±
      const centerX = (gameState.canvasWidth || 600) / 2;
      const centerY = (gameState.canvasHeight || 440) / 2;
      showFloatingText(centerX, centerY, bestStratagem.name, {
        color: "#fbbf24",
        fontSize: 18,
        duration: 1500
      });

      updateCPDisplay();
      await delay(500);

      // è¿”å›æˆ°ç•¥è³‡è¨Šä¾›èª¿ç”¨è€…æ‡‰ç”¨æ•ˆæœ
      return bestStratagem;
    }
  }

  return null;
}

// æ‡‰ç”¨æˆ°ç•¥æ•ˆæœåˆ°æ”»æ“Š
function applyStratagemEffect(stratagem, attacker, target, attackContext) {
  if (!stratagem) return {};

  const desc = stratagem.desc.toLowerCase();
  const effects = {};

  // å‘½ä¸­åŠ æˆ
  if (desc.includes("å‘½ä¸­+1") || desc.includes("+1") && desc.includes("å‘½ä¸­")) {
    effects.hitBonus = 1;
  }
  // è‡´å‚·åŠ æˆ
  if (desc.includes("è‡´å‚·+1") || desc.includes("+1") && desc.includes("è‡´å‚·")) {
    effects.woundBonus = 1;
  }
  // é‡æ“²å‘½ä¸­
  if (desc.includes("é‡æ“²å‘½ä¸­") || desc.includes("å…¨é‡æ“²")) {
    effects.rerollHits = true;
  }
  // é‡æ“²è‡´å‚·
  if (desc.includes("é‡æ“²è‡´å‚·") || desc.includes("é‡æ“²æ‰€æœ‰è‡´å‚·")) {
    effects.rerollWounds = true;
  }
  // æ¯€æ»…æ€§å‚·å£
  if (desc.includes("æ¯€æ»…æ€§å‚·å£") || desc.includes("devastating")) {
    effects.devastatingWounds = true;
  }
  // è‡´å‘½æ‰“æ“Š
  if (desc.includes("è‡´å‘½æ‰“æ“Š") || desc.includes("lethal")) {
    effects.lethalHits = true;
  }
  // ç„¡è¦–æ©è­·
  if (desc.includes("ç„¡è¦–æ©è­·")) {
    effects.ignoreCover = true;
  }
  // å‚·å®³åŠ æˆ
  if (desc.includes("å‚·å®³+1")) {
    effects.damageBonus = 1;
  }
  // åŠ›é‡åŠ æˆ
  if (desc.includes("s+1") || desc.includes("åŠ›é‡+1")) {
    effects.strengthBonus = 1;
  }
  if (desc.includes("s+2") || desc.includes("åŠ›é‡+2")) {
    effects.strengthBonus = 2;
  }
  // APåŠ æˆ
  if (desc.includes("ap+1") || desc.includes("apæ”¹é€²")) {
    effects.apBonus = 1;
  }

  return effects;
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// AIç§»å‹•éšæ®µ
async function aiMovementPhase() {
  const aiPlayer = gameState.currentPlayer;
  const enemyPlayer = aiPlayer === 1 ? 2 : 1;
  const myUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive && !u.hasMoved);

  for (const unit of myUnits) {
    await delay(200);
    const target = aiSelectMoveTarget(unit);
    if (target) {
      const maxDist = unit.stats.M * INCH;
      const dx = target.x - unit.x;
      const dy = target.y - unit.y;
      const dist = Math.hypot(dx, dy);

      if (dist > 0) {
        const moveDist = Math.min(dist, maxDist);
        const ratio = moveDist / dist;
        let newX = unit.x + dx * ratio;
        let newY = unit.y + dy * ratio;

        // æª¢æŸ¥ç¢°æ’ä¸¦èª¿æ•´ä½ç½®
        const baseSize = getUnitBaseSize(unit);
        const otherUnits = gameState.units.filter(u => u !== unit && u.alive);
        if (!isPositionValid(newX, newY, baseSize, otherUnits)) {
          // å˜—è©¦æ‰¾åˆ°ä¸é‡ç–Šçš„æ›¿ä»£ä½ç½®
          let found = false;
          for (let angle = 0; angle < Math.PI * 2 && !found; angle += Math.PI / 8) {
            for (let distRatio = 0.8; distRatio >= 0.2 && !found; distRatio -= 0.2) {
              const altX = unit.x + dx * ratio * distRatio + Math.cos(angle) * baseSize;
              const altY = unit.y + dy * ratio * distRatio + Math.sin(angle) * baseSize;
              if (isPositionValid(altX, altY, baseSize, otherUnits)) {
                newX = altX;
                newY = altY;
                found = true;
              }
            }
          }
          // å¦‚æœé‚„æ˜¯æ‰¾ä¸åˆ°ï¼Œå°±ä¸ç§»å‹•
          if (!found) {
            newX = unit.x;
            newY = unit.y;
          }
        }

        if (newX !== unit.x || newY !== unit.y) {
          unit.x = newX;
          unit.y = newY;
          checkCover(unit);
          log(`ğŸ¤– ${unit.name} ç§»å‹•`, "info");
        }
      }
    }
    unit.hasMoved = true;
    updateUnitLists();
    render();
  }
}

// ========== AIæˆ°ç•¥è©•ä¼°ç³»çµ± ==========
// è©•ä¼°ç•¶å‰éŠæˆ²å±€å‹¢ï¼ˆVPã€æ§åˆ¶çš„ç›®æ¨™ã€å…µåŠ›å°æ¯”ï¼‰
function evaluateGameState(aiPlayer) {
  const enemyPlayer = aiPlayer === 1 ? 2 : 1;
  const myVP = gameState.vp[aiPlayer];
  const enemyVP = gameState.vp[enemyPlayer];
  const vpDiff = myVP - enemyVP;

  const myUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive);
  const enemyUnits = gameState.units.filter(u => u.player === enemyPlayer && u.alive);

  // è¨ˆç®—ç¸½OC
  const myTotalOC = myUnits.reduce((sum, u) => sum + u.stats.OC, 0);
  const enemyTotalOC = enemyUnits.reduce((sum, u) => sum + u.stats.OC, 0);

  // è¨ˆç®—æ§åˆ¶çš„ç›®æ¨™æ•¸
  const myObjectives = gameState.objectives.filter(o => o.control === aiPlayer).length;
  const enemyObjectives = gameState.objectives.filter(o => o.control === enemyPlayer).length;

  // è¨ˆç®—æˆ°é¬¥åŠ›ï¼ˆç°¡åŒ–ï¼šHPç¸½å’Œï¼‰
  const myPower = myUnits.reduce((sum, u) => sum + u.currentHP, 0);
  const enemyPower = enemyUnits.reduce((sum, u) => sum + u.currentHP, 0);

  // æ±ºå®šæˆ°ç•¥æ…‹å‹¢
  let strategy = "balanced";

  if (vpDiff >= 10 || (myObjectives >= 3 && vpDiff > 0)) {
    strategy = "defensive"; // é ˜å…ˆæ™‚é˜²å®ˆ
  } else if (vpDiff <= -10 || enemyObjectives >= 3) {
    strategy = "aggressive"; // è½å¾Œæ™‚é€²æ”»
  } else if (gameState.round >= 4) {
    strategy = "objective_rush"; // å¾ŒæœŸæ¶åˆ†
  }

  // å¦‚æœå…µåŠ›æ‡¸æ®Šï¼Œèª¿æ•´ç­–ç•¥
  if (myPower < enemyPower * 0.5) {
    strategy = "objective_rush"; // å…µåŠ›åŠ£å‹¢æ™‚å°ˆæ³¨æ¶åˆ†
  } else if (myPower > enemyPower * 1.5) {
    strategy = "aggressive"; // å…µåŠ›å„ªå‹¢æ™‚é€²æ”»
  }

  return {
    vpDiff,
    myVP,
    enemyVP,
    myObjectives,
    enemyObjectives,
    myTotalOC,
    enemyTotalOC,
    myPower,
    enemyPower,
    strategy,
    round: gameState.round,
    maxRounds: 5
  };
}

// è¨ˆç®—ç›®æ¨™çš„æˆ°ç•¥åƒ¹å€¼ï¼ˆè€ƒæ…®ç•¶å‰å±€å‹¢ï¼‰
function getObjectiveValue(obj, unit, gameEval, aiPlayer) {
  let value = 100; // åŸºç¤åƒ¹å€¼

  const dist = Math.hypot(unit.x - obj.x, unit.y - obj.y) / INCH;
  const canReach = dist <= unit.stats.M + 3; // 3" æ˜¯ç›®æ¨™ç¯„åœ

  // è·é›¢æ‡²ç½°
  value -= dist * 3;

  // æ§åˆ¶ç‹€æ…‹åŠ æˆ
  if (obj.control === null) {
    value += 40; // ä¸­ç«‹ç›®æ¨™
  } else if (obj.control !== aiPlayer) {
    value += 60; // æ•µæ–¹ç›®æ¨™ï¼ˆæ¶å¥ªï¼‰
  } else {
    value -= 20; // å·±æ–¹å·²æ§åˆ¶
  }

  // ä¸­å¤®ç›®æ¨™æ›´é‡è¦
  if (obj.id === 1) value += 25;

  // æ ¹æ“šæˆ°ç•¥èª¿æ•´
  if (gameEval.strategy === "objective_rush") {
    value *= 1.5; // æ¶åˆ†ç­–ç•¥æ™‚ç›®æ¨™æ›´é‡è¦
  } else if (gameEval.strategy === "defensive" && obj.control === aiPlayer) {
    value += 30; // é˜²å®ˆæ™‚ä¿ä½å·²æœ‰ç›®æ¨™
  }

  // å¾ŒæœŸç›®æ¨™æ›´é‡è¦
  if (gameEval.round >= 3) {
    value *= 1.2;
  }
  if (gameEval.round >= 4) {
    value *= 1.3;
  }

  // é«˜OCå–®ä½ä½”é»åƒ¹å€¼æ›´é«˜
  value += unit.stats.OC * 15;

  return { obj, value, dist, canReach };
}

// AIé¸æ“‡ç§»å‹•ç›®æ¨™ - ç­–ç•¥æ€§AIï¼ˆä»¥å¾—åˆ†ç‚ºå„ªå…ˆï¼‰
function aiSelectMoveTarget(unit) {
  const aiPlayer = unit.player;
  const enemyPlayer = aiPlayer === 1 ? 2 : 1;
  const enemies = gameState.units.filter(u => u.player === enemyPlayer && u.alive);
  const myUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive);
  const objectives = gameState.objectives;

  // è©•ä¼°ç•¶å‰å±€å‹¢
  const gameEval = evaluateGameState(aiPlayer);

  if (aiDifficulty === "easy") {
    // ç°¡å–®ï¼šéš¨æ©Ÿç§»å‹•
    return { x: unit.x + (Math.random() - 0.5) * unit.stats.M * INCH, y: unit.y + (Math.random() - 0.5) * unit.stats.M * INCH };
  }

  // ===== ç­–ç•¥æ€§AIï¼ˆæ™®é€š/å›°é›£ï¼‰=====
  // æ ¸å¿ƒåŸå‰‡ï¼šä»¥å¾—åˆ†(VP)ç‚ºæœ€é«˜å„ªå…ˆï¼

  // 1. è¨ˆç®—å–®ä½çš„æˆ°ç•¥è§’è‰²
  const isHighOC = unit.stats.OC >= 2;           // é«˜ç›®æ¨™æ§åˆ¶å€¼
  const isMeleeOnly = !unit.weapons.ranged && unit.weapons.melee;
  const isRanged = unit.weapons.ranged;
  const isCharacter = unit.keywords?.includes("Character");
  const isLowHP = unit.currentHP / unit.maxHP < 0.4;

  // é¡¯ç¤ºç•¶å‰æˆ°ç•¥
  if (myUnits.indexOf(unit) === 0) {
    log(`ğŸ“Š AIæˆ°ç•¥: ${gameEval.strategy} (VP: ${gameEval.myVP} vs ${gameEval.enemyVP})`, "info");
  }

  // 2. ä½¿ç”¨æ–°çš„ç›®æ¨™è©•ä¼°ç³»çµ±
  const objectiveScores = objectives.map(obj => getObjectiveValue(obj, unit, gameEval, aiPlayer));

  // æª¢æŸ¥ç›®æ¨™é™„è¿‘çš„æ•µè»OC
  objectiveScores.forEach(os => {
    const enemyOCNearby = enemies
      .filter(e => Math.hypot(e.x - os.obj.x, e.y - os.obj.y) / INCH <= 3)
      .reduce((sum, e) => sum + e.stats.OC, 0);

    const myOCNearby = myUnits
      .filter(u => u.id !== unit.id && Math.hypot(u.x - os.obj.x, u.y - os.obj.y) / INCH <= 3)
      .reduce((sum, u) => sum + u.stats.OC, 0);

    // éœ€è¦æ›´å¤šOCä¾†çˆ­å¥ªçš„ç›®æ¨™
    if (myOCNearby < enemyOCNearby && isHighOC) os.value += 50;

    // å›°é›£æ¨¡å¼ï¼šè€ƒæ…®OCç©©å›ºåº¦
    if (aiDifficulty === "hard") {
      if (os.obj.control === aiPlayer && myOCNearby <= enemyOCNearby + unit.stats.OC) {
        os.value += 25; // éœ€è¦å¢æ´çš„å·±æ–¹ç›®æ¨™
      }
    }
  });

  objectiveScores.sort((a, b) => b.value - a.value);

  // 3. æ±ºå®šç§»å‹•ç›®æ¨™ - ç›®æ¨™å„ªå…ˆï¼
  let targetPosition = null;

  // æ‰€æœ‰å–®ä½éƒ½æ‡‰è©²è€ƒæ…®ä½”é»ï¼ˆä¸åªæ˜¯é«˜OCï¼‰
  // ä½†é«˜OCå–®ä½æœ‰æ›´é«˜çš„å„ªå…ˆç´š
  const objectivePriority = isHighOC ? 0.9 : (gameEval.strategy === "objective_rush" ? 0.8 : 0.6);

  if (Math.random() < objectivePriority && objectiveScores.length > 0 && objectiveScores[0].value > 30) {
    const bestObj = objectiveScores[0].obj;
    if (objectiveScores[0].canReach || objectiveScores[0].dist <= unit.stats.M * 2) {
      targetPosition = { x: bestObj.x, y: bestObj.y };
      const action = bestObj.control === aiPlayer ? "é˜²å®ˆ" : (bestObj.control === null ? "ä½”é ˜" : "æ¶å¥ª");
      log(`ğŸ¯ ${unit.name} ç­–ç•¥ï¼š${action}ç›®æ¨™é»${bestObj.id}`, "info");
    }
  }

  // è¿‘æˆ°å–®ä½ç­–ç•¥ï¼ˆä½”é»å„ªå…ˆï¼Œä½†ä¹Ÿè¦æ¸…é™¤å¨è„…ï¼‰
  if (!targetPosition && isMeleeOnly) {
    // å„ªå…ˆæ”»æ“Šåœ¨ç›®æ¨™é™„è¿‘çš„æ•µäººï¼ˆæ¸…é™¤ä½”é»å¨è„…ï¼‰
    const enemiesNearObjectives = enemies.filter(e =>
      objectives.some(o => Math.hypot(e.x - o.x, e.y - o.y) / INCH <= 4)
    );

    if (enemiesNearObjectives.length > 0) {
      const nearestThreat = findNearest(unit, enemiesNearObjectives);
      if (nearestThreat) {
        targetPosition = nearestThreat;
        log(`ğŸ§  ${unit.name} ç­–ç•¥ï¼šæ¸…é™¤ç›®æ¨™é™„è¿‘æ•µäºº`, "info");
      }
    } else {
      const nearestEnemy = findNearest(unit, enemies);
      if (nearestEnemy) targetPosition = nearestEnemy;
    }
  }

  // é ç¨‹å–®ä½ç­–ç•¥ - æ ¹æ“šæˆ°ç•¥æ±ºå®šæ˜¯å¦ç§»å‹•
  if (!targetPosition && isRanged) {
    const weapon = unit.weapons.ranged;
    const inRangeEnemies = enemies.filter(e => {
      const dist = Math.hypot(e.x - unit.x, e.y - unit.y) / INCH;
      return dist <= weapon.range;
    });

    if (inRangeEnemies.length > 0) {
      // å·²æœ‰ç›®æ¨™åœ¨å°„ç¨‹å…§
      if (aiDifficulty === "hard" || gameEval.strategy === "defensive") {
        // å›°é›£æ¨¡å¼æˆ–é˜²å®ˆç­–ç•¥ï¼šå°‹æ‰¾æ©è­·
        if (!unit.inCover) {
          const coverSpot = findNearestCover(unit);
          if (coverSpot) {
            const coverDist = Math.hypot(coverSpot.x - unit.x, coverSpot.y - unit.y);
            if (coverDist <= unit.stats.M * INCH) {
              targetPosition = coverSpot;
              log(`ğŸ›¡ï¸ ${unit.name} ç­–ç•¥ï¼šç§»å‹•åˆ°æ©è­·ä½ç½®`, "info");
            }
          }
        }
      }

      // æ¶åˆ†ç­–ç•¥ï¼šå³ä½¿æœ‰å°„ç¨‹ç›®æ¨™ï¼Œä¹Ÿå¯èƒ½éœ€è¦ç§»å‹•å»ä½”é»
      if (!targetPosition && gameEval.strategy === "objective_rush" && unit.stats.OC > 0) {
        const urgentObjective = objectiveScores.find(o => o.canReach && o.obj.control !== aiPlayer);
        if (urgentObjective && urgentObjective.value > 80) {
          targetPosition = urgentObjective.obj;
          log(`ğŸ¯ ${unit.name} ç­–ç•¥ï¼šæ”¾æ£„å°„æ“Šå»æ¶é»`, "info");
        }
      }

      if (!targetPosition) {
        return null; // ä¸ç§»å‹•ï¼Œå°ˆæ³¨å°„æ“Š
      }
    } else {
      // æ²’æœ‰ç›®æ¨™åœ¨å°„ç¨‹å…§
      // å„ªå…ˆè€ƒæ…®ç§»å‹•åˆ°ç›®æ¨™é»ï¼ˆå¦‚æœæœ‰åƒ¹å€¼ï¼‰
      const goodObjective = objectiveScores.find(o => o.value > 50 && o.dist <= unit.stats.M * 2);
      if (goodObjective) {
        targetPosition = goodObjective.obj;
        log(`ğŸ¯ ${unit.name} ç­–ç•¥ï¼šç§»å‹•å»ä½”é»`, "info");
      } else {
        // å¦å‰‡å‘æ•µäººé è¿‘
        const nearestEnemy = findNearest(unit, enemies);
        if (nearestEnemy) {
          targetPosition = nearestEnemy;
          log(`ğŸ”« ${unit.name} ç­–ç•¥ï¼šæ¥è¿‘å°„ç¨‹`, "info");
        }
      }
    }
  }

  // ä½HPå–®ä½è€ƒæ…®æ’¤é€€ï¼ˆä½†åœ¨æ¶åˆ†ç­–ç•¥ä¸‹å¯èƒ½å …å®ˆï¼‰
  if (isLowHP && !unit.inCover) {
    if (gameEval.strategy !== "objective_rush" || gameEval.vpDiff > -5) {
      if (aiDifficulty === "hard") {
        const coverSpot = findNearestCover(unit);
        if (coverSpot) {
          targetPosition = coverSpot;
          log(`ğŸ›¡ï¸ ${unit.name} ç­–ç•¥ï¼šæ’¤é€€åˆ°æ©è­·ï¼ˆHPä½ï¼‰`, "info");
        }
      }
    } else {
      log(`ğŸ’€ ${unit.name} ç­–ç•¥ï¼šå …å®ˆé™£åœ°ï¼ˆæ¶åˆ†å„ªå…ˆï¼‰`, "info");
    }
  }

  // æœ€å¾Œä¿åº•ï¼šå¦‚æœæ²’æœ‰ç›®æ¨™ï¼Œä¸€å®šè¦å»ä½”é»
  if (!targetPosition && objectiveScores.length > 0) {
    // å„ªå…ˆæ¶å¥ªæ•µæ–¹ç›®æ¨™ï¼Œå…¶æ¬¡ä¸­ç«‹ï¼Œæœ€å¾Œå¢æ´å·±æ–¹
    const priority = objectiveScores.find(o => o.obj.control !== aiPlayer && o.obj.control !== null) ||
                     objectiveScores.find(o => o.obj.control === null) ||
                     objectiveScores.find(o => o.obj.control === aiPlayer);
    if (priority) {
      targetPosition = priority.obj;
      log(`ğŸ¯ ${unit.name} ç­–ç•¥ï¼šå‰å¾€ç›®æ¨™é»${priority.obj.id}`, "info");
    }
  }

  return targetPosition;
}

// AIå°„æ“Šéšæ®µ
async function aiShootingPhase() {
  const aiPlayer = gameState.currentPlayer;
  const myUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive && !u.hasShot && u.weapons.ranged);

  // å°„æ“Šéšæ®µé–‹å§‹æ™‚è€ƒæ…®ä½¿ç”¨æˆ°ç•¥
  let phaseStratagem = null;
  if (myUnits.length > 0) {
    const firstTarget = aiSelectShootTarget(myUnits[0]);
    phaseStratagem = await aiConsiderStratagem("shooting", { attacker: myUnits[0], target: firstTarget });
  }

  for (const unit of myUnits) {
    await delay(300);
    const target = aiSelectShootTarget(unit);

    if (target) {
      let weapon = unit.weapons.ranged;

      // æª¢æŸ¥ä¸€æ¬¡æ€§æ­¦å™¨æ˜¯å¦å·²ä½¿ç”¨
      if (weapon.oneUse) {
        if (!unit.usedOneUseWeapons) unit.usedOneUseWeapons = {};
        if (unit.usedOneUseWeapons[weapon.name]) {
          log(`${unit.name} çš„ ${weapon.name} å·²ä½¿ç”¨éï¼ˆä¸€æ¬¡æ€§ï¼‰`, "info");
          unit.hasShot = true;
          continue;
        }
      }
      const distance = Math.hypot(unit.x - target.x, unit.y - target.y) / INCH;

      if (distance <= weapon.range) {
        gameState.selectedUnit = unit;
        gameState.targetUnit = target;

        // å°é‡è¦ç›®æ¨™è€ƒæ…®ä½¿ç”¨é¡å¤–æˆ°ç•¥
        if (!phaseStratagem && target.keywords?.includes("Character") && gameState.cp[aiPlayer] >= 1) {
          phaseStratagem = await aiConsiderStratagem("shooting", { attacker: unit, target: target });
        }

        log(`ğŸ¤– ${unit.name} å°„æ“Š ${target.name}`, "phase");

        // æ‡‰ç”¨æˆ°ç•¥æ•ˆæœ
        const stratagemEffects = applyStratagemEffect(phaseStratagem, unit, target, { phase: "shooting" });
        gameState.activeStratagemEffects = stratagemEffects;

        await performAttack(unit, target, weapon, "ranged");
        unit.hasShot = true;

        // æ¨™è¨˜ä¸€æ¬¡æ€§æ­¦å™¨å·²ä½¿ç”¨
        if (weapon.oneUse) {
          if (!unit.usedOneUseWeapons) unit.usedOneUseWeapons = {};
          unit.usedOneUseWeapons[weapon.name] = true;
          log(`âš¡ ${weapon.name} å·²ä½¿ç”¨ï¼ˆä¸€æ¬¡æ€§æ­¦å™¨ï¼‰`, "info");
        }

        updateUnitLists();
        render();
      }
    }
    unit.hasShot = true;
  }

  // æ¸…é™¤æˆ°ç•¥æ•ˆæœ
  gameState.activeStratagemEffects = null;
}

// AIé¸æ“‡å°„æ“Šç›®æ¨™ - ç­–ç•¥æ€§AI
function aiSelectShootTarget(unit) {
  const aiPlayer = unit.player;
  const enemyPlayer = aiPlayer === 1 ? 2 : 1;
  const enemies = gameState.units.filter(u => u.player === enemyPlayer && u.alive);
  if (enemies.length === 0) return null;

  const weapon = unit.weapons.ranged;
  const inRange = enemies.filter(e => {
    const dist = Math.hypot(e.x - unit.x, e.y - unit.y) / INCH;
    return dist <= weapon.range;
  });

  if (inRange.length === 0) return null;

  if (aiDifficulty === "easy") {
    return inRange[Math.floor(Math.random() * inRange.length)];
  }

  // ===== ç­–ç•¥æ€§ç›®æ¨™é¸æ“‡ï¼ˆæ™®é€š/å›°é›£ï¼‰=====
  const objectives = gameState.objectives;
  const gameEval = evaluateGameState(unit.player);

  const scored = inRange.map(enemy => {
    let score = 0;

    // 1. å¯æ“Šæ®ºç›®æ¨™ï¼ˆé«˜å„ªå…ˆï¼‰
    const potentialDamage = estimateDamage(weapon, enemy);
    if (potentialDamage >= enemy.currentHP) {
      score += 80; // å¯ä»¥æ“Šæ®ºçš„ç›®æ¨™æœ€å„ªå…ˆ
    }

    // 2. ä½HPç›®æ¨™
    const hpRatio = enemy.currentHP / enemy.maxHP;
    score += (1 - hpRatio) * 40;

    // 3. ç›®æ¨™é™„è¿‘çš„æ•µäººï¼ˆæˆ°ç•¥åƒ¹å€¼é«˜ï¼‰- æ ¹æ“šæˆ°ç•¥åŠ æ¬Š
    const objNear = objectives.find(o =>
      Math.hypot(enemy.x - o.x, enemy.y - o.y) / INCH <= 3
    );
    if (objNear) {
      let objBonus = 35;
      // å¦‚æœæ•µäººä½”è‘—æˆ‘å€‘éœ€è¦çš„ç›®æ¨™ï¼Œå„ªå…ˆæ¸…é™¤
      if (objNear.control !== unit.player) {
        objBonus += 30;
      }
      // æ¶åˆ†ç­–ç•¥æ™‚ç›®æ¨™æ›´é‡è¦
      if (gameEval.strategy === "objective_rush") {
        objBonus *= 1.5;
      }
      score += objBonus;
      // é«˜OCæ•µäººåœ¨ç›®æ¨™é™„è¿‘æ›´å±éšª
      score += enemy.stats.OC * 15;
    }

    // 4. é«˜å¨è„…ç›®æ¨™ï¼ˆè§’è‰²ã€å¼·åŠ›æ­¦å™¨ï¼‰
    const threat = calculateThreat(enemy);
    score += threat * 25;

    // 5. é ˜å°å–®ä½ï¼ˆæ¶ˆæ»…å¯èƒ½é€ æˆæˆ°æ…„ï¼‰
    if (enemy.keywords?.includes("Character")) score += 25;

    // 6. ç„¡æ©è­·ç›®æ¨™ï¼ˆæ›´å®¹æ˜“é€ æˆå‚·å®³ï¼‰
    if (!enemy.inCover) score += 15;

    // 7. å›°é›£æ¨¡å¼ï¼šæ›´ç²¾ç´°çš„æ•ˆç‡è¨ˆç®—
    if (aiDifficulty === "hard") {
      const woundRoll = getWoundRoll(weapon.S, enemy.stats.T);
      score += (7 - woundRoll) * 8; // è¶Šå®¹æ˜“è‡´å‚·è¶Šå¥½

      // è€ƒæ…®è­·ç”²ç©¿é€æ•ˆç‡
      const effectiveSave = Math.max(2, enemy.stats.Sv - (weapon.AP || 0));
      score += (7 - effectiveSave) * 5; // è¶Šé›£è±å…è¶Šå¥½

      // å¦‚æœæ•µäººæœ‰ç„¡æ•µè±å…ï¼Œé™ä½å„ªå…ˆç´š
      if (enemy.inv) score -= 10;

      // å„ªå…ˆæ”»æ“Šæ²’æœ‰æ©è­·çš„é«˜åƒ¹å€¼ç›®æ¨™
      if (!enemy.inCover && enemy.points > 100) score += 20;

      // é˜²å®ˆç­–ç•¥æ™‚å„ªå…ˆæ¸…é™¤å¨è„…æˆ‘æ–¹ç›®æ¨™çš„æ•µäºº
      if (gameEval.strategy === "defensive" && objNear && objNear.control === unit.player) {
        score += 40;
      }
    }

    return { enemy, score };
  });

  scored.sort((a, b) => b.score - a.score);

  // è¨˜éŒ„AIæ€è€ƒéç¨‹
  if (aiDifficulty === "hard" && scored.length > 0) {
    log(`ğŸ§  ç›®æ¨™åˆ†æï¼š${scored[0].enemy.name}(${scored[0].score.toFixed(0)}åˆ†)`, "info");
  }

  return scored[0].enemy;
}

// AIè¡é‹’éšæ®µ
async function aiChargePhase() {
  const aiPlayer = gameState.currentPlayer;
  const enemyPlayer = aiPlayer === 1 ? 2 : 1;
  // å®˜æ–¹è¦å‰‡ï¼šæˆ°æ…„ä¸­çš„å–®ä½ä¸èƒ½è¡é‹’
  const myUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive && !u.hasCharged && !u.battleShocked && u.weapons.melee);

  // è¡é‹’éšæ®µé–‹å§‹æ™‚è€ƒæ…®ä½¿ç”¨æˆ°ç•¥
  let chargeStratagem = null;
  if (myUnits.length > 0) {
    chargeStratagem = await aiConsiderStratagem("charge", { charger: myUnits[0] });
  }

  for (const unit of myUnits) {
    const enemies = gameState.units.filter(u => u.player === enemyPlayer && u.alive);
    const nearbyEnemies = enemies.filter(e => {
      const dist = Math.hypot(e.x - unit.x, e.y - unit.y) / INCH;
      return dist <= 12 && dist > 1.5;
    });

    if (nearbyEnemies.length > 0 && shouldCharge(unit, nearbyEnemies)) {
      await delay(300);

      // ç­–ç•¥æ€§è¡é‹’ç›®æ¨™é¸æ“‡
      const target = aiSelectChargeTarget(unit, nearbyEnemies);

      let roll1 = rollD6();
      let roll2 = rollD6();
      let chargeRoll = roll1 + roll2;
      const dist = Math.hypot(target.x - unit.x, target.y - unit.y) / INCH;

      // å¦‚æœè¡é‹’å¤±æ•—ä¸”æœ‰æˆ°ç•¥å¯é‡æ“²ï¼Œè€ƒæ…®ä½¿ç”¨
      if (chargeRoll < dist && !chargeStratagem && gameState.cp[aiPlayer] >= 1) {
        const rerollStrat = await aiConsiderStratagem("charge", { charger: unit, target: target, needReroll: true });
        if (rerollStrat && rerollStrat.desc.includes("é‡æ“²")) {
          log(`ğŸ² AIä½¿ç”¨æˆ°ç•¥é‡æ“²è¡é‹’éª°`, "info");
          roll1 = rollD6();
          roll2 = rollD6();
          chargeRoll = roll1 + roll2;
        }
      }

      // è¡é‹’éª°å­å‹•ç•«
      if (enableDiceAnimation) {
        await showChargeRoll(roll1, roll2, dist);
      }

      log(`ğŸ¤– ${unit.name} è¡é‹’æ“²éª°: ${roll1}+${roll2}=${chargeRoll}" (éœ€è¦${dist.toFixed(1)}")`, "info");

      if (chargeRoll >= dist) {
        // ç§»å‹•åˆ°ç›®æ¨™æ—é‚Š
        const angle = Math.atan2(target.y - unit.y, target.x - unit.x);
        let newX = target.x - Math.cos(angle) * INCH * 1.2;
        let newY = target.y - Math.sin(angle) * INCH * 1.2;

        // æª¢æŸ¥æ˜¯å¦èˆ‡å‹è»é‡ç–Šï¼Œå¦‚æœæ˜¯å‰‡å˜—è©¦æ‰¾å…¶ä»–ä½ç½®
        const baseSize = getUnitBaseSize(unit);
        const friendlyUnits = gameState.units.filter(u => u !== unit && u.alive && u.player === unit.player);
        if (!isPositionValid(newX, newY, baseSize, friendlyUnits)) {
          // å˜—è©¦åœç¹ç›®æ¨™æ‰¾åˆ°ä¸é‡ç–Šçš„ä½ç½®
          for (let angleOffset = Math.PI / 4; angleOffset <= Math.PI * 2; angleOffset += Math.PI / 4) {
            const testAngle = angle + angleOffset;
            const testX = target.x - Math.cos(testAngle) * INCH * 1.5;
            const testY = target.y - Math.sin(testAngle) * INCH * 1.5;
            if (isPositionValid(testX, testY, baseSize, friendlyUnits)) {
              newX = testX;
              newY = testY;
              break;
            }
          }
        }

        unit.x = newX;
        unit.y = newY;
        playSound('charge'); // éŸ³æ•ˆï¼šè¡é‹’
        log(`ğŸ¤– ${unit.name} è¡é‹’æˆåŠŸï¼`, "hit");
      } else {
        playSound('miss'); // éŸ³æ•ˆï¼šå¤±æ•—
        log(`ğŸ¤– ${unit.name} è¡é‹’å¤±æ•—`, "miss");
      }

      unit.hasCharged = true;
      updateUnitLists();
      render();
    }
    unit.hasCharged = true;
  }
}

// åˆ¤æ–·æ˜¯å¦æ‡‰è©²è¡é‹’
function shouldCharge(unit, enemies) {
  if (aiDifficulty === "easy") return Math.random() > 0.5;

  // è¿‘æˆ°å°ˆç²¾å–®ä½å„ªå…ˆè¡é‹’
  if (!unit.weapons.ranged) return true;

  // å›°é›£æ¨¡å¼ï¼šåˆ†ææ˜¯å¦æœ‰åˆ©
  if (aiDifficulty === "hard") {
    const nearestEnemy = findNearest(unit, enemies);
    if (nearestEnemy) {
      const myMelee = unit.weapons.melee;
      const enemyHP = nearestEnemy.currentHP;
      // å¦‚æœå¯èƒ½é€ æˆå¤§é‡å‚·å®³å°±è¡é‹’
      const potentialDamage = estimateDamage(myMelee, nearestEnemy);
      if (potentialDamage >= enemyHP * 0.5) return true;

      // å¦‚æœæ•µäººåœ¨ç›®æ¨™é»é™„è¿‘ï¼Œè¡é‹’æ¸…é™¤
      const nearObjective = gameState.objectives.some(o =>
        Math.hypot(nearestEnemy.x - o.x, nearestEnemy.y - o.y) / INCH <= 3
      );
      if (nearObjective) return true;
    }
  }

  return Math.random() > 0.7;
}

// AIé¸æ“‡è¡é‹’ç›®æ¨™ - ç­–ç•¥æ€§é¸æ“‡
function aiSelectChargeTarget(unit, enemies) {
  if (enemies.length === 1) return enemies[0];

  if (aiDifficulty === "easy") {
    return findNearest(unit, enemies);
  }

  // ç­–ç•¥æ€§é¸æ“‡è¡é‹’ç›®æ¨™
  const objectives = gameState.objectives;
  const scored = enemies.map(enemy => {
    let score = 0;
    const dist = Math.hypot(unit.x - enemy.x, unit.y - enemy.y) / INCH;

    // è·é›¢è¿‘çš„å„ªå…ˆï¼ˆæ›´å®¹æ˜“æˆåŠŸï¼‰
    score += (12 - dist) * 5;

    // å¯æ“Šæ®ºç›®æ¨™å„ªå…ˆ
    const potentialDamage = estimateDamage(unit.weapons.melee, enemy);
    if (potentialDamage >= enemy.currentHP) score += 50;

    // ç›®æ¨™é»é™„è¿‘çš„æ•µäººå„ªå…ˆ
    const nearObjective = objectives.some(o =>
      Math.hypot(enemy.x - o.x, enemy.y - o.y) / INCH <= 3
    );
    if (nearObjective) score += 40;

    // é«˜OCæ•µäººå„ªå…ˆ
    score += enemy.stats.OC * 8;

    // ä½HPæ•µäººå„ªå…ˆ
    const hpRatio = enemy.currentHP / enemy.maxHP;
    score += (1 - hpRatio) * 30;

    // å›°é›£æ¨¡å¼ï¼šè€ƒæ…®å¨è„…
    if (aiDifficulty === "hard") {
      // å„ªå…ˆæ¶ˆæ»…é«˜å¨è„…ç›®æ¨™
      const threat = calculateThreat(enemy);
      score += threat * 15;
    }

    return { enemy, score };
  });

  scored.sort((a, b) => b.score - a.score);
  return scored[0].enemy;
}

// AIè¿‘æˆ°éšæ®µ
async function aiFightPhase() {
  const aiPlayer = gameState.currentPlayer;
  const enemyPlayer = aiPlayer === 1 ? 2 : 1;
  const myUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive && !u.hasFought && u.weapons.melee);

  // æˆ°é¬¥éšæ®µé–‹å§‹æ™‚è€ƒæ…®ä½¿ç”¨æˆ°ç•¥
  let fightStratagem = null;
  if (myUnits.length > 0) {
    fightStratagem = await aiConsiderStratagem("fight", { attacker: myUnits[0] });
  }

  for (const unit of myUnits) {
    const enemies = gameState.units.filter(u => u.player === enemyPlayer && u.alive);
    const meleeRange = enemies.filter(e => {
      const dist = Math.hypot(e.x - unit.x, e.y - unit.y) / INCH;
      return dist <= 1.5;
    });

    if (meleeRange.length > 0) {
      await delay(300);
      const target = aiSelectMeleeTarget(unit, meleeRange);

      if (target) {
        gameState.selectedUnit = unit;
        gameState.targetUnit = target;

        // å°é‡è¦ç›®æ¨™è€ƒæ…®ä½¿ç”¨é¡å¤–æˆ°ç•¥
        if (!fightStratagem && target.keywords?.includes("Character") && gameState.cp[aiPlayer] >= 1) {
          fightStratagem = await aiConsiderStratagem("fight", { attacker: unit, target: target });
        }

        log(`ğŸ¤– ${unit.name} è¿‘æˆ°æ”»æ“Š ${target.name}`, "phase");

        // æ‡‰ç”¨æˆ°ç•¥æ•ˆæœ
        const stratagemEffects = applyStratagemEffect(fightStratagem, unit, target, { phase: "fight" });
        gameState.activeStratagemEffects = stratagemEffects;

        await performAttack(unit, target, unit.weapons.melee, "melee");
      }
    }

    unit.hasFought = true;
    updateUnitLists();
    render();
  }

  // æ¸…é™¤æˆ°ç•¥æ•ˆæœ
  gameState.activeStratagemEffects = null;
}

// AIé¸æ“‡è¿‘æˆ°ç›®æ¨™ - ç­–ç•¥æ€§é¸æ“‡
function aiSelectMeleeTarget(unit, enemies) {
  if (enemies.length === 0) return null;
  if (enemies.length === 1) return enemies[0];

  if (aiDifficulty === "easy") {
    return enemies[Math.floor(Math.random() * enemies.length)];
  }

  // ===== ç­–ç•¥æ€§è¿‘æˆ°ç›®æ¨™é¸æ“‡ =====
  const objectives = gameState.objectives;
  const weapon = unit.weapons.melee;

  const scored = enemies.map(enemy => {
    let score = 0;

    // å¯æ“Šæ®ºç›®æ¨™å„ªå…ˆ
    const potentialDamage = estimateDamage(weapon, enemy);
    if (potentialDamage >= enemy.currentHP) {
      score += 80;
    }

    // ä½HPç›®æ¨™å„ªå…ˆ
    const hpRatio = enemy.currentHP / enemy.maxHP;
    score += (1 - hpRatio) * 40;

    // ç›®æ¨™é»é™„è¿‘çš„æ•µäººå„ªå…ˆ
    const nearObjective = objectives.some(o =>
      Math.hypot(enemy.x - o.x, enemy.y - o.y) / INCH <= 3
    );
    if (nearObjective) {
      score += 35;
      score += enemy.stats.OC * 8;
    }

    // é«˜å¨è„…ç›®æ¨™å„ªå…ˆ
    const threat = calculateThreat(enemy);
    score += threat * 20;

    // è§’è‰²ç›®æ¨™ï¼ˆæ¶ˆæ»…å¯èƒ½é€ æˆæˆ°æ…„ï¼‰
    if (enemy.keywords?.includes("Character")) score += 25;

    // å›°é›£æ¨¡å¼ï¼šè€ƒæ…®å‚·å®³æ•ˆç‡
    if (aiDifficulty === "hard") {
      const woundRoll = getWoundRoll(weapon.S, enemy.stats.T);
      score += (7 - woundRoll) * 6;

      // ä½è­·ç”²æ•µäººæ›´å®¹æ˜“é€ æˆå‚·å®³
      const effectiveSave = Math.max(2, enemy.stats.Sv - (weapon.AP || 0));
      score += (7 - effectiveSave) * 4;
    }

    return { enemy, score };
  });

  scored.sort((a, b) => b.score - a.score);
  return scored[0].enemy;
}

// è¼”åŠ©å‡½æ•¸
function findNearest(unit, targets) {
  if (targets.length === 0) return null;
  let nearest = targets[0];
  let minDist = Math.hypot(unit.x - targets[0].x, unit.y - targets[0].y);

  for (const t of targets) {
    const dist = Math.hypot(unit.x - t.x, unit.y - t.y);
    if (dist < minDist) {
      minDist = dist;
      nearest = t;
    }
  }
  return nearest;
}

function findNearestCover(unit) {
  const validTerrain = gameState.terrain.filter(t => TERRAIN_TYPES[t.type].coverBonus);
  if (validTerrain.length === 0) return null;

  return findNearest(unit, validTerrain.map(t => ({ x: t.x, y: t.y })));
}

function calculateThreat(unit) {
  let threat = 0;
  if (unit.weapons.ranged) {
    const w = unit.weapons.ranged;
    threat += (typeof w.A === 'number' ? w.A : 3) * w.S * (1 + Math.abs(w.AP || 0));
  }
  if (unit.weapons.melee) {
    const w = unit.weapons.melee;
    threat += (typeof w.A === 'number' ? w.A : 3) * w.S * (1 + Math.abs(w.AP || 0)) * 0.8;
  }
  return threat / 100;
}

function estimateDamage(weapon, target) {
  const attacks = typeof weapon.A === 'number' ? weapon.A : 3;
  const hitChance = (7 - weapon.skill) / 6;
  const woundRoll = getWoundRoll(weapon.S, target.stats.T);
  const woundChance = (7 - woundRoll) / 6;
  const saveRoll = Math.min(7, target.stats.Sv - (weapon.AP || 0));
  const failSaveChance = Math.min(1, (saveRoll - 1) / 6);
  const damage = typeof weapon.D === 'number' ? weapon.D : 3;

  return attacks * hitChance * woundChance * failSaveChance * damage;
}

// ========== æˆ°å ´é è¦½ ==========
function updateBattlefieldPreview() {
  selectedBattlefieldSize = document.getElementById("battlefieldSize")?.value || "strike-force";
  selectedMapScenario = document.getElementById("mapScenario")?.value || "standard";

  const sizeConfig = BATTLEFIELD_SIZES[selectedBattlefieldSize];
  const mapConfig = MAP_SCENARIOS[selectedMapScenario];

  // æ›´æ–°æè¿°
  const sizeDesc = document.getElementById("sizeDesc");
  const mapDesc = document.getElementById("mapDesc");
  if (sizeDesc) sizeDesc.textContent = sizeConfig.desc;
  if (mapDesc) mapDesc.textContent = mapConfig.desc;

  // ç¹ªè£½é è¦½
  const previewCanvas = document.getElementById("previewCanvas");
  if (!previewCanvas) return;

  const previewCtx = previewCanvas.getContext("2d");
  const scale = Math.min(300 / (sizeConfig.width * INCH), 200 / (sizeConfig.height * INCH));
  const w = sizeConfig.width * INCH * scale;
  const h = sizeConfig.height * INCH * scale;

  // èª¿æ•´ canvas å¤§å°
  previewCanvas.width = Math.max(300, w);
  previewCanvas.height = Math.max(150, h);

  // ç¹ªè£½èƒŒæ™¯
  previewCtx.fillStyle = "#1a2a1a";
  previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);

  // ç½®ä¸­åç§»
  const offsetX = (previewCanvas.width - w) / 2;
  const offsetY = (previewCanvas.height - h) / 2;

  // ç¹ªè£½æˆ°å ´å€åŸŸ
  previewCtx.fillStyle = "#243424";
  previewCtx.fillRect(offsetX, offsetY, w, h);
  previewCtx.strokeStyle = "rgba(255,255,255,0.3)";
  previewCtx.lineWidth = 1;
  previewCtx.strokeRect(offsetX, offsetY, w, h);

  // ç¹ªè£½éƒ¨ç½²å€
  const deployWidth = sizeConfig.deployZone * INCH * scale;
  previewCtx.fillStyle = "rgba(70, 130, 180, 0.3)";
  previewCtx.fillRect(offsetX, offsetY, deployWidth, h);
  previewCtx.fillStyle = "rgba(220, 80, 80, 0.3)";
  previewCtx.fillRect(offsetX + w - deployWidth, offsetY, deployWidth, h);

  // ç”Ÿæˆåœ°å½¢å’Œç›®æ¨™
  const fullW = sizeConfig.width * INCH;
  const fullH = sizeConfig.height * INCH;
  const mapData = mapConfig.generate(fullW, fullH);

  // ç¹ªè£½åœ°å½¢
  for (const t of mapData.terrain) {
    const terrainInfo = TERRAIN_TYPES[t.type];
    if (!terrainInfo) continue;

    previewCtx.fillStyle = terrainInfo.color;
    previewCtx.globalAlpha = 0.6;
    previewCtx.fillRect(
      offsetX + (t.x - t.width/2) * scale,
      offsetY + (t.y - t.height/2) * scale,
      t.width * scale,
      t.height * scale
    );
    previewCtx.globalAlpha = 1;
  }

  // ç¹ªè£½ç›®æ¨™é»
  for (const obj of mapData.objectives) {
    previewCtx.beginPath();
    previewCtx.arc(offsetX + obj.x * scale, offsetY + obj.y * scale, 6, 0, Math.PI * 2);
    previewCtx.fillStyle = "#fbbf24";
    previewCtx.fill();
    previewCtx.strokeStyle = "#fff";
    previewCtx.lineWidth = 1;
    previewCtx.stroke();
  }

  // æ¨™ç¤ºå°ºå¯¸
  previewCtx.font = "10px sans-serif";
  previewCtx.fillStyle = "#888";
  previewCtx.textAlign = "center";
  previewCtx.fillText(`${sizeConfig.width}" x ${sizeConfig.height}"`, previewCanvas.width / 2, previewCanvas.height - 5);
}

// ========== åˆå§‹åŒ– ==========
function init() {
  canvas = document.getElementById("gameCanvas");
  ctx = canvas.getContext("2d");

  updateAvailableUnits(1);
  updateAvailableUnits(2);
  updateDetachmentOptions(1);
  updateDetachmentOptions(2);
  updateBattlefieldPreview();

  window.addEventListener("resize", resizeCanvas);
}

// ========== ç¨®æ—è¦å‰‡åŠŸèƒ½ ==========
function updateDetachmentOptions(player) {
  const factionId = document.getElementById(`p${player}Faction`).value;
  const detachmentSelect = document.getElementById(`p${player}Detachment`);
  const descDiv = document.getElementById(`p${player}DetachmentDesc`);

  const factionDetachments = DETACHMENT_RULES[factionId] || {};
  detachmentSelect.innerHTML = '';

  for (const [key, det] of Object.entries(factionDetachments)) {
    const option = document.createElement('option');
    option.value = key;
    option.textContent = det.name;
    detachmentSelect.appendChild(option);
  }

  // é¸æ“‡ç¬¬ä¸€å€‹ä¸¦æ›´æ–°æè¿°
  selectDetachment(player);
}

function selectDetachment(player) {
  const factionId = document.getElementById(`p${player}Faction`).value;
  const detachmentId = document.getElementById(`p${player}Detachment`).value;
  const descDiv = document.getElementById(`p${player}DetachmentDesc`);

  const detachment = DETACHMENT_RULES[factionId]?.[detachmentId];
  if (detachment) {
    playerDetachments[player] = { factionId, detachmentId, ...detachment };
    descDiv.innerHTML = `<strong>${detachment.name}</strong><br>${detachment.description}`;
  }
}

// ç²å–ç¨®æ—è¦å‰‡æ•ˆæœ
function getDetachmentBonus(player, attacker, target, context) {
  const det = playerDetachments[player];
  if (!det || !det.apply) return {};

  try {
    return det.apply(attacker, target, context) || {};
  } catch (e) {
    return {};
  }
}

// æª¢æŸ¥æ˜¯å¦é è¿‘ç›®æ¨™æ¨™è¨˜
function isNearObjective(unit) {
  const OBJ_RANGE = 3 * INCH;
  for (const obj of gameState.objectives) {
    const dist = Math.hypot(unit.x - obj.x, unit.y - obj.y);
    if (dist <= OBJ_RANGE) return true;
  }
  return false;
}

// æª¢æŸ¥ç›®æ¨™æ˜¯å¦é è¿‘å·±æ–¹æ€ªç¸ï¼ˆç”¨æ–¼ Pantheon of Woeï¼‰
function isNearAllyMonster(target, attackerPlayer) {
  const AURA_RANGE = 6 * INCH;
  const allyMonsters = gameState.units.filter(u =>
    u.player === attackerPlayer &&
    u.alive &&
    u.keywords?.includes("Monster")
  );

  for (const monster of allyMonsters) {
    const dist = Math.hypot(target.x - monster.x, target.y - monster.y);
    if (dist <= AURA_RANGE) return true;
  }
  return false;
}

// ========== è»è¡¨é…ç½®åŠŸèƒ½ ==========
function updateAvailableUnits(player) {
  const factionId = document.getElementById(`p${player}Faction`).value;
  const faction = UNIT_DATABASE[factionId];
  const grid = document.getElementById(`p${player}UnitGrid`);

  grid.innerHTML = "";

  faction.units.forEach(unit => {
    const div = document.createElement("div");
    div.className = "unit-option";
    div.onclick = () => addUnitToRoster(player, factionId, unit);
    div.innerHTML = `
      <img src="${unit.img}" alt="${unit.name}" onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 40 40%22><rect fill=%22%23333%22 width=%2240%22 height=%2240%22/><text x=%2220%22 y=%2225%22 text-anchor=%22middle%22 fill=%22%23888%22 font-size=%2220%22>?</text></svg>'">
      <div class="unit-option-info">
        <div class="unit-option-name">${unit.name}</div>
        <div class="unit-option-cost">${unit.points} é»</div>
      </div>
    `;
    grid.appendChild(div);
  });
}

function addUnitToRoster(player, factionId, unit) {
  const roster = armyRosters[player];
  const currentPoints = roster.reduce((sum, u) => sum + u.points, 0);

  if (currentPoints + unit.points > maxPoints) {
    alert(`è¶…å‡ºé»æ•¸ä¸Šé™ï¼(${currentPoints + unit.points} > ${maxPoints})`);
    return;
  }

  roster.push({ ...unit, faction: factionId, uid: Date.now() + Math.random() });
  updateRosterDisplay(player);
  checkStartButton();
  syncArmyToFirebase(player);  // å³æ™‚åŒæ­¥è»éšŠ
}

function removeFromRoster(player, index) {
  armyRosters[player].splice(index, 1);
  updateRosterDisplay(player);
  checkStartButton();
  syncArmyToFirebase(player);  // å³æ™‚åŒæ­¥è»éšŠ
}

// ç·šä¸Šæ¨¡å¼ï¼šå³æ™‚åŒæ­¥è»éšŠåˆ° Firebase
function syncArmyToFirebase(player) {
  console.log('[syncArmy] å˜—è©¦åŒæ­¥:', { player, isOnlineMode, hasRoomRef: !!roomRef, onlinePlayerId });
  if (!isOnlineMode || !roomRef) {
    console.log('[syncArmy] è·³éï¼šéç·šä¸Šæ¨¡å¼æˆ–ç„¡æˆ¿é–“');
    return;
  }
  if (player !== onlinePlayerId) {
    console.log('[syncArmy] è·³éï¼šä¸æ˜¯è‡ªå·±çš„è»éšŠ', player, '!=', onlinePlayerId);
    return;
  }

  const roster = armyRosters[player];
  const factionSelect = document.getElementById(`p${player}Faction`);
  const detachmentSelect = document.getElementById(`p${player}Detachment`);

  console.log('[syncArmy] ä¸Šå‚³è»éšŠ:', roster.length, 'å€‹å–®ä½');

  // æ¸…ç†è³‡æ–™ï¼Œç§»é™¤æ‰€æœ‰ undefined å€¼
  const cleanRoster = roster.map(u => {
    const clean = {
      id: u.id || '',
      name: u.name || '',
      points: u.points || 0,
      stats: u.stats ? JSON.parse(JSON.stringify(u.stats)) : {},
      weapons: Array.isArray(u.weapons) ? u.weapons.map(w => JSON.parse(JSON.stringify(w || {}))) : [],
      abilities: Array.isArray(u.abilities) ? u.abilities.filter(a => a !== undefined) : [],
      keywords: Array.isArray(u.keywords) ? u.keywords.filter(k => k !== undefined) : [],
      inv: u.inv !== undefined ? u.inv : null,
      img: u.img || ''
    };
    return clean;
  });

  roomRef.child(`armies/${player}`).set({
    roster: cleanRoster,
    faction: factionSelect ? factionSelect.value : '',
    detachment: detachmentSelect ? detachmentSelect.value : ''
  }).then(() => {
    console.log('[syncArmy] ä¸Šå‚³æˆåŠŸï¼');
  }).catch(err => {
    console.error('[syncArmy] ä¸Šå‚³å¤±æ•—:', err);
  });
}

// ========== é»æ•¸ä¸Šé™è¨­å®š ==========
function updateMaxPoints(value) {
  maxPoints = parseInt(value);
  document.getElementById("maxPointsDisplay").textContent = maxPoints;
  document.getElementById("maxPointsSlider").value = maxPoints;
  // æ›´æ–°å…©é‚Šçš„é»æ•¸é¡¯ç¤º
  document.querySelectorAll(".max-pts").forEach(el => {
    el.textContent = maxPoints;
  });
}

function setPointsPreset(value) {
  updateMaxPoints(value);
  document.getElementById("maxPointsSlider").value = value;
}

// ========== æ¸…ç©ºè»éšŠ ==========
function clearRoster(player) {
  armyRosters[player] = [];
  updateRosterDisplay(player);
  checkStartButton();
  syncArmyToFirebase(player);  // å³æ™‚åŒæ­¥è»éšŠ
}

// ========== Meta è‡ªå‹•é…ç½® ==========
// å„é™£ç‡Ÿçš„ Meta é…ç½®ï¼ˆåŸºæ–¼ç«¶æŠ€å ´å¸¸è¦‹é…ç½®ï¼‰
const META_BUILDS = {
  "necrons": {
    meta: [
      { id: "nc-overlord", count: 1 },       // éœ¸ä¸»å¿…å¸¶
      { id: "nc-ctan-void", count: 1 },      // è™›ç©ºé¾æ˜Ÿç¥
      { id: "nc-warriors", count: 2 },       // æˆ°å£«Ã—10å¡«ç·š
      { id: "nc-immortals", count: 1 },      // ä¸æœ½è€…
      { id: "nc-lychguard", count: 1 },      // æš—è¡›
      { id: "nc-wraiths", count: 1 },        // å¹½éˆ
      { id: "nc-doomstalker", count: 1 }     // æœ«æ—¥è¡Œè€…
    ],
    balanced: [
      { id: "nc-overlord", count: 1 },
      { id: "nc-warriors", count: 2 },
      { id: "nc-immortals", count: 1 },
      { id: "nc-scarabs", count: 2 },
      { id: "nc-skorpekh", count: 1 }
    ]
  },
  "tyranids": {
    meta: [
      { id: "ty-hivetyrant", count: 1 },     // èŸ²å·¢æš´å›
      { id: "ty-swarmlord", count: 1 },      // èŸ²ç¾¤éœ¸ä¸»
      { id: "ty-termagants", count: 2 },     // ç™½èŸ»å¡«ç·š
      { id: "ty-hormagaunts", count: 1 },    // åˆºèŸ²è¡é‹’
      { id: "ty-zoanthropes", count: 1 },    // éˆèƒ½ç¸
      { id: "ty-carnifex", count: 1 },       // å± æ®ºç¸
      { id: "ty-exocrine", count: 1 }        // å™´å°„ç¸
    ],
    balanced: [
      { id: "ty-broodlord", count: 1 },
      { id: "ty-termagants", count: 2 },
      { id: "ty-hormagaunts", count: 2 },
      { id: "ty-warriors", count: 1 },
      { id: "ty-lictors", count: 1 }
    ]
  },
  "space-marines": {
    meta: [
      { id: "sm-captain", count: 1 },
      { id: "sm-intercessors", count: 2 },
      { id: "sm-hellblasters", count: 1 },
      { id: "sm-redemptor", count: 1 }
    ],
    balanced: [
      { id: "sm-captain", count: 1 },
      { id: "sm-tactical", count: 2 },
      { id: "sm-intercessors", count: 1 }
    ]
  },
  "chaos": {
    meta: [
      { id: "ch-lord", count: 1 },
      { id: "ch-legionaries", count: 2 },
      { id: "ch-terminators", count: 1 }
    ],
    balanced: [
      { id: "ch-lord", count: 1 },
      { id: "ch-legionaries", count: 2 }
    ]
  },
  "orks": {
    meta: [
      { id: "ork-warboss", count: 1 },
      { id: "ork-boyz", count: 3 }
    ],
    balanced: [
      { id: "ork-warboss", count: 1 },
      { id: "ork-boyz", count: 2 }
    ]
  }
};

function autoConfigMeta(player) {
  const factionId = document.getElementById(`p${player}Faction`).value;
  autoConfigArmy(player, factionId, "meta");
}

function autoConfigBalanced(player) {
  const factionId = document.getElementById(`p${player}Faction`).value;
  autoConfigArmy(player, factionId, "balanced");
}

function autoConfigArmy(player, factionId, buildType) {
  // æ¸…ç©ºç•¶å‰è»éšŠ
  armyRosters[player] = [];

  const faction = UNIT_DATABASE[factionId];
  if (!faction) return;

  const build = META_BUILDS[factionId]?.[buildType];
  if (!build) {
    // å¦‚æœæ²’æœ‰é è¨­é…ç½®ï¼Œä½¿ç”¨æ™ºèƒ½å¡«å……
    smartFillArmy(player, factionId);
    return;
  }

  let currentPoints = 0;

  // æŒ‰ç…§ Meta é…ç½®æ·»åŠ å–®ä½
  for (const config of build) {
    const unitTemplate = faction.units.find(u => u.id === config.id);
    if (!unitTemplate) continue;

    for (let i = 0; i < config.count; i++) {
      if (currentPoints + unitTemplate.points <= maxPoints) {
        armyRosters[player].push({
          ...unitTemplate,
          faction: factionId,
          uid: Date.now() + Math.random()
        });
        currentPoints += unitTemplate.points;
      }
    }
  }

  // å¦‚æœé‚„æœ‰é»æ•¸ï¼Œæ™ºèƒ½å¡«å……
  smartFillRemaining(player, factionId, currentPoints);

  updateRosterDisplay(player);
  checkStartButton();
  syncArmyToFirebase(player);  // å³æ™‚åŒæ­¥è»éšŠ
}

// æ™ºèƒ½å¡«å……å‰©é¤˜é»æ•¸
function smartFillRemaining(player, factionId, currentPoints) {
  const faction = UNIT_DATABASE[factionId];
  if (!faction) return;

  // æŒ‰é»æ•¸æ’åºï¼Œå„ªå…ˆå¡«å……ä¾¿å®œçš„å–®ä½
  const sortedUnits = [...faction.units].sort((a, b) => a.points - b.points);

  for (const unit of sortedUnits) {
    while (currentPoints + unit.points <= maxPoints) {
      armyRosters[player].push({
        ...unit,
        faction: factionId,
        uid: Date.now() + Math.random()
      });
      currentPoints += unit.points;
    }
  }
}

// æ™ºèƒ½å¡«å……æ•´å€‹è»éšŠï¼ˆæ²’æœ‰ Meta é…ç½®æ™‚ä½¿ç”¨ï¼‰
function smartFillArmy(player, factionId) {
  const faction = UNIT_DATABASE[factionId];
  if (!faction) return;

  let currentPoints = 0;
  const units = faction.units;

  // 1. å…ˆåŠ å…¥ä¸€å€‹è§’è‰²/é ˜è¢–
  const leader = units.find(u => u.keywords?.includes("Character") || u.name.includes("é ˜ä¸»") || u.name.includes("éœ¸ä¸»") || u.name.includes("é€£é•·"));
  if (leader && currentPoints + leader.points <= maxPoints) {
    armyRosters[player].push({ ...leader, faction: factionId, uid: Date.now() + Math.random() });
    currentPoints += leader.points;
  }

  // 2. åŠ å…¥åŸºç¤æ­¥å…µ
  const troops = units.filter(u => u.name.includes("Ã—10") || u.name.includes("Ã—5") || u.points <= 80);
  for (const troop of troops) {
    if (currentPoints + troop.points <= maxPoints * 0.4) { // æœ€å¤š40%èŠ±åœ¨åŸºç¤å–®ä½
      armyRosters[player].push({ ...troop, faction: factionId, uid: Date.now() + Math.random() });
      currentPoints += troop.points;
    }
  }

  // 3. åŠ å…¥ç²¾è‹±/é‡å‹å–®ä½
  const elites = units.filter(u => u.points > 80 && u.points < 200);
  for (const elite of elites) {
    if (currentPoints + elite.points <= maxPoints) {
      armyRosters[player].push({ ...elite, faction: factionId, uid: Date.now() + Math.random() });
      currentPoints += elite.points;
      if (currentPoints >= maxPoints * 0.8) break;
    }
  }

  // 4. å¡«å……å‰©é¤˜é»æ•¸
  smartFillRemaining(player, factionId, currentPoints);

  updateRosterDisplay(player);
  checkStartButton();
  syncArmyToFirebase(player);  // å³æ™‚åŒæ­¥è»éšŠ
}

function updateRosterDisplay(player) {
  const roster = armyRosters[player];
  const container = document.getElementById(`p${player}Roster`);
  const pointsDisplay = document.getElementById(`p${player}Points`);

  const totalPoints = roster.reduce((sum, u) => sum + u.points, 0);
  pointsDisplay.textContent = totalPoints;

  container.innerHTML = roster.map((unit, i) => `
    <div class="roster-item">
      <span>${unit.name} (${unit.points}é»)</span>
      <button class="remove-btn" onclick="removeFromRoster(${player}, ${i})">Ã—</button>
    </div>
  `).join("");
}

// é¡¯ç¤ºå°æ‰‹çš„è»éšŠï¼ˆç·šä¸Šæ¨¡å¼ï¼Œè¨­å®šéšæ®µï¼‰
function displayOpponentArmy(player, armyData) {
  if (!armyData || !armyData.roster) return;

  const container = document.getElementById(`p${player}Roster`);
  const pointsDisplay = document.getElementById(`p${player}Points`);
  if (!container || !pointsDisplay) return;

  const roster = armyData.roster;
  const totalPoints = roster.reduce((sum, u) => sum + (u.points || 0), 0);
  pointsDisplay.textContent = totalPoints;

  // é¡¯ç¤ºå°æ‰‹è»éšŠï¼ˆä¸å¯ç·¨è¼¯ï¼‰
  container.innerHTML = roster.map((unit) => `
    <div class="roster-item" style="opacity: 0.8;">
      <span>ğŸ‘¤ ${unit.name} (${unit.points}é»)</span>
    </div>
  `).join("");

  // æ›´æ–°é™£ç‡Ÿå’Œç¨®æ—è¦å‰‡é¡¯ç¤º
  const factionSelect = document.getElementById(`p${player}Faction`);
  if (factionSelect && armyData.faction) {
    factionSelect.value = armyData.faction;
    // è§¸ç™¼é™£ç‡Ÿè®Šæ›´ä»¥æ›´æ–°ç¨®æ—è¦å‰‡é¸é …
    if (typeof updateDetachmentOptions === 'function') {
      updateDetachmentOptions(player);
    }
  }

  const detachmentSelect = document.getElementById(`p${player}Detachment`);
  if (detachmentSelect && armyData.detachment) {
    detachmentSelect.value = armyData.detachment;
  }
}

function checkStartButton() {
  const btn = document.getElementById("startGameBtn");

  if (isOnlineMode) {
    // ç·šä¸Šæ¨¡å¼ï¼šæˆ¿ä¸»åªéœ€è¦è‡ªå·±æœ‰å–®ä½ï¼Œä¸”å°æ‰‹å·²åŠ å…¥
    if (isHost) {
      btn.disabled = !(armyRosters[1].length > 0 && currentRoomCode);
    } else {
      // åŠ å…¥è€…ä¸èƒ½é»é–‹å§‹æŒ‰éˆ•
      btn.disabled = true;
    }
  } else {
    // æœ¬åœ°æ¨¡å¼ï¼šé›™æ–¹éƒ½è¦æœ‰å–®ä½
    btn.disabled = !(armyRosters[1].length > 0 && armyRosters[2].length > 0);
  }
}

// ========== é–‹å§‹æˆ°é¬¥ ==========
function startBattle() {
  // ç·šä¸Šæ¨¡å¼ï¼šåªæœ‰æˆ¿ä¸»èƒ½é–‹å§‹
  if (isOnlineMode && !isHost) {
    alert('ç­‰å¾…æˆ¿ä¸»é–‹å§‹éŠæˆ²');
    return;
  }

  // ç·šä¸Šæ¨¡å¼ï¼šæª¢æŸ¥ä¸¦è¼‰å…¥å°æ‰‹è»éšŠ
  if (isOnlineMode && roomRef) {
    // ç¢ºä¿è‡ªå·±çš„è»éšŠå·²åŒæ­¥ï¼ˆä»¥é˜²è¬ä¸€ï¼‰
    syncArmyToFirebase(1);

    roomRef.child('status').set('playing');
    roomRef.child('gameStarted').set(true);

    // è¼‰å…¥å°æ‰‹è»éšŠè³‡æ–™ï¼ˆæ‡‰è©²å·²ç¶“å³æ™‚åŒæ­¥äº†ï¼‰
    roomRef.child('armies/2').once('value').then((snapshot) => {
      if (snapshot.exists()) {
        const enemyArmy = snapshot.val();
        loadEnemyArmy(enemyArmy, 2);
        continueStartBattle();
      } else {
        alert('å°æ‰‹å°šæœªé…ç½®è»éšŠï¼Œè«‹ç­‰å¾…å°æ‰‹å®Œæˆé…ç½®');
      }
    });
    return;
  }

  continueStartBattle();
}

function loadEnemyArmy(armyData, player) {
  if (!armyData || !armyData.roster) return;

  armyRosters[player] = armyData.roster;

  // è¨­å®šå°æ‰‹çš„é™£ç‡Ÿ
  const factionSelect = document.getElementById(`p${player}Faction`);
  if (factionSelect && armyData.faction) {
    factionSelect.value = armyData.faction;
  }
}

function continueStartBattle() {
  document.getElementById("setupScreen").style.display = "none";
  document.getElementById("gameScreen").classList.add("active");

  resizeCanvas();
  initBattlefield();

  gameState.phase = "command";
  gameState.round = 1;
  gameState.currentPlayer = 1;

  // æ›´æ–°AIç‹€æ…‹
  ai1Enabled = document.getElementById("ai1ModeToggle")?.checked ?? false;
  ai2Enabled = document.getElementById("aiModeToggle")?.checked ?? true;
  aiDifficulty = getAIDifficulty();
  enableDiceAnimation = document.getElementById("diceAnimToggle")?.checked ?? true;

  const aiIndicator = document.getElementById("aiIndicator");
  if (aiIndicator) {
    if (ai1Enabled && ai2Enabled) {
      aiIndicator.textContent = "ğŸ¤– VS ğŸ¤– è‡ªå‹•å°æˆ°";
      aiIndicator.style.display = "inline";
      aiIndicator.style.background = "linear-gradient(90deg, var(--blue), var(--red))";
    } else if (ai1Enabled || ai2Enabled) {
      aiIndicator.textContent = "ğŸ¤– AIæ¨¡å¼";
      aiIndicator.style.display = "inline";
      aiIndicator.style.background = "var(--red)";
    } else {
      aiIndicator.style.display = "none";
    }
  }

  // ç¢ºä¿ç¨®æ—è¦å‰‡å·²é¸æ“‡
  selectDetachment(1);
  selectDetachment(2);

  updatePhaseDisplay();
  log("=== æˆ°é¬¥é–‹å§‹ ===", "phase");

  // é¡¯ç¤ºé›™æ–¹ç¨®æ—è¦å‰‡
  if (playerDetachments[1]) {
    log(`ç©å®¶ä¸€ç¨®æ—è¦å‰‡: ${playerDetachments[1].name}`, "info");
  }
  if (playerDetachments[2]) {
    log(`ç©å®¶äºŒç¨®æ—è¦å‰‡: ${playerDetachments[2].name}`, "info");
  }

  // é¡¯ç¤ºç•¶å‰ç¨®æ—è¦å‰‡
  const det = playerDetachments[1];
  document.getElementById("currentDetachment").textContent = det ? det.name : "";

  if (ai1Enabled && ai2Enabled) {
    log(`ğŸ¤– VS ğŸ¤– AIè‡ªå‹•å°æˆ°æ¨¡å¼`, "phase");
    log(`é›£åº¦: ${aiDifficulty === "easy" ? "ç°¡å–®" : aiDifficulty === "normal" ? "æ™®é€š" : "å›°é›£"}`, "info");
  } else {
    log(`å›åˆ 1 - ${ai1Enabled ? "AI-1" : "ç©å®¶ä¸€"} å…ˆæ”»`, "info");
    if (ai2Enabled) log(`ğŸ¤– å°æ‰‹AIé›£åº¦: ${aiDifficulty === "easy" ? "ç°¡å–®" : aiDifficulty === "normal" ? "æ™®é€š" : "å›°é›£"}`, "info");
  }

  // é€²å…¥éƒ¨ç½²éšæ®µ
  startDeployPhase();
  render();
}

// ========== éƒ¨ç½²éšæ®µç³»çµ± ==========
function startDeployPhase() {
  gameState.phase = "deployment";
  gameState.deploy = {
    deployingPlayer: 1,
    p1Deployed: false,
    p2Deployed: false
  };

  // éš±è—æ‰€æœ‰å–®ä½ï¼ˆå°šæœªéƒ¨ç½²ï¼‰
  gameState.units.forEach(u => {
    u.deployed = false;
    u.visible = false;
  });

  updatePhaseDisplay();
  updateDeployButtons();
  updateCPDisplay();
  updateUnitLists();
  log("=== éƒ¨ç½²éšæ®µ ===", "phase");
  log("ç©å®¶ä¸€å…ˆéƒ¨ç½²å–®ä½", "info");
  log("é»æ“Šå·¦å´éƒ¨ç½²å€æ”¾ç½®å–®ä½", "info");

  // å¦‚æœæ˜¯AIç©å®¶ï¼Œè‡ªå‹•éƒ¨ç½²
  if (ai1Enabled) {
    setTimeout(() => autoDeployIfNeeded(), 500);
  }
}

function updateDeployButtons() {
  const btnStartRound = document.getElementById("btnStartRound");
  const btnSwitchDeploy = document.getElementById("btnSwitchDeploy");
  const btnNextPhase = document.getElementById("btnNextPhase");

  if (gameState.phase === "deployment") {
    btnStartRound.style.display = "inline-block";
    btnSwitchDeploy.style.display = "inline-block";
    btnNextPhase.style.display = "none";

    // åªæœ‰é›™æ–¹éƒ½è‡³å°‘éƒ¨ç½²ä¸€å€‹å–®ä½å¾Œæ‰èƒ½é–‹å§‹
    const p1HasDeployed = gameState.units.some(u => u.player === 1 && u.deployed);
    const p2HasDeployed = gameState.units.some(u => u.player === 2 && u.deployed);
    btnStartRound.disabled = !(p1HasDeployed && p2HasDeployed);
  } else {
    btnStartRound.style.display = "none";
    btnSwitchDeploy.style.display = "none";
    btnNextPhase.style.display = "inline-block";
  }
}

function switchDeploySide() {
  gameState.deploy.deployingPlayer = gameState.deploy.deployingPlayer === 1 ? 2 : 1;
  const player = gameState.deploy.deployingPlayer;
  log(`åˆ‡æ›åˆ°ç©å®¶${player === 1 ? "ä¸€" : "äºŒ"}éƒ¨ç½²`, "info");

  // å¦‚æœåˆ‡æ›åˆ°çš„æ˜¯AIç©å®¶ï¼Œè‡ªå‹•éƒ¨ç½²
  if ((player === 1 && ai1Enabled) || (player === 2 && ai2Enabled)) {
    setTimeout(() => autoDeployIfNeeded(), 500);
  }

  render();
}

function autoDeployIfNeeded() {
  const player = gameState.deploy.deployingPlayer;
  const undeployed = gameState.units.filter(u => u.player === player && !u.deployed);

  if (undeployed.length === 0) return;

  const w = gameState.canvasWidth || 600;
  const h = gameState.canvasHeight || 440;
  const deployZoneWidth = gameState.deployZone || 12 * INCH;

  // ç¢ºä¿éƒ¨ç½²å€åŸŸæœ‰æ•ˆ
  if (w <= 0 || h <= 0 || deployZoneWidth <= 0) {
    console.error("Invalid deployment zone dimensions", { w, h, deployZoneWidth });
    return;
  }

  // ä½¿ç”¨æ™ºèƒ½éƒ¨ç½²ç³»çµ±
  smartDeployUnits(undeployed, player, deployZoneWidth, w, h);

  log(`AIè‡ªå‹•éƒ¨ç½²äº†${undeployed.length}å€‹å–®ä½`, "info");

  if (player === 1) {
    gameState.deploy.p1Deployed = true;
  } else {
    gameState.deploy.p2Deployed = true;
  }

  updateDeployButtons();
  updateUnitLists();
  render();

  // å¦‚æœå…©é‚Šéƒ½æ˜¯AIä¸”éƒ½å·²éƒ¨ç½²ï¼Œè‡ªå‹•é–‹å§‹
  if (ai1Enabled && ai2Enabled && gameState.deploy.p1Deployed && gameState.deploy.p2Deployed) {
    setTimeout(() => finishDeploymentAndStart(), 1000);
  }
}

function handleDeployClick(canvasX, canvasY) {
  // ç·šä¸Šæ¨¡å¼ï¼šç›´æ¥ä½¿ç”¨è‡ªå·±çš„ç©å®¶ID
  const player = isOnlineMode ? onlinePlayerId : gameState.deploy.deployingPlayer;

  // ç·šä¸Šæ¨¡å¼ï¼šæ¯å€‹ç©å®¶éƒ¨ç½²è‡ªå·±çš„å–®ä½
  if (isOnlineMode) {
    console.log('[deploy] ç·šä¸Šæ¨¡å¼éƒ¨ç½²:', { player, onlinePlayerId });
  }

  const w = gameState.canvasWidth || canvas.getBoundingClientRect().width;
  // deployZone å·²ç¶“åŒ…å«ç¸®æ”¾
  const deployZoneWidth = gameState.deployZone || 12 * INCH;

  // æª¢æŸ¥æ˜¯å¦åœ¨æ­£ç¢ºçš„éƒ¨ç½²å€å…§
  let inDeployZone = false;
  if (player === 1 && canvasX < deployZoneWidth) {
    inDeployZone = true;
  } else if (player === 2 && canvasX > w - deployZoneWidth) {
    inDeployZone = true;
  }

  if (!inDeployZone) {
    log(`è«‹åœ¨ç©å®¶${player === 1 ? "ä¸€" : "äºŒ"}çš„éƒ¨ç½²å€å…§é»æ“Š`, "info");
    return;
  }

  // æ‰¾åˆ°ä¸‹ä¸€å€‹æœªéƒ¨ç½²çš„å–®ä½
  const undeployed = gameState.units.find(u => u.player === player && !u.deployed);
  if (!undeployed) {
    log(`ç©å®¶${player === 1 ? "ä¸€" : "äºŒ"}æ‰€æœ‰å–®ä½å·²éƒ¨ç½²`, "info");
    return;
  }

  // æª¢æŸ¥æ˜¯å¦èˆ‡å·²éƒ¨ç½²å–®ä½é‡ç–Š
  const baseSize = getUnitBaseSize(undeployed);
  const deployedUnits = gameState.units.filter(u => u.deployed);
  if (!isPositionValid(canvasX, canvasY, baseSize, deployedUnits)) {
    log(`æ­¤ä½ç½®èˆ‡å…¶ä»–å–®ä½é‡ç–Šï¼Œè«‹é¸æ“‡å…¶ä»–ä½ç½®`, "info");
    return;
  }

  // éƒ¨ç½²å–®ä½
  undeployed.x = canvasX;
  undeployed.y = canvasY;
  undeployed.deployed = true;
  undeployed.visible = true;

  log(`${undeployed.name} å·²éƒ¨ç½²`, "info");

  // ç·šä¸Šæ¨¡å¼åŒæ­¥éƒ¨ç½²
  if (isOnlineMode) {
    sendAction({ type: 'deploy', unitId: undeployed.id, x: canvasX, y: canvasY });
  }

  if (player === 1) {
    gameState.deploy.p1Deployed = true;
  } else {
    gameState.deploy.p2Deployed = true;
  }

  // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰å·±æ–¹å–®ä½éƒ½å·²éƒ¨ç½²
  const myUndeployed = gameState.units.filter(u => u.player === player && !u.deployed);
  if (myUndeployed.length === 0) {
    log(`ç©å®¶${player === 1 ? "ä¸€" : "äºŒ"}æ‰€æœ‰å–®ä½å·²å®Œæˆéƒ¨ç½²ï¼`, "phase");
    // ç·šä¸Šæ¨¡å¼åŒæ­¥éƒ¨ç½²å®Œæˆç‹€æ…‹
    if (isOnlineMode) {
      syncGameStateToFirebase();
    }
  }

  updateDeployButtons();
  updateUnitLists();
  render();
}

function finishDeploymentAndStart() {
  // ç¢ºä¿æ‰€æœ‰å–®ä½éƒ½å·²éƒ¨ç½²ï¼ˆè‡ªå‹•éƒ¨ç½²å‰©é¤˜å–®ä½ï¼‰
  const w = gameState.canvasWidth || 600;
  const h = gameState.canvasHeight || 440;
  const deployZoneWidth = gameState.deployZone || 12 * INCH;

  // åˆ†åˆ¥è™•ç†å…©é‚Šæœªéƒ¨ç½²çš„å–®ä½
  const undeployedP1 = gameState.units.filter(u => u.player === 1 && !u.deployed);
  const undeployedP2 = gameState.units.filter(u => u.player === 2 && !u.deployed);

  if (undeployedP1.length > 0) {
    smartDeployUnits(undeployedP1, 1, deployZoneWidth, w, h);
  }
  if (undeployedP2.length > 0) {
    smartDeployUnits(undeployedP2, 2, deployZoneWidth, w, h);
  }

  log("=== éƒ¨ç½²å®Œæˆï¼Œé–‹å§‹ç¬¬ä¸€å›åˆ ===", "phase");

  // é€²å…¥æŒ‡æ®éšæ®µ
  gameState.phase = "command";
  gameState.round = 1;
  gameState.currentPlayer = 1;

  updateDeployButtons();
  updateUnitLists();
  render();

  // é–‹å§‹ç¬¬ä¸€å›åˆ
  if (ai1Enabled) {
    // AIæ§åˆ¶ï¼šç›´æ¥åŸ·è¡ŒAIå›åˆ
    setTimeout(() => runAITurn(), 1000);
  } else {
    // ç©å®¶æ§åˆ¶ï¼šåŸ·è¡ŒæŒ‡æ®éšæ®µ
    startCommandPhase();
  }
}

// ========== CPç³»çµ± ==========
function updateCPDisplay() {
  const p1CP = document.getElementById("p1CPDisplay");
  const p2CP = document.getElementById("p2CPDisplay");
  const cpDisplay = document.getElementById("cpDisplay");

  if (p1CP) p1CP.textContent = gameState.cp[1];
  if (p2CP) p2CP.textContent = gameState.cp[2];
  if (cpDisplay) cpDisplay.textContent = gameState.cp[gameState.currentPlayer];

  // æ›´æ–°é‡æ“²æŒ‰éˆ•ç‹€æ…‹
  const btnReroll = document.getElementById("btnReroll");
  if (btnReroll) {
    btnReroll.disabled = gameState.cp[gameState.currentPlayer] < 1;
  }
}

function gainCPAtCommandStart() {
  // é›™æ–¹å„+1 CP
  gameState.cp[1] += 1;
  gameState.cp[2] += 1;
  log(`é›™æ–¹å„ç²å¾— 1 CP (ç©å®¶ä¸€: ${gameState.cp[1]}, ç©å®¶äºŒ: ${gameState.cp[2]})`, "info");
  updateCPDisplay();
}

function spendCP(player, amount) {
  if (gameState.cp[player] >= amount) {
    gameState.cp[player] -= amount;
    updateCPDisplay();
    return true;
  }
  return false;
}

function useCommandReroll() {
  const player = gameState.currentPlayer;
  if (gameState.cp[player] < 1) {
    log("CPä¸è¶³ï¼Œç„¡æ³•ä½¿ç”¨æŒ‡æ®é‡æ“²", "info");
    return;
  }

  // æ¨™è¨˜ä¸‹ä¸€æ¬¡æ“²éª°å¯é‡æ“²
  gameState.pendingReroll = true;
  spendCP(player, 1);
  log(`ç©å®¶${player === 1 ? "ä¸€" : "äºŒ"}èŠ±è²»1CPï¼Œä¸‹æ¬¡æ“²éª°å¯é‡æ“²`, "special");
}

// ========== æˆ°ç•¥é¢æ¿ç³»çµ± ==========
function toggleStratagemPanel() {
  const panel = document.getElementById("stratagemPanel");
  const toggle = document.getElementById("stratagemToggle");
  if (panel.style.display === "none") {
    panel.style.display = "block";
    toggle.textContent = "â–²";
    updateStratagemPanel();
  } else {
    panel.style.display = "none";
    toggle.textContent = "â–¼";
  }
}

function updateStratagemPanel() {
  const panel = document.getElementById("stratagemList");
  const player = gameState.currentPlayer;

  // ç²å–ç•¶å‰ç©å®¶çš„æµæ´¾æˆ°ç•¥
  const faction = armyRosters[player]?.[0]?.faction;
  const detachment = playerDetachments[player]?.detachmentId;

  if (!faction || !detachment || !DETACHMENT_RULES[faction]?.[detachment]) {
    panel.innerHTML = '<p style="color: var(--muted); padding: 8px;">æœªé¸æ“‡æµæ´¾æˆ–ç„¡å¯ç”¨æˆ°ç•¥</p>';
    return;
  }

  const rules = DETACHMENT_RULES[faction][detachment];
  const stratagems = rules.stratagems || [];
  const currentCP = gameState.cp[player];

  let html = `<div style="padding: 4px 8px; background: rgba(251,191,36,0.1); border-radius: 4px; margin-bottom: 6px;">
    <b style="color: var(--gold);">${rules.name}</b>
    <div style="font-size: 10px; color: var(--muted);">${rules.description}</div>
  </div>`;

  if (stratagems.length === 0) {
    html += '<p style="color: var(--muted); padding: 4px;">æ­¤æµæ´¾ç„¡ç‰¹æ®Šæˆ°ç•¥</p>';
  } else {
    stratagems.forEach((s, i) => {
      const canUse = currentCP >= s.cp;
      const btnClass = canUse ? 'background: rgba(34,197,94,0.2); border: 1px solid var(--green); cursor: pointer;' :
                                'background: rgba(100,100,100,0.2); border: 1px solid #555; cursor: not-allowed; opacity: 0.5;';
      html += `
        <div style="padding: 6px; margin: 4px 0; border-radius: 4px; ${btnClass}"
             onclick="${canUse ? `useStratagem(${i})` : ''}"
             title="${s.desc}">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <span style="font-weight: bold; color: ${canUse ? 'var(--gold)' : '#888'};">${s.name}</span>
            <span style="font-size: 10px; padding: 2px 6px; background: rgba(0,0,0,0.3); border-radius: 3px; color: ${canUse ? 'var(--green)' : '#888'};">${s.cp} CP</span>
          </div>
          <div style="font-size: 10px; color: ${canUse ? 'var(--txt)' : '#666'}; margin-top: 2px;">${s.desc}</div>
        </div>`;
    });
  }

  panel.innerHTML = html;
}

function useStratagem(index) {
  const player = gameState.currentPlayer;
  const faction = armyRosters[player]?.[0]?.faction;
  const detachment = playerDetachments[player]?.detachmentId;
  const stratagems = DETACHMENT_RULES[faction]?.[detachment]?.stratagems;

  if (!stratagems || !stratagems[index]) return;

  const stratagem = stratagems[index];

  if (!spendCP(player, stratagem.cp)) {
    log("CPä¸è¶³ï¼", "info");
    return;
  }

  playSound('click');

  // è¨˜éŒ„ä½¿ç”¨çš„æˆ°ç•¥
  gameState.activeStratagems = gameState.activeStratagems || {};
  gameState.activeStratagems[player] = stratagem;

  log(`ğŸ´ ä½¿ç”¨ã€${stratagem.name}ã€‘(${stratagem.cp}CP)`, "phase");
  log(`æ•ˆæœï¼š${stratagem.desc}`, "info");

  // é¡¯ç¤ºæµ®å‹•æ–‡å­—
  const myUnits = gameState.units.filter(u => u.player === player && u.alive);
  if (myUnits.length > 0) {
    const unit = myUnits[Math.floor(Math.random() * myUnits.length)];
    showFloatingText(unit.x, unit.y, stratagem.name, {
      color: "#fbbf24",
      fontSize: 16,
      duration: 2000
    });
  }

  updateStratagemPanel();
  updateCPDisplay();
}

// ========== æˆ°ç•¥å½ˆçª—ç³»çµ± ==========
let stratagemPopupCallback = null;

function showStratagemPopup(phase) {
  const player = gameState.currentPlayer;
  const isAI = (player === 1 && ai1Enabled) || (player === 2 && ai2Enabled);

  // AIè‡ªå‹•è™•ç†
  if (isAI) {
    return Promise.resolve();
  }

  // ç²å–ç•¶å‰ç©å®¶çš„æµæ´¾æˆ°ç•¥
  const faction = armyRosters[player]?.[0]?.faction;
  const detachment = playerDetachments[player]?.detachmentId;

  if (!faction || !detachment || !DETACHMENT_RULES[faction]?.[detachment]) {
    return Promise.resolve();
  }

  const rules = DETACHMENT_RULES[faction][detachment];
  const stratagems = rules.stratagems || [];
  const currentCP = gameState.cp[player];

  if (stratagems.length === 0 || currentCP < 1) {
    return Promise.resolve();
  }

  // éæ¿¾å¯ç”¨æˆ°ç•¥ï¼ˆæ ¹æ“šéšæ®µï¼‰
  const phaseStratagems = stratagems.filter(s => {
    if (currentCP < s.cp) return false;
    // ç°¡å–®éæ¿¾ï¼šæ‰€æœ‰æˆ°ç•¥éƒ½å¯åœ¨ä»»ä½•éšæ®µå˜—è©¦ä½¿ç”¨
    return true;
  });

  if (phaseStratagems.length === 0) {
    return Promise.resolve();
  }

  return new Promise(resolve => {
    stratagemPopupCallback = resolve;

    const popup = document.getElementById("stratagemPopup");
    const title = document.getElementById("stratagemPopupTitle");
    const cpDisplay = document.getElementById("stratagemPopupCP");
    const phaseInfo = document.getElementById("stratagemPopupPhase");
    const list = document.getElementById("stratagemPopupList");

    const phaseNames = {
      command: "æŒ‡æ®éšæ®µ",
      movement: "ç§»å‹•éšæ®µ",
      shooting: "å°„æ“Šéšæ®µ",
      charge: "è¡é‹’éšæ®µ",
      fight: "è¿‘æˆ°éšæ®µ"
    };

    title.textContent = `${rules.name} - é¸æ“‡æˆ°ç•¥`;
    cpDisplay.textContent = currentCP;
    phaseInfo.innerHTML = `<b>ç•¶å‰éšæ®µï¼š${phaseNames[phase] || phase}</b><br>
      <span style="color: var(--gold);">${rules.description}</span>`;

    let html = '';
    phaseStratagems.forEach((s, i) => {
      const originalIndex = stratagems.indexOf(s);
      html += `
        <div onclick="selectPopupStratagem(${originalIndex})"
             style="padding: 12px; background: rgba(251,191,36,0.1); border: 1px solid var(--gold); border-radius: 8px; cursor: pointer; transition: all 0.2s;"
             onmouseover="this.style.background='rgba(251,191,36,0.25)'"
             onmouseout="this.style.background='rgba(251,191,36,0.1)'">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <span style="font-weight: bold; color: var(--gold); font-size: 14px;">${s.name}</span>
            <span style="padding: 3px 10px; background: linear-gradient(135deg, var(--green), #059669); border-radius: 4px; color: white; font-weight: bold; font-size: 12px;">${s.cp} CP</span>
          </div>
          <div style="font-size: 12px; color: var(--txt); margin-top: 6px;">${s.desc}</div>
        </div>`;
    });

    list.innerHTML = html;
    popup.style.display = "flex";
    playSound('click');
  });
}

function selectPopupStratagem(index) {
  useStratagem(index);
  closeStratagemPopup();
}

function closeStratagemPopup() {
  document.getElementById("stratagemPopup").style.display = "none";
  if (stratagemPopupCallback) {
    stratagemPopupCallback();
    stratagemPopupCallback = null;
  }
}

// ========== ç¸®æ”¾æ§åˆ¶å‡½æ•¸ ==========
function zoomIn() {
  viewZoom = Math.min(MAX_ZOOM, viewZoom + ZOOM_STEP);
  updateZoomDisplay();
  render();
}

function zoomOut() {
  viewZoom = Math.max(MIN_ZOOM, viewZoom - ZOOM_STEP);
  updateZoomDisplay();
  render();
}

function zoomReset() {
  viewZoom = 1.0;
  viewOffsetX = 0;
  viewOffsetY = 0;
  updateZoomDisplay();
  render();
}

function updateZoomDisplay() {
  const display = document.getElementById("zoomDisplay");
  if (display) {
    display.textContent = Math.round(viewZoom * 100) + "%";
  }
}

// æ»‘é¼ æ»¾è¼ªç¸®æ”¾
function handleWheel(e) {
  if (!canvas) return;

  // åªåœ¨canvaså€åŸŸç¸®æ”¾
  const rect = canvas.getBoundingClientRect();
  if (e.clientX < rect.left || e.clientX > rect.right ||
      e.clientY < rect.top || e.clientY > rect.bottom) return;

  e.preventDefault();

  const oldZoom = viewZoom;

  if (e.deltaY < 0) {
    viewZoom = Math.min(MAX_ZOOM, viewZoom + ZOOM_STEP);
  } else {
    viewZoom = Math.max(MIN_ZOOM, viewZoom - ZOOM_STEP);
  }

  // ä»¥æ»‘é¼ ä½ç½®ç‚ºä¸­å¿ƒç¸®æ”¾
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  const zoomRatio = viewZoom / oldZoom;
  viewOffsetX = mouseX - (mouseX - viewOffsetX) * zoomRatio;
  viewOffsetY = mouseY - (mouseY - viewOffsetY) * zoomRatio;

  updateZoomDisplay();
  render();
}

// æ‹–æ›³å¹³ç§»è¦–åœ–
function handlePanStart(e) {
  // å³éµæˆ–ä¸­éµé–‹å§‹æ‹–æ›³
  if (e.button === 1 || e.button === 2) {
    isDragging = true;
    dragStartX = e.clientX - viewOffsetX;
    dragStartY = e.clientY - viewOffsetY;
    e.preventDefault();
  }
}

function handlePanMove(e) {
  if (isDragging) {
    viewOffsetX = e.clientX - dragStartX;
    viewOffsetY = e.clientY - dragStartY;
    render();
  }
}

function handlePanEnd() {
  isDragging = false;
}

// å°‡è¢å¹•åº§æ¨™è½‰æ›ç‚ºéŠæˆ²åº§æ¨™
function screenToGame(screenX, screenY) {
  const rect = canvas.getBoundingClientRect();
  const x = (screenX - rect.left - viewOffsetX) / viewZoom;
  const y = (screenY - rect.top - viewOffsetY) / viewZoom;
  return { x, y };
}

// å°‡éŠæˆ²åº§æ¨™è½‰æ›ç‚ºè¢å¹•åº§æ¨™
function gameToScreen(gameX, gameY) {
  const rect = canvas.getBoundingClientRect();
  const x = gameX * viewZoom + viewOffsetX + rect.left;
  const y = gameY * viewZoom + viewOffsetY + rect.top;
  return { x, y };
}

function resizeCanvas() {
  const wrap = canvas.parentElement;

  // ä½¿ç”¨å›ºå®šæˆ°å ´å°ºå¯¸ï¼ˆå¦‚æœå·²è¨­å®šï¼‰
  if (gameState.canvasWidth && gameState.canvasHeight) {
    canvas.width = gameState.canvasWidth * devicePixelRatio;
    canvas.height = gameState.canvasHeight * devicePixelRatio;

    // ç½®ä¸­é¡¯ç¤º
    canvas.style.width = gameState.canvasWidth + "px";
    canvas.style.height = gameState.canvasHeight + "px";
    canvas.style.margin = "auto";
    canvas.style.display = "block";
  } else {
    canvas.width = wrap.clientWidth * devicePixelRatio;
    canvas.height = wrap.clientHeight * devicePixelRatio;
  }

  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  render();
}

function initBattlefield() {
  // å–å¾—é¸æ“‡çš„æˆ°å ´è¨­å®š
  const sizeConfig = BATTLEFIELD_SIZES[selectedBattlefieldSize];
  const mapConfig = MAP_SCENARIOS[selectedMapScenario];

  // è¨­å®šæˆ°å ´å°ºå¯¸ï¼ˆä¿å­˜ä¾›å…¶ä»–å‡½æ•¸ä½¿ç”¨ï¼‰
  gameState.battlefieldSize = sizeConfig;

  // è¨ˆç®—å¯¦éš›åƒç´ å°ºå¯¸
  const targetW = sizeConfig.width * INCH;
  const targetH = sizeConfig.height * INCH;

  // å–å¾—å®¹å™¨å°ºå¯¸ä¸¦è¨ˆç®—ç¸®æ”¾
  const container = canvas.parentElement;
  const containerW = container.clientWidth || 800;
  const containerH = container.clientHeight || 600;

  // è¨ˆç®—é©åˆçš„ç¸®æ”¾æ¯”ä¾‹ï¼ˆä¿æŒæ¯”ä¾‹ï¼‰
  const scaleX = containerW / targetW;
  const scaleY = containerH / targetH;
  const scale = Math.min(scaleX, scaleY, 1.5); // æœ€å¤§æ”¾å¤§1.5å€

  const w = targetW * scale;
  const h = targetH * scale;

  // è¨­å®š canvas å¯¦éš›æ¸²æŸ“å°ºå¯¸ï¼ˆæ‡‰ç”¨ç¸®æ”¾ï¼‰
  gameState.canvasScale = scale;
  gameState.canvasWidth = w;
  gameState.canvasHeight = h;
  gameState.deployZone = sizeConfig.deployZone * INCH * scale; // éƒ¨ç½²å€ä¹Ÿè¦ç¸®æ”¾

  // åˆå§‹åŒ–å–®ä½
  gameState.units = [];

  // ç©å®¶ä¸€å–®ä½ (å·¦å´) - åˆå§‹æœªéƒ¨ç½²
  armyRosters[1].forEach((unit, i) => {
    gameState.units.push({
      ...unit,
      player: 1,
      id: `p1-${i}`,
      currentHP: unit.stats.W,
      maxHP: unit.stats.W,
      x: 60 + (i % 2) * 60,
      y: 80 + Math.floor(i / 2) * 80,
      alive: true,
      deployed: false,
      hasMoved: false,
      hasShot: false,
      hasCharged: false,
      hasFought: false,
      inCover: false,
      battleShocked: false
    });
  });

  // ç©å®¶äºŒå–®ä½ (å³å´) - åˆå§‹æœªéƒ¨ç½²
  armyRosters[2].forEach((unit, i) => {
    gameState.units.push({
      ...unit,
      player: 2,
      id: `p2-${i}`,
      currentHP: unit.stats.W,
      maxHP: unit.stats.W,
      x: w - 100 - (i % 2) * 60,
      y: 80 + Math.floor(i / 2) * 80,
      alive: true,
      deployed: false,
      hasMoved: false,
      hasShot: false,
      hasCharged: false,
      hasFought: false,
      inCover: false,
      battleShocked: false
    });
  });

  // ä½¿ç”¨é¸æ“‡çš„åœ°åœ–å ´æ™¯ç”Ÿæˆåœ°å½¢å’Œç›®æ¨™
  const mapData = mapConfig.generate(w, h);

  // åˆå§‹åŒ–åœ°å½¢ï¼ˆæ ¹æ“šç¸®æ”¾èª¿æ•´ï¼‰
  gameState.terrain = mapData.terrain.map(t => ({
    ...t,
    width: t.width * scale,
    height: t.height * scale
  }));

  // åˆå§‹åŒ–ç›®æ¨™é»
  gameState.objectives = mapData.objectives.map(obj => ({
    ...obj,
    control: null
  }));

  // è¨˜éŒ„ç•¶å‰åœ°åœ–è³‡è¨Š
  log(`æˆ°å ´: ${sizeConfig.name} (${sizeConfig.width}" x ${sizeConfig.height}")`, "info");
  log(`å ´æ™¯: ${mapConfig.name}`, "info");

  updateUnitLists();
  setupCanvasEvents();
}

// ========== Canvas äº‹ä»¶ ==========
function setupCanvasEvents() {
  canvas.onclick = (e) => {
    // è½‰æ›è¢å¹•åº§æ¨™åˆ°éŠæˆ²åº§æ¨™ï¼ˆè€ƒæ…®ç¸®æ”¾å’Œå¹³ç§»ï¼‰
    const rect = canvas.getBoundingClientRect();
    const screenX = e.clientX - rect.left;
    const screenY = e.clientY - rect.top;
    const x = (screenX - viewOffsetX) / viewZoom;
    const y = (screenY - viewOffsetY) / viewZoom;

    handleCanvasClick(x, y);
  };

  // æ»‘é¼ æ»¾è¼ªç¸®æ”¾
  canvas.addEventListener('wheel', handleWheel, { passive: false });

  // å³éµ/ä¸­éµæ‹–æ›³å¹³ç§»
  canvas.addEventListener('mousedown', handlePanStart);
  canvas.addEventListener('mousemove', handlePanMove);
  canvas.addEventListener('mouseup', handlePanEnd);
  canvas.addEventListener('mouseleave', handlePanEnd);

  // ç¦æ­¢å³éµé¸å–®
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());
}

async function handleCanvasClick(x, y) {
  // ç·šä¸Šæ¨¡å¼ï¼šæª¢æŸ¥æ˜¯å¦ç‚ºè‡ªå·±çš„å›åˆ
  if (isOnlineMode && !isMyTurn()) {
    log('ç­‰å¾…å°æ‰‹è¡Œå‹•...', 'info');
    return;
  }

  // éƒ¨ç½²éšæ®µè™•ç†
  if (gameState.phase === "deployment") {
    handleDeployClick(x, y);
    return;
  }

  // æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°å–®ä½
  for (const unit of gameState.units) {
    if (!unit.alive) continue;
    const dist = Math.hypot(x - unit.x, y - unit.y);
    if (dist < 25) {
      if (gameState.currentAction === "shoot" || gameState.currentAction === "fight") {
        // é¸æ“‡ç›®æ¨™
        if (unit.player !== gameState.currentPlayer) {
          gameState.targetUnit = unit;
          await executeAction();
          return;
        }
      } else {
        // é¸æ“‡å–®ä½
        selectUnit(unit);
        return;
      }
    }
  }

  // ç§»å‹•å‹•ä½œ
  if (gameState.currentAction === "move" && gameState.selectedUnit) {
    const unit = gameState.selectedUnit;
    const maxDist = unit.stats.M * INCH;
    const dist = Math.hypot(x - unit.x, y - unit.y);

    if (dist <= maxDist) {
      // æª¢æŸ¥æ˜¯å¦èˆ‡å…¶ä»–å–®ä½é‡ç–Š
      const baseSize = getUnitBaseSize(unit);
      const otherUnits = gameState.units.filter(u => u !== unit && u.alive);
      if (!isPositionValid(x, y, baseSize, otherUnits)) {
        setHint(`ç„¡æ³•ç§»å‹•åˆ°è©²ä½ç½®ï¼Œæœƒèˆ‡å…¶ä»–å–®ä½é‡ç–Š`);
        return;
      }
      unit.x = x;
      unit.y = y;
      unit.hasMoved = true;
      checkCover(unit);
      log(`${unit.name} ç§»å‹•åˆ°æ–°ä½ç½®`, "info");

      // ç·šä¸Šæ¨¡å¼åŒæ­¥
      if (isOnlineMode) {
        sendAction({ type: 'move', unitId: unit.id, x: x, y: y });
      }

      clearAction();
      updateUnitLists();
      render();
    } else {
      setHint(`ç§»å‹•è·é›¢è¶…å‡ºï¼æœ€å¤§ ${unit.stats.M}"`);
    }
  }

  // è¡é‹’å‹•ä½œ
  if (gameState.currentAction === "charge" && gameState.selectedUnit) {
    // å…ˆæ“²éª°æ±ºå®šè¡é‹’è·é›¢
    const roll1 = rollD6();
    const roll2 = rollD6();
    const chargeRoll = roll1 + roll2;
    const dist = Math.hypot(x - gameState.selectedUnit.x, y - gameState.selectedUnit.y);
    const distInches = dist / INCH;

    // è¡é‹’éª°å­å‹•ç•«
    if (enableDiceAnimation) {
      await showChargeRoll(roll1, roll2, distInches);
    }

    log(`è¡é‹’æ“²éª°: ${roll1} + ${roll2} = ${chargeRoll}"`, "info");

    if (chargeRoll >= distInches) {
      // æª¢æŸ¥æ˜¯å¦èˆ‡å…¶ä»–å–®ä½é‡ç–Šï¼ˆè¡é‹’å…è¨±æ¥è¿‘æ•µäººä½†ä¸èƒ½ç©¿éå‹è»ï¼‰
      const unit = gameState.selectedUnit;
      const baseSize = getUnitBaseSize(unit);
      const friendlyUnits = gameState.units.filter(u => u !== unit && u.alive && u.player === unit.player);
      if (!isPositionValid(x, y, baseSize, friendlyUnits)) {
        // å˜—è©¦æ‰¾åˆ°é è¿‘ç›®æ¨™ä½†ä¸é‡ç–Šçš„ä½ç½®
        let validX = x, validY = y;
        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
          for (let offset = 10; offset <= 50; offset += 10) {
            const testX = x + Math.cos(angle) * offset;
            const testY = y + Math.sin(angle) * offset;
            if (isPositionValid(testX, testY, baseSize, friendlyUnits)) {
              validX = testX;
              validY = testY;
              break;
            }
          }
          if (validX !== x || validY !== y) break;
        }
        x = validX;
        y = validY;
      }
      gameState.selectedUnit.x = x;
      gameState.selectedUnit.y = y;
      gameState.selectedUnit.hasCharged = true;
      playSound('charge'); // éŸ³æ•ˆï¼šè¡é‹’
      log(`${gameState.selectedUnit.name} è¡é‹’æˆåŠŸï¼`, "hit");
      clearAction();
      updateUnitLists();
      render();
    } else {
      playSound('miss'); // éŸ³æ•ˆï¼šå¤±æ•—
      log(`è¡é‹’å¤±æ•—ï¼éœ€è¦ ${distInches.toFixed(1)}" ä½†åªæ“²å‡º ${chargeRoll}"`, "miss");
      gameState.selectedUnit.hasCharged = true;
      clearAction();
    }
  }
}

// ========== é¸æ“‡å–®ä½ ==========
function selectUnit(unit) {
  gameState.selectedUnit = unit;
  playSound('select'); // éŸ³æ•ˆï¼šé¸æ“‡

  // æ ¹æ“šç•¶å‰éšæ®µè‡ªå‹•è¨­å®šå‹•ä½œ
  const phase = gameState.phase;
  const isMyUnit = unit.player === gameState.currentPlayer;

  if (isMyUnit) {
    if (phase === "movement" && !unit.hasMoved) {
      gameState.currentAction = "move";
      setHint(`é»æ“Šæˆ°å ´ç§»å‹• ${unit.name}ï¼ˆæœ€å¤§ ${unit.stats.M}"ï¼‰`);
    } else if (phase === "shooting" && !unit.hasShot && unit.weapons.ranged) {
      gameState.currentAction = "shoot";
      setHint(`é»æ“Šæ•µæ–¹å–®ä½ä½œç‚º ${unit.name} çš„å°„æ“Šç›®æ¨™`);
    } else if (phase === "charge" && !unit.hasCharged && !unit.battleShocked) {
      gameState.currentAction = "charge";
      setHint(`é»æ“Šæˆ°å ´ä½ç½®é€²è¡Œè¡é‹’ï¼ˆ2D6ï¼‰`);
    } else if (phase === "fight" && !unit.hasFought && unit.weapons.melee) {
      gameState.currentAction = "fight";
      setHint(`é»æ“Šç›¸é„°æ•µæ–¹å–®ä½é€²è¡Œè¿‘æˆ°`);
    } else {
      gameState.currentAction = null;
      setHint(`${unit.name} åœ¨æ­¤éšæ®µç„¡æ³•è¡Œå‹•`);
    }
  } else {
    gameState.currentAction = null;
    setHint(`é€™æ˜¯æ•µæ–¹å–®ä½`);
  }

  updateSelectedUnitInfo();
  updateActionButtons();
  highlightSelectedUnit();
  render();
}

function updateSelectedUnitInfo() {
  const unit = gameState.selectedUnit;
  if (!unit) {
    document.getElementById("selectedUnitInfo").innerHTML = `<p style="color: var(--muted); text-align: center; padding: 20px;">é»æ“Šå–®ä½æŸ¥çœ‹è©³ç´°è³‡è¨Š</p>`;
    return;
  }

  const faction = UNIT_DATABASE[unit.faction];
  let weaponsHtml = "";

  if (unit.weapons.ranged) {
    const w = unit.weapons.ranged;
    const keywords = w.keywords ? `<div style="font-size: 9px; color: #fbbf24; margin-top: 2px;">${w.keywords.join(", ")}</div>` : "";
    weaponsHtml += `
      <div class="weapon-item">
        <div class="weapon-name">ğŸ”« ${w.name}</div>
        <div class="weapon-stats">å°„ç¨‹${w.range}" A${w.A} BS${w.skill}+ S${w.S} AP${w.AP} D${w.D}</div>
        ${keywords}
      </div>
    `;
  }
  if (unit.weapons.melee) {
    const w = unit.weapons.melee;
    const keywords = w.keywords ? `<div style="font-size: 9px; color: #fbbf24; margin-top: 2px;">${w.keywords.join(", ")}</div>` : "";
    weaponsHtml += `
      <div class="weapon-item">
        <div class="weapon-name">âš”ï¸ ${w.name}</div>
        <div class="weapon-stats">A${w.A} WS${w.skill}+ S${w.S} AP${w.AP} D${w.D}</div>
        ${keywords}
      </div>
    `;
  }

  document.getElementById("selectedUnitInfo").innerHTML = `
    <div class="selected-unit-header">
      <div class="selected-avatar"><img src="${unit.img}" onerror="this.style.display='none'"></div>
      <div class="selected-details">
        <div class="selected-name">${unit.name}</div>
        <div class="selected-faction">${faction.name} - ${unit.points}é»</div>
        <div style="margin-top: 4px; font-size: 11px;">
          HP: ${unit.currentHP}/${unit.maxHP} ${unit.inCover ? "ğŸ›¡ï¸æ©è­·" : ""} ${unit.battleShocked ? "ğŸ’€æˆ°æ…„" : ""}
        </div>
      </div>
    </div>
    <div class="stats-grid">
      <div class="stat-cell"><div class="stat-label">ç§»å‹•</div><div class="stat-value">${unit.stats.M}"</div></div>
      <div class="stat-cell"><div class="stat-label">éŸŒæ€§</div><div class="stat-value">${unit.stats.T}</div></div>
      <div class="stat-cell"><div class="stat-label">è­·ç”²</div><div class="stat-value">${unit.stats.Sv}+</div></div>
      <div class="stat-cell"><div class="stat-label">å‚·å£</div><div class="stat-value">${unit.currentHP}</div></div>
      <div class="stat-cell"><div class="stat-label">é ˜å°</div><div class="stat-value">${unit.stats.Ld}+</div></div>
      <div class="stat-cell"><div class="stat-label">OC</div><div class="stat-value">${unit.stats.OC}</div></div>
    </div>
    <div class="weapons-section">
      ${weaponsHtml}
    </div>
    ${unit.abilities?.length ? `<div style="margin-top: 8px; font-size: 10px; color: var(--muted);">
      <b>ç‰¹æ®Šèƒ½åŠ›:</b> ${unit.abilities.join(", ")}
    </div>` : ""}
  `;
}

// ========== å‹•ä½œç³»çµ± ==========
function setAction(action) {
  if (!gameState.selectedUnit) {
    setHint("è«‹å…ˆé¸æ“‡ä¸€å€‹å–®ä½");
    return;
  }

  const unit = gameState.selectedUnit;

  if (action === "move" && unit.hasMoved) {
    setHint("è©²å–®ä½å·²ç§»å‹•é");
    return;
  }
  if (action === "shoot" && unit.hasShot) {
    setHint("è©²å–®ä½å·²å°„æ“Šé");
    return;
  }
  if (action === "charge" && unit.hasCharged) {
    setHint("è©²å–®ä½å·²è¡é‹’é");
    return;
  }
  // å®˜æ–¹è¦å‰‡ï¼šæˆ°æ…„ä¸­çš„å–®ä½ä¸èƒ½è¡é‹’
  if (action === "charge" && unit.battleShocked) {
    setHint("æˆ°æ…„ä¸­çš„å–®ä½ç„¡æ³•è¡é‹’ï¼");
    return;
  }
  if (action === "fight" && unit.hasFought) {
    setHint("è©²å–®ä½å·²è¿‘æˆ°é");
    return;
  }

  gameState.currentAction = action;

  const hints = {
    move: `é»æ“Šæˆ°å ´ç§»å‹• ${unit.name}ï¼ˆæœ€å¤§ ${unit.stats.M}"ï¼‰`,
    shoot: `é»æ“Šæ•µæ–¹å–®ä½ä½œç‚º ${unit.name} çš„å°„æ“Šç›®æ¨™`,
    charge: `é»æ“Šæˆ°å ´ä½ç½®é€²è¡Œè¡é‹’ï¼ˆ2D6ï¼‰`,
    fight: `é»æ“Šç›¸é„°æ•µæ–¹å–®ä½é€²è¡Œè¿‘æˆ°`
  };

  setHint(hints[action]);
  render();
}

function clearAction() {
  gameState.currentAction = null;
  gameState.targetUnit = null;
  setHint("é¸æ“‡ä¸€å€‹å–®ä½é–‹å§‹è¡Œå‹•");
}

function setHint(text) {
  document.getElementById("actionHint").textContent = text;
}

async function executeAction() {
  const attacker = gameState.selectedUnit;
  const target = gameState.targetUnit;

  if (!attacker || !target) return;

  if (gameState.currentAction === "shoot") {
    if (!attacker.weapons.ranged) {
      log(`${attacker.name} æ²’æœ‰é ç¨‹æ­¦å™¨ï¼`, "miss");
      clearAction();
      return;
    }

    const weapon = attacker.weapons.ranged;

    // æª¢æŸ¥ä¸€æ¬¡æ€§æ­¦å™¨æ˜¯å¦å·²ä½¿ç”¨
    if (weapon.oneUse) {
      if (!attacker.usedOneUseWeapons) attacker.usedOneUseWeapons = {};
      if (attacker.usedOneUseWeapons[weapon.name]) {
        log(`${weapon.name} å·²ä½¿ç”¨éï¼ˆä¸€æ¬¡æ€§æ­¦å™¨ï¼‰ï¼`, "miss");
        clearAction();
        return;
      }
    }

    const distance = Math.hypot(attacker.x - target.x, attacker.y - target.y) / INCH;

    if (distance > weapon.range) {
      log(`ç›®æ¨™è¶…å‡ºå°„ç¨‹ï¼(${distance.toFixed(1)}" > ${weapon.range}")`, "miss");
      clearAction();
      return;
    }

    await performAttack(attacker, target, weapon, "ranged");
    resolveHazardous(attacker, weapon);
    attacker.hasShot = true;

    // æ¨™è¨˜ä¸€æ¬¡æ€§æ­¦å™¨å·²ä½¿ç”¨
    if (weapon.oneUse) {
      if (!attacker.usedOneUseWeapons) attacker.usedOneUseWeapons = {};
      attacker.usedOneUseWeapons[weapon.name] = true;
      log(`âš¡ ${weapon.name} å·²ä½¿ç”¨ï¼ˆä¸€æ¬¡æ€§æ­¦å™¨ï¼‰`, "info");
    }
  }
  else if (gameState.currentAction === "fight") {
    if (!attacker.weapons.melee) {
      log(`${attacker.name} æ²’æœ‰è¿‘æˆ°æ­¦å™¨ï¼`, "miss");
      clearAction();
      return;
    }

    const distance = Math.hypot(attacker.x - target.x, attacker.y - target.y) / INCH;
    if (distance > 1.5) {
      log(`ç›®æ¨™è¶…å‡ºè¿‘æˆ°ç¯„åœï¼`, "miss");
      clearAction();
      return;
    }

    await performAttack(attacker, target, attacker.weapons.melee, "melee");
    attacker.hasFought = true;
  }

  clearAction();
  updateUnitLists();
  render();
}

// ========== å–®ä½èƒ½åŠ›ç³»çµ± ==========

// ç²å–ç›®æ¨™çš„é˜²ç¦¦èƒ½åŠ›ï¼ˆFNPã€å‚·å®³æ¸›å…ç­‰ï¼‰
function getTargetDefenseAbilities(unit) {
  const defense = {
    fnp: 0,             // ç„¡æ‡¼æ­»äº¡ï¼ˆ0è¡¨ç¤ºæ²’æœ‰ï¼‰
    damageReduction: 0, // å‚·å®³æ¸›å…
    bodyguard: false,   // è­·è¡›å”è­°
    bodyguardRange: 3   // è­·è¡›ç¯„åœï¼ˆè‹±å‹ï¼‰
  };

  if (!unit || !unit.abilities) return defense;

  for (const ability of unit.abilities) {
    const abilityLower = ability.toLowerCase();

    // C'tan ä¸æ»…é‡‘å±¬ï¼šå‚·å®³æ¸›å…1
    if (ability.includes("ä¸æ»…é‡‘å±¬") || ability.includes("Living Metal") ||
        ability.includes("å‚·å®³-1")) {
      // C'tan ç‰¹æ®Šè¦å‰‡ï¼šæ¸›å°‘æ‰€æœ‰å—åˆ°çš„å‚·å®³1ï¼ˆæœ€ä½1ï¼‰
      if (unit.keywords && unit.keywords.includes("C'tan")) {
        defense.damageReduction = Math.max(defense.damageReduction, 1);
      }
    }

    // ç„¡æ‡¼æ­»äº¡ (Feel No Pain) 5+ / æ™‚é–“æ“æ§
    if (ability.includes("ç„¡æ‡¼æ­»äº¡") || ability.includes("ä¸æ‡¼æ­»äº¡") ||
        ability.includes("FNP") || ability.includes("Feel No Pain") ||
        ability.includes("æ™‚é–“æ“æ§") || ability.includes("ç„¡è¦–å‚·å®³")) {
      const match = ability.match(/(\d)\+/);
      if (match) {
        defense.fnp = Math.max(defense.fnp, parseInt(match[1]));
      } else {
        defense.fnp = Math.max(defense.fnp, 5); // é è¨­5+
      }
    }

    // èŸ²æ—ç—›è‹¦æŠµæŠ— (é€šå¸¸æ˜¯6+)
    if (ability.includes("ç—›è‹¦æŠµæŠ—") || ability.includes("Pain Token") ||
        ability.includes("ç”ŸåŒ–é©æ‡‰")) {
      defense.fnp = Math.max(defense.fnp, 6);
    }

    // è­·è¡›å”è­° / è­·è¡›å–®ä½
    if (ability.includes("è­·è¡›å”è­°") || ability.includes("Bodyguard") ||
        ability.includes("è­·è¡›") || ability.includes("ä¿è­·")) {
      defense.bodyguard = true;
    }

    // å …éŸŒä¸æ‹”ï¼ˆéƒ¨åˆ†å–®ä½æœ‰æ›´å¥½çš„FNPï¼‰
    if (ability.includes("å …éŸŒ") && ability.includes("4+")) {
      defense.fnp = Math.max(defense.fnp, 4);
    }
  }

  return defense;
}

// è§£æä¸¦æ‡‰ç”¨å–®ä½ç‰¹æ®Šèƒ½åŠ›
function getUnitAbilityBonus(unit, target, context) {
  const bonus = {
    attackBonus: 0,
    damageBonus: 0,
    hitBonus: 0,
    woundBonus: 0,
    apBonus: 0,
    saveBonus: 0,
    invSave: null,
    rerollHits: false,
    rerollWounds: false,
    healAfterKill: 0,
    healOnDamage: false,
    mortalWoundsOnCharge: 0,
    triggeredAbilities: []  // è¨˜éŒ„è§¸ç™¼çš„èƒ½åŠ›åç¨±
  };

  if (!unit.abilities) return bonus;

  const abilities = unit.abilities;
  const hasCharged = unit.hasCharged || context.charged;
  const isMelee = context.mode === "melee";
  const isRanged = context.mode === "ranged";

  for (const ability of abilities) {
    const abilityLower = ability.toLowerCase();

    // ===== è¡é‹’ç›¸é—œ =====
    // ä¸å¯é˜»æ“‹: è¡é‹’æ™‚+1å‚·å®³
    if ((ability.includes("ä¸å¯é˜»æ“‹") || ability.includes("Unstoppable")) && hasCharged && isMelee) {
      bonus.damageBonus += 1;
      bonus.triggeredAbilities.push("ä¸å¯é˜»æ“‹ +1å‚·å®³");
    }

    // è¡é‹’æ™‚+1æ”»æ“Š
    if ((ability.includes("è¡é‹’") && ability.includes("+1æ”»æ“Š")) ||
        (ability.includes("charge") && ability.includes("+1 attack"))) {
      if (hasCharged && isMelee) {
        bonus.attackBonus += 1;
        bonus.triggeredAbilities.push("è¡é‹’ +1æ”»æ“Š");
      }
    }

    // ===== å‘½ä¸­/è‡´å‚·åŠ æˆ =====
    // é ˜è¢–: 6"å…§å‹è»é‡æ“²å‘½ä¸­1
    if (ability.includes("é ˜è¢–") && ability.includes("é‡æ“²å‘½ä¸­")) {
      // é€™å€‹èƒ½åŠ›å½±éŸ¿é™„è¿‘å‹è»ï¼Œåœ¨é€™è£¡æ¨™è¨˜
      bonus.rerollHits = true;
      bonus.triggeredAbilities.push("é ˜è¢–å…‰ç’°");
    }

    // ç›®æ¨™é–å®š: +æ”»æ“Š
    if (ability.includes("ç›®æ¨™é–å®š") || ability.includes("Target Lock")) {
      const match = ability.match(/\+(\d+)/);
      if (match) {
        bonus.attackBonus += parseInt(match[1]);
        bonus.triggeredAbilities.push(`ç›®æ¨™é–å®š +${match[1]}æ”»æ“Š`);
      }
    }

    // ===== é˜²ç¦¦èƒ½åŠ› =====
    // éˆèƒ½è­·ç›¾ / ç„¡æ•µè±å…
    if (ability.includes("éˆèƒ½è­·ç›¾") || ability.includes("Psychic Shield")) {
      bonus.invSave = bonus.invSave ? Math.min(bonus.invSave, 4) : 4;
      bonus.triggeredAbilities.push("éˆèƒ½è­·ç›¾ 4+ç„¡æ•µ");
    }

    // æ¯’éœ§: 6"å…§å‹è»-1è¢«å‘½ä¸­ (é˜²ç¦¦æ–¹)
    if (context.isDefending && ability.includes("æ¯’éœ§")) {
      bonus.hitPenalty = 1;
      bonus.triggeredAbilities.push("æ¯’éœ§ -1è¢«å‘½ä¸­");
    }

    // ===== æ¢å¾©èƒ½åŠ› =====
    // åå™¬æ¢å¾©: é€ æˆå‚·å®³æ¢å¾©HP
    if (ability.includes("åå™¬æ¢å¾©") || ability.includes("å™¬æ®ºæ¢å¾©") ||
        ability.includes("éˆå™¬") || ability.includes("æ¢å¾©HP")) {
      bonus.healOnDamage = true;
      bonus.triggeredAbilities.push("é€ å‚·å›è¡€");
    }

    // å†ç”Ÿ / æ´»é‡‘å±¬
    if (ability.includes("å†ç”Ÿ") || ability.includes("æ´»é‡‘å±¬") || ability.includes("Living Metal")) {
      bonus.regenerate = true;
      bonus.triggeredAbilities.push("å†ç”Ÿ");
    }

    // ===== ç‰¹æ®Šæ”»æ“Š =====
    // ææ€–çªç¾: æ·±å…¥æ‰“æ“Šæ™‚é€ æˆè‡´å‘½å‚·å®³
    if (ability.includes("ææ€–çªç¾") && context.deepStrike) {
      bonus.mortalWoundsOnArrival = "D3+3";
      bonus.triggeredAbilities.push("ææ€–çªç¾");
    }

    // Hazardous æ­¦å™¨ (é€™å€‹é€šå¸¸åœ¨æ­¦å™¨é—œéµå­—è™•ç†)
    if (ability.includes("Hazardous") || ability.includes("éè¼‰")) {
      bonus.hazardous = true;
    }

    // ===== é›™å°„ / å¿«é€Ÿå°„æ“Š =====
    if (ability.includes("å¿«é€Ÿå°„æ“Š") || ability.includes("Rapid Fire")) {
      if (isRanged && context.halfRange) {
        bonus.attackBonus += bonus.attackBonus || 1;
        bonus.triggeredAbilities.push("å¿«é€Ÿå°„æ“Š");
      }
    }

    // ===== Synapse çªè§¸ =====
    if (ability.includes("Synapse") || ability.includes("çªè§¸")) {
      bonus.hasSynapse = true;
    }

    // ===== é‡ç«åŠ›æ¨¡å¼ =====
    if (ability.includes("é‡ç«åŠ›") && !unit.hasMoved && isRanged) {
      bonus.hitBonus += 1;
      bonus.triggeredAbilities.push("é‡ç«åŠ›æ¨¡å¼ +1å‘½ä¸­");
    }

    // ===== ææ‡¼å°–å˜¯ =====
    if (ability.includes("ææ‡¼å°–å˜¯") || ability.includes("Terror")) {
      bonus.causesFear = true;
      bonus.triggeredAbilities.push("ææ‡¼");
    }

    // ===== è‡´å‘½å‘½ä¸­ (Lethal Hits) =====
    if (ability.includes("è‡´å‘½å‘½ä¸­") || ability.includes("Lethal Hits") ||
        ability.includes("Lethal Hit")) {
      bonus.lethalHits = true;
      bonus.triggeredAbilities.push("è‡´å‘½å‘½ä¸­");
    }

    // ===== æŒçºŒå‘½ä¸­ (Sustained Hits) =====
    if (ability.includes("æŒçºŒå‘½ä¸­") || ability.includes("Sustained Hits")) {
      const match = ability.match(/(\d+)/);
      bonus.sustainedHits = match ? parseInt(match[1]) : 1;
      bonus.triggeredAbilities.push(`æŒçºŒå‘½ä¸­ ${bonus.sustainedHits}`);
    }

    // ===== å¸å–ç”Ÿå‘½ (è¿‘æˆ°å¾Œè‡´å‘½å‚·) =====
    if (ability.includes("å¸å–ç”Ÿå‘½") || ability.includes("éˆèƒ½å¸å–") ||
        ability.includes("è¿‘æˆ°å¾Œ") && ability.includes("è‡´å‘½å‚·")) {
      bonus.lifeDrain = true;
      const dmgMatch = ability.match(/D(\d+)/);
      bonus.lifeDrainDice = dmgMatch ? parseInt(dmgMatch[1]) : 3;
      bonus.triggeredAbilities.push("å¸å–ç”Ÿå‘½");
    }

    // ===== ç‹™æ“Š (å¯ä»¥é‡å°è§’è‰²) =====
    if (ability.includes("ç‹™æ“Š") || ability.includes("Sniper") ||
        ability.includes("Precision")) {
      bonus.precision = true;
      bonus.triggeredAbilities.push("ç‹™æ“Š");
    }

    // ===== æ¯€æ»…ç‹‚ç†± (Destroyer) =====
    if (ability.includes("æ¯€æ»…ç‹‚ç†±") || ability.includes("Destroyer Cult")) {
      bonus.rerollWounds = true;
      bonus.triggeredAbilities.push("æ¯€æ»…ç‹‚ç†±");
    }
  }

  return bonus;
}

// æ‡‰ç”¨èƒ½åŠ›å¾Œæ•ˆæœï¼ˆå¦‚å›è¡€ï¼‰
function applyPostCombatAbilities(attacker, target, damageDealt, context) {
  const abilityBonus = getUnitAbilityBonus(attacker, target, context);

  // åå™¬æ¢å¾©ï¼šé€ æˆå‚·å®³æ™‚æ¢å¾©HP
  if (abilityBonus.healOnDamage && damageDealt > 0) {
    const healAmount = Math.min(damageDealt, 3); // æœ€å¤šå›3é»
    const oldHP = attacker.currentHP;
    attacker.currentHP = Math.min(attacker.maxHP, attacker.currentHP + healAmount);
    const actualHeal = attacker.currentHP - oldHP;
    if (actualHeal > 0) {
      playSound('heal'); // éŸ³æ•ˆï¼šæ²»ç™‚
      log(`ğŸ’š ${attacker.name} åå™¬æ¢å¾© +${actualHeal} HPï¼`, "heal");
      showFloatingText(attacker.x, attacker.y, `+${actualHeal} HP`, {
        color: "#22cc66",
        fontSize: 16,
        duration: 1200
      });
    }
  }

  // å¸å–ç”Ÿå‘½ï¼šè¿‘æˆ°å¾Œå°ç›®æ¨™é€ æˆé¡å¤–è‡´å‘½å‚·
  if (abilityBonus.lifeDrain && context.mode === "melee" && target.alive) {
    const dice = abilityBonus.lifeDrainDice || 3;
    let mortalWounds = 0;
    for (let i = 0; i < dice; i++) {
      mortalWounds += (rollD6() >= 4) ? 1 : 0; // D3 å¹³å‡è‡´å‘½å‚·
    }
    if (mortalWounds > 0) {
      log(`ğŸ’€ ${attacker.name} å¸å–ç”Ÿå‘½é€ æˆ ${mortalWounds} è‡´å‘½å‚·ï¼`, "damage");
      showFloatingText(target.x, target.y, `-${mortalWounds} è‡´å‘½å‚·`, {
        color: "#ff00ff",
        fontSize: 16,
        duration: 1500
      });
      target.currentHP -= mortalWounds;
      if (target.currentHP <= 0) {
        target.currentHP = 0;
        target.alive = false;
        log(`ğŸ’€ ${target.name} è¢«å¸å–ç”Ÿå‘½æ¶ˆæ»…ï¼`, "damage");
      }
    }
  }
}

// å›åˆé–‹å§‹æ™‚çš„å†ç”Ÿèƒ½åŠ›
function applyRegenerationAbilities() {
  const currentPlayer = gameState.currentPlayer;
  const myUnits = gameState.units.filter(u => u.player === currentPlayer && u.alive);

  for (const unit of myUnits) {
    if (!unit.abilities) continue;

    // æ´»é‡‘å±¬ / å†ç”Ÿï¼šå›åˆé–‹å§‹æ¢å¾©1å‚·å£
    const hasRegen = unit.abilities.some(a =>
      a.includes("å†ç”Ÿ") || a.includes("æ´»é‡‘å±¬") || a.includes("Living Metal")
    );

    if (hasRegen && unit.currentHP < unit.maxHP) {
      unit.currentHP = Math.min(unit.maxHP, unit.currentHP + 1);
      playSound('heal'); // éŸ³æ•ˆï¼šæ²»ç™‚
      log(`ğŸ”§ ${unit.name} æ´»é‡‘å±¬å†ç”Ÿ +1 HP`, "heal");
      showFloatingText(unit.x, unit.y, "+1 å†ç”Ÿ", {
        color: "#44aaff",
        fontSize: 14,
        duration: 1000
      });
    }
  }
}

// ========== æˆ°é¬¥ç³»çµ± ==========
// æ˜¯å¦å•Ÿç”¨éª°å­å‹•ç•«ï¼ˆå¯åœ¨é«˜é€ŸAIæˆ°é¬¥æ™‚é—œé–‰ï¼‰
let enableDiceAnimation = true;

async function performAttack(attacker, target, weapon, mode) {
  log(`ã€${mode === "ranged" ? "å°„æ“Š" : "è¿‘æˆ°"}ã€‘${attacker.name} â†’ ${target.name}`, "phase");
  log(`ä½¿ç”¨ ${weapon.name}`, "info");

  // é¡¯ç¤ºæ”»æ“Šå‹•ç•« + éŸ³æ•ˆ
  if (mode === "ranged") {
    playSound('shoot', { weapon: weapon.name.includes('é›·å°„') || weapon.name.includes('å…‰æŸ') ? 'laser' : 'rifle' });
    showAttackLine(attacker.x, attacker.y, target.x, target.y, {
      color: "#ffaa00",
      type: "beam",
      duration: 500
    });
  } else {
    playSound('melee');
    showAttackLine(attacker.x, attacker.y, target.x, target.y, {
      color: "#ff4444",
      type: "melee",
      duration: 400
    });
  }

  // é¡¯ç¤ºæ­¦å™¨åç¨±
  showFloatingText(attacker.x, attacker.y, weapon.name, {
    color: mode === "ranged" ? "#ffaa00" : "#ff6666",
    fontSize: 14,
    duration: 1000
  });

  await new Promise(r => setTimeout(r, 200)); // ç­‰å¾…å‹•ç•«é–‹å§‹

  // ç²å–ç¨®æ—è¦å‰‡åŠ æˆ
  const context = {
    phase: mode === "ranged" ? "shooting" : "fight",
    mode: mode,
    nearObjective: isNearObjective(target),
    nearAllyMonster: isNearAllyMonster(target, attacker.player),
    charged: attacker.hasCharged
  };
  const detBonus = getDetachmentBonus(attacker.player, attacker, target, context);

  // ç²å–å–®ä½èƒ½åŠ›åŠ æˆ
  const abilityBonus = getUnitAbilityBonus(attacker, target, context);

  // é¡¯ç¤ºç¨®æ—è¦å‰‡æ•ˆæœï¼ˆå¸¶è¦–è¦ºç‰¹æ•ˆï¼‰
  const bonusTexts = [];
  if (detBonus.hitBonus) bonusTexts.push(`å‘½ä¸­+${detBonus.hitBonus}`);
  if (detBonus.strengthBonus) bonusTexts.push(`åŠ›é‡+${detBonus.strengthBonus}`);
  if (detBonus.woundBonus) bonusTexts.push(`è‡´å‚·+${detBonus.woundBonus}`);
  if (detBonus.apBonus) bonusTexts.push(`AP+${detBonus.apBonus}`);
  if (detBonus.rerollHitOnes) bonusTexts.push(`é‡æ“²å‘½ä¸­1`);
  if (detBonus.rerollWoundOnes) bonusTexts.push(`é‡æ“²è‡´å‚·1`);
  if (detBonus.attackBonus) bonusTexts.push(`æ”»æ“Š+${detBonus.attackBonus}`);

  if (bonusTexts.length > 0) {
    // é¡¯ç¤ºç¨®æ—è¦å‰‡æ¿€æ´»æ–‡å­—
    showFloatingText(attacker.x, attacker.y - 20, "âš”ï¸ " + bonusTexts[0], {
      color: "#aa66ff",
      fontSize: 12,
      duration: 1500
    });
    bonusTexts.forEach(txt => log(`[ç¨®æ—è¦å‰‡] ${txt}`, "info"));
  }

  // é¡¯ç¤ºå–®ä½èƒ½åŠ›è§¸ç™¼æ•ˆæœ
  if (abilityBonus.triggeredAbilities.length > 0) {
    abilityBonus.triggeredAbilities.forEach((abil, i) => {
      setTimeout(() => {
        showFloatingText(attacker.x, attacker.y - 40 - i * 20, "âœ¨ " + abil, {
          color: "#66ffaa",
          fontSize: 13,
          duration: 1800
        });
      }, i * 200);
      log(`[å–®ä½èƒ½åŠ›] ${abil}`, "info");
    });
  }

  // è¨ˆç®—æ”»æ“Šæ¬¡æ•¸ï¼ˆåŠ ä¸Šæ”»æ“ŠåŠ æˆï¼‰
  let attacks = weapon.A;
  if (typeof attacks === "string") {
    if (attacks.includes("D6")) {
      const base = attacks.replace("D6", "").replace("+", "") || "0";
      attacks = rollD6() + parseInt(base);
    }
  }
  attacks += detBonus.attackBonus || 0;
  attacks += abilityBonus.attackBonus || 0;  // å–®ä½èƒ½åŠ›æ”»æ“ŠåŠ æˆ

  log(`æ”»æ“Šæ¬¡æ•¸: ${attacks}`, "info");

  // å‘½ä¸­æ“²éª°ï¼ˆåŒ…å«å‘½ä¸­åŠ æˆå’Œé‡æ“²ï¼‰
  const hitNeed = Math.max(2, weapon.skill - (detBonus.hitBonus || 0) - (abilityBonus.hitBonus || 0));
  let hitRolls = [];
  for (let i = 0; i < attacks; i++) hitRolls.push(rollD6());

  // é‡æ“²å‘½ä¸­1ï¼ˆç¨®æ—è¦å‰‡æˆ–å–®ä½èƒ½åŠ›ï¼‰
  if (detBonus.rerollHitOnes || abilityBonus.rerollHits) {
    hitRolls = hitRolls.map(r => r === 1 ? rollD6() : r);
  }

  // å‘½ä¸­éª°å­å‹•ç•«
  if (enableDiceAnimation && hitRolls.length <= 12) {
    await showDiceRoll(`å‘½ä¸­æ“²éª° (${attacker.name})`, hitRolls, hitNeed, { duration: 600 });
  }

  log(`å‘½ä¸­æ“²éª°: ${hitRolls.join(", ")} (éœ€è¦ ${hitNeed}+)`, "info");

  // è¨ˆç®—å‘½ä¸­æ•¸ï¼ˆåŒ…å«æŒçºŒå‘½ä¸­å’Œè‡´å‘½å‘½ä¸­ï¼‰
  let hits = 0;
  let lethalWounds = 0;  // è‡´å‘½å‘½ä¸­ç›´æ¥è®Šæˆå‚·
  let sustainedExtra = 0; // æŒçºŒå‘½ä¸­é¡å¤–å‘½ä¸­æ•¸

  for (const roll of hitRolls) {
    if (roll >= hitNeed) {
      hits++;

      // è‡´å‘½å‘½ä¸­ï¼š6å‘½ä¸­ç›´æ¥è‡´å‚·ï¼ˆè·³éè‡´å‚·éª°ï¼‰
      if (roll === 6 && abilityBonus.lethalHits) {
        lethalWounds++;
        log(`[è‡´å‘½å‘½ä¸­] 6å‘½ä¸­ â†’ è‡ªå‹•è‡´å‚·ï¼`, "info");
      }

      // æŒçºŒå‘½ä¸­ï¼š6å‘½ä¸­é¡å¤–+Nå‘½ä¸­
      if (roll === 6 && abilityBonus.sustainedHits) {
        sustainedExtra += abilityBonus.sustainedHits;
        log(`[æŒçºŒå‘½ä¸­] +${abilityBonus.sustainedHits} é¡å¤–å‘½ä¸­ï¼`, "info");
      }
    }
  }

  hits += sustainedExtra;
  log(`å‘½ä¸­: ${hits}/${attacks}${sustainedExtra > 0 ? ` (+${sustainedExtra}æŒçºŒå‘½ä¸­)` : ''}`, hits > 0 ? "hit" : "miss");

  if (hits === 0) {
    // é¡¯ç¤ºæœªå‘½ä¸­
    showFloatingText(target.x, target.y, "MISS", {
      color: "#888888",
      fontSize: 18,
      duration: 1000
    });
    return;
  }

  // è‡´å‚·æ“²éª°ï¼ˆåŒ…å«åŠ›é‡åŠ æˆå’Œè‡´å‚·åŠ æˆï¼‰
  const effectiveS = weapon.S + (detBonus.strengthBonus || 0);
  const woundNeed = Math.max(2, getWoundRoll(effectiveS, target.stats.T) - (detBonus.woundBonus || 0));
  const woundExplanation = `S${effectiveS} vs T${target.stats.T} â†’ ${woundNeed}+`;

  // è‡´å‘½å‘½ä¸­çš„è‡ªå‹•å‚·ä¸éœ€è¦æ“²éª°
  const hitsNeedingWoundRoll = abilityBonus.lethalHits ? (hits - lethalWounds) : hits;

  let woundRolls = [];
  for (let i = 0; i < hitsNeedingWoundRoll; i++) woundRolls.push(rollD6());

  // é‡æ“²è‡´å‚·1ï¼ˆç¨®æ—è¦å‰‡æˆ–å–®ä½èƒ½åŠ›ï¼‰
  if (detBonus.rerollWoundOnes || abilityBonus.rerollWounds) {
    woundRolls = woundRolls.map(r => r === 1 ? rollD6() : r);
  }

  // è‡´å‚·éª°å­å‹•ç•«
  if (enableDiceAnimation && woundRolls.length <= 12) {
    await showDiceRoll(`è‡´å‚·æ“²éª° (${woundExplanation})`, woundRolls, woundNeed, { duration: 600 });
  }

  log(`è‡´å‚·æ“²éª°: ${woundRolls.join(", ")} (${woundExplanation})`, "info");

  // è‡´å‚·æ•¸ = æ“²éª°æˆåŠŸ + è‡´å‘½å‘½ä¸­è‡ªå‹•å‚·
  const woundRollSuccesses = woundRolls.filter(r => r >= woundNeed).length;
  const wounds = woundRollSuccesses + lethalWounds;
  if (lethalWounds > 0) {
    log(`è‡´å‚·: ${wounds}/${hits} (å« ${lethalWounds} è‡´å‘½å‘½ä¸­)`, wounds > 0 ? "hit" : "miss");
  } else {
    log(`è‡´å‚·: ${wounds}/${hits}`, wounds > 0 ? "hit" : "miss");
  }

  if (wounds === 0) {
    showFloatingText(target.x, target.y, "æŠµæ“‹!", {
      color: "#4488ff",
      fontSize: 16,
      duration: 1000
    });
    return;
  }

  // è±å…æ“²éª° (å®˜æ–¹10ç‰ˆè¦å‰‡)
  // APåŠ æˆï¼ˆå¦‚ Pantheon of Woeï¼‰
  const effectiveAP = (weapon.AP || 0) + (detBonus.apBonus || 0);

  // æ©è­·åŠ æˆ: +1è­·ç”²è±å…ï¼Œä½†è­·ç”²3+æˆ–æ›´å¥½é¢å°AP0æ™‚ä¸é©ç”¨
  let saveNeed = target.stats.Sv - effectiveAP;
  const canBenefitFromCover = target.inCover &&
    !(target.stats.Sv <= 3 && effectiveAP === 0);
  if (canBenefitFromCover) {
    saveNeed += 1; // æ©è­·+1è±å…
    log(`æ©è­·åŠ æˆ: +1è±å…`, "info");
  }
  saveNeed = Math.max(2, Math.min(7, saveNeed));

  // ç¨®æ—è¦å‰‡çš„ç„¡æ•µè±å…ï¼ˆå¦‚ Warrior Bioform Onslaughtï¼‰
  let targetInv = target.inv;
  const defenderBonus = getDetachmentBonus(target.player, target, attacker, { phase: "defense" });
  if (defenderBonus.invSave && (!targetInv || defenderBonus.invSave < targetInv)) {
    targetInv = defenderBonus.invSave;
    log(`[ç¨®æ—è¦å‰‡] ${target.name} ç²å¾— ${targetInv}+ ç„¡æ•µè±å…`, "info");
  }

  // ç„¡æ•µè±å…
  if (targetInv && targetInv < saveNeed) {
    saveNeed = targetInv;
    log(`ä½¿ç”¨ç„¡æ•µè±å… ${saveNeed}+`, "info");
  }

  const saveRolls = [];
  for (let i = 0; i < wounds; i++) saveRolls.push(rollD6());

  // è±å…éª°å­å‹•ç•«ï¼ˆæ³¨æ„ï¼šè±å…æ˜¯é«˜æ–¼æ‰æˆåŠŸï¼Œæ‰€ä»¥å¤±æ•—çš„é¡¯ç¤ºç‚ºç´…è‰²ï¼‰
  if (enableDiceAnimation && saveRolls.length <= 12) {
    await showDiceRoll(`è±å…æ“²éª° (${target.name} ${saveNeed}+)`, saveRolls, saveNeed, { duration: 600 });
  }

  log(`è±å…æ“²éª°: ${saveRolls.join(", ")} (éœ€è¦ ${saveNeed}+${target.inCover ? " å«æ©è­·" : ""})`, "info");

  const failed = saveRolls.filter(r => r < saveNeed).length;
  log(`å¤±æ•—è±å…: ${failed}/${wounds}`, failed > 0 ? "damage" : "hit");

  if (failed === 0) {
    showFloatingText(target.x, target.y, "ğŸ›¡ï¸ è±å…!", {
      color: "#22cc66",
      fontSize: 16,
      duration: 1000
    });
    return;
  }

  // è¨ˆç®—å‚·å®³ï¼ˆåŒ…å«å–®ä½èƒ½åŠ›å‚·å®³åŠ æˆï¼‰
  let totalDamage = 0;

  // æª¢æŸ¥ç›®æ¨™çš„é˜²ç¦¦èƒ½åŠ›
  const targetDefense = getTargetDefenseAbilities(target);

  for (let i = 0; i < failed; i++) {
    let dmg = weapon.D;
    if (typeof dmg === "string" && dmg.includes("D6")) {
      dmg = rollD6();
    } else if (typeof dmg === "string" && dmg.includes("+")) {
      const parts = dmg.split("+");
      dmg = rollD6() + parseInt(parts[1] || 0);
    }
    // åŠ ä¸Šå–®ä½èƒ½åŠ›å‚·å®³åŠ æˆï¼ˆå¦‚ä¸å¯é˜»æ“‹ï¼šè¡é‹’+1å‚·å®³ï¼‰
    dmg = parseInt(dmg) + (abilityBonus.damageBonus || 0);

    // C'tan ä¸æ»…é‡‘å±¬ï¼šæ¸›å°‘1å‚·å®³ï¼ˆæœ€ä½1ï¼‰
    if (targetDefense.damageReduction > 0) {
      const reduced = Math.max(1, dmg - targetDefense.damageReduction);
      if (reduced < dmg) {
        log(`[ä¸æ»…é‡‘å±¬] å‚·å®³æ¸›å°‘ ${dmg} â†’ ${reduced}`, "info");
        dmg = reduced;
      }
    }

    // ç„¡æ‡¼æ­»äº¡ (FNP)ï¼šé¡å¤–è±å…æª¢å®š
    if (targetDefense.fnp > 0) {
      const fnpRoll = rollD6();
      if (fnpRoll >= targetDefense.fnp) {
        log(`[ç„¡æ‡¼æ­»äº¡] ${fnpRoll} â‰¥ ${targetDefense.fnp}+ å¿½ç•¥å‚·å®³!`, "info");
        showFloatingText(target.x, target.y - 20, `FNP ${fnpRoll}+`, {
          color: "#44ff88",
          fontSize: 14,
          duration: 1000
        });
        continue; // å¿½ç•¥é€™æ¬¡å‚·å®³
      } else {
        log(`[ç„¡æ‡¼æ­»äº¡] ${fnpRoll} < ${targetDefense.fnp}+ å¤±æ•—`, "info");
      }
    }

    totalDamage += dmg;
  }

  log(`é€ æˆ ${totalDamage} é»å‚·å®³ï¼`, "damage");

  // éŸ³æ•ˆï¼šå‘½ä¸­
  playSound('hit');
  if (totalDamage >= 5) {
    playSound('explosion', { size: 'medium' });
  }

  // é¡¯ç¤ºå‚·å®³æ•¸å­—å’Œçˆ†ç‚¸æ•ˆæœ
  showDamageNumber(target.x, target.y, totalDamage, totalDamage >= 5);
  showExplosion(target.x, target.y, {
    radius: 15 + totalDamage * 2,
    color: totalDamage >= 5 ? "#ff0000" : "#ff6600"
  });

  // æ‡‰ç”¨æˆ°å¾Œèƒ½åŠ›æ•ˆæœï¼ˆå¦‚åå™¬æ¢å¾©ï¼‰
  applyPostCombatAbilities(attacker, target, totalDamage, context);

  target.currentHP -= totalDamage;
  if (target.currentHP <= 0) {
    target.currentHP = 0;
    target.alive = false;
    log(`ğŸ’€ ${target.name} è¢«æ¶ˆæ»…ï¼`, "damage");

    // éŸ³æ•ˆï¼šæ­»äº¡
    playSound('death');
    playSound('explosion', { size: 'large' });

    // å–®ä½è¢«æ¶ˆæ»…æ™‚é¡¯ç¤ºå¤§çˆ†ç‚¸
    showExplosion(target.x, target.y, {
      radius: 50,
      color: "#ff0000",
      duration: 500
    });
    showFloatingText(target.x, target.y, "ğŸ’€ æ“Šæ®º!", {
      color: "#ff0000",
      fontSize: 20,
      duration: 2000
    });
  }

  checkVictory();

  // ç·šä¸Šæ¨¡å¼åŒæ­¥æ”»æ“Šçµæœ
  if (isOnlineMode) {
    syncGameStateToFirebase();
  }
}


function resolveHazardous(attacker, weapon) {
  if (!weapon || !weapon.keywords || !weapon.keywords.includes("Hazardous")) return;
  // 10ç‰ˆï¼šä½¿ç”¨Hazardousæ­¦å™¨å®Œæˆæ”»æ“Šå¾Œï¼Œæ“²1D6ï¼›è‹¥ç‚º1ï¼Œæ‰¿å—3é»è‡´å‘½å‚·ï¼ˆç°¡åŒ–ï¼šç›´æ¥æ‰£HPï¼‰
  const r = rollD6();
  log(`âš ï¸ Hazardous æª¢å®š: ${r} (1æœƒå›ç«)`, "info");
  if (r === 1) {
    const mortals = 3;
    attacker.currentHP -= mortals;
    log(`ğŸ’¥ ${attacker.name} å—åˆ° Hazardous å›ç«ï¼š-${mortals} HP`, "damage");
    if (attacker.currentHP <= 0) {
      attacker.currentHP = 0;
      attacker.alive = false;
      log(`ğŸ’€ ${attacker.name} å› å›ç«è¢«æ¶ˆæ»…ï¼`, "damage");
    }
  }
}

function rollD6() {

  return Math.floor(Math.random() * 6) + 1;
}

// å®˜æ–¹10ç‰ˆå‚·å®³è¡¨
// S >= 2Ã—T â†’ 2+
// S > T â†’ 3+
// S = T â†’ 4+
// S < T â†’ 5+
// S <= T/2 â†’ 6+
function getWoundRoll(S, T) {
  if (S >= T * 2) return 2;      // Sæ˜¯Tçš„å…©å€æˆ–æ›´å¤š
  if (S > T) return 3;           // Så¤§æ–¼T
  if (S === T) return 4;         // Sç­‰æ–¼T
  if (S <= T / 2) return 6;      // Sæ˜¯Tçš„ä¸€åŠæˆ–æ›´å°‘ï¼ˆä¿®æ­£é †åºï¼‰
  return 5;                      // Så°æ–¼T
}

// ç²å–å‚·å®³è¡¨èªªæ˜
function getWoundRollExplanation(S, T) {
  if (S >= T * 2) return `S${S} â‰¥ 2Ã—T${T} â†’ 2+`;
  if (S > T) return `S${S} > T${T} â†’ 3+`;
  if (S === T) return `S${S} = T${T} â†’ 4+`;
  if (S <= T / 2) return `S${S} â‰¤ T${T}/2 â†’ 6+`;
  return `S${S} < T${T} â†’ 5+`;
}

// ========== æ©è­·æª¢æ¸¬ ==========
function checkCover(unit) {
  unit.inCover = false;
  for (const t of gameState.terrain) {
    if (unit.x >= t.x - t.width/2 && unit.x <= t.x + t.width/2 &&
        unit.y >= t.y - t.height/2 && unit.y <= t.y + t.height/2) {
      unit.inCover = true;
      break;
    }
  }
}

// ========== éšæ®µæ§åˆ¶ ==========
async function startCommandPhase() {
  // æ¸…é™¤ä¹‹å‰çš„ç‰¹æ•ˆ
  clearAllVisualEffects();
  hideDiceOverlay();

  gameState.phase = "command";
  updatePhaseDisplay();

  const playerName = gameState.currentPlayer === 1 ?
    (ai1Enabled ? "AI-1" : "ç©å®¶ä¸€") :
    (ai2Enabled ? "AI-2" : "ç©å®¶äºŒ");
  log(`ã€${playerName}æŒ‡æ®éšæ®µé–‹å§‹ã€‘`, "phase");

  // æŒ‡æ®éšæ®µé–‹å§‹ï¼Œé›™æ–¹å„+1 CP
  gainCPAtCommandStart();

  // æ‡‰ç”¨å›åˆé–‹å§‹çš„å†ç”Ÿèƒ½åŠ›ï¼ˆæ´»é‡‘å±¬ç­‰ï¼‰
  applyRegenerationAbilities();

  // è¨ˆç®—ç›®æ¨™æ§åˆ¶ç‹€æ…‹
  computeObjectiveControl();

  // è¨ˆç®—VPç²å¾—
  const gain = scorePrimary(gameState.currentPlayer);
  const controlCount = gameState.objectives.filter(o => o.control === gameState.currentPlayer).length;
  const prevVP = gameState.vp[gameState.currentPlayer];
  gameState.vp[gameState.currentPlayer] += gain;
  updateVPDisplay();

  if (gain > 0) {
    log(`ğŸ† ${playerName}æ§åˆ¶ ${controlCount} å€‹ç›®æ¨™ â†’ +${gain} VP (ç¸½è¨ˆ: ${prevVP} â†’ ${gameState.vp[gameState.currentPlayer]})`, "phase");
    playSound('click');
  } else {
    log(`âš ï¸ ${playerName}æœªæ§åˆ¶ä»»ä½•ç›®æ¨™ï¼Œæœ¬å›åˆ+0 VP`, "info");
  }

  // é¡¯ç¤ºæˆ°ç•¥é¸æ“‡å½ˆçª—ï¼ˆç©å®¶æ§åˆ¶æ™‚ï¼Œæœ‰CPä¸”æœ‰æˆ°ç•¥æ™‚ï¼‰
  const isAI = (gameState.currentPlayer === 1 && ai1Enabled) || (gameState.currentPlayer === 2 && ai2Enabled);
  if (!isAI && gameState.cp[gameState.currentPlayer] >= 1) {
    try {
      await showStratagemPopup("command");
    } catch (e) {
      console.error("Stratagem popup error:", e);
    }
  }

  // æˆ°æ…„æ¸¬è©¦ Battle-shockï¼ˆå®˜æ–¹10ç‰ˆè¦å‰‡ï¼‰
  // ä½æ–¼åŠæ•¸å‚·å£çš„å–®ä½éœ€è¦æ¸¬è©¦
  const currentUnits = gameState.units.filter(u => u.player === gameState.currentPlayer && u.alive);
  for (const unit of currentUnits) {
    if (unit.currentHP <= unit.maxHP / 2) {
      const roll = rollD6() + rollD6(); // 2D6
      if (roll >= unit.stats.Ld) {
        unit.battleShocked = false;
        log(`${unit.name} æˆ°æ…„æ¸¬è©¦é€šé (${roll} â‰¥ ${unit.stats.Ld}+)`, "hit");
      } else {
        unit.battleShocked = true;
        log(`${unit.name} æˆ°æ…„ï¼OCè®Šç‚º0 (${roll} < ${unit.stats.Ld}+)`, "miss");
      }
    }
  }

  // Necrons å¾©æ´»å”è­°ï¼ˆå®˜æ–¹è¦å‰‡ï¼‰
  for (const unit of currentUnits) {
    if (unit.faction === "necrons" && unit.currentHP < unit.maxHP) {
      const healed = Math.min(rollD6() % 3 + 1, unit.maxHP - unit.currentHP); // D3
      unit.currentHP += healed;
      log(`${unit.name} å¾©æ´»å”è­°ï¼šæ¢å¾© ${healed} å‚·å£`, "hit");
    }
  }

  updateUnitLists();
}

function computeObjectiveControl() {
  const OBJ_RANGE = 3 * INCH;
  let changes = [];

  for (const obj of gameState.objectives) {
    let oc1 = 0, oc2 = 0;
    let units1 = [], units2 = [];

    for (const unit of gameState.units) {
      if (!unit.alive) continue;
      const dist = Math.hypot(unit.x - obj.x, unit.y - obj.y);
      if (dist <= OBJ_RANGE) {
        // æˆ°æ…„ä¸­çš„å–®ä½OCç‚º0ï¼ˆå®˜æ–¹è¦å‰‡ï¼‰
        const effectiveOC = unit.battleShocked ? 0 : unit.stats.OC;
        if (unit.player === 1) {
          oc1 += effectiveOC;
          units1.push(unit.name);
        } else {
          oc2 += effectiveOC;
          units2.push(unit.name);
        }
      }
    }

    const prevControl = obj.control;
    if (oc1 > oc2) obj.control = 1;
    else if (oc2 > oc1) obj.control = 2;
    else obj.control = null;

    // è¨˜éŒ„æ§åˆ¶æ¬Šè®ŠåŒ–
    if (prevControl !== obj.control) {
      if (obj.control === 1) {
        changes.push(`ğŸ´ ç©å®¶ä¸€ä½”é ˜ç›®æ¨™${obj.id} (OC: ${oc1} vs ${oc2})`);
      } else if (obj.control === 2) {
        changes.push(`ğŸ´ ç©å®¶äºŒä½”é ˜ç›®æ¨™${obj.id} (OC: ${oc2} vs ${oc1})`);
      } else if (prevControl !== null) {
        changes.push(`âš”ï¸ ç›®æ¨™${obj.id}è¢«çˆ­å¥ªä¸­ (OC: ${oc1} vs ${oc2})`);
      }
    }
  }

  // è¼¸å‡ºæ§åˆ¶æ¬Šè®ŠåŒ–
  changes.forEach(c => log(c, "info"));

  // é¡¯ç¤ºç•¶å‰ç›®æ¨™æ§åˆ¶ç‹€æ…‹
  const p1Count = gameState.objectives.filter(o => o.control === 1).length;
  const p2Count = gameState.objectives.filter(o => o.control === 2).length;
  const contested = gameState.objectives.filter(o => o.control === null).length;
  if (p1Count > 0 || p2Count > 0 || contested > 0) {
    log(`ğŸ“ ç›®æ¨™æ§åˆ¶ï¼šç©å®¶ä¸€ ${p1Count}å€‹ | ç©å®¶äºŒ ${p2Count}å€‹ | çˆ­å¥ªä¸­ ${contested}å€‹`, "info");
  }
}

function scorePrimary(player) {
  return Math.min(15, gameState.objectives.filter(o => o.control === player).length * 5);
}

async function nextPhase() {
  // ç·šä¸Šæ¨¡å¼ï¼šåªæœ‰ç•¶å‰ç©å®¶å¯ä»¥åˆ‡æ›éšæ®µ
  if (isOnlineMode && !isMyTurn()) {
    log('ç­‰å¾…å°æ‰‹è¡Œå‹•...', 'info');
    return;
  }

  // æ¸…é™¤ä¸Šä¸€éšæ®µçš„è¦–è¦ºç‰¹æ•ˆ
  clearAllVisualEffects();
  hideDiceOverlay();

  const phases = ["command", "movement", "shooting", "charge", "fight"];
  const currentIndex = phases.indexOf(gameState.phase);

  if (currentIndex < phases.length - 1) {
    gameState.phase = phases[currentIndex + 1];
    log(`é€²å…¥ã€${getPhaseNameChinese(gameState.phase)}ã€‘`, "phase");
    updatePhaseDisplay();
    updateActionButtons();

    // ç·šä¸Šæ¨¡å¼åŒæ­¥éšæ®µè®Šæ›´
    if (isOnlineMode) {
      syncGameStateToFirebase();
    }

    // é¡¯ç¤ºæˆ°ç•¥é¸æ“‡å½ˆçª—ï¼ˆç©å®¶æ§åˆ¶æ™‚ï¼‰
    const isAI = (gameState.currentPlayer === 1 && ai1Enabled) || (gameState.currentPlayer === 2 && ai2Enabled);
    if (!isAI && gameState.cp[gameState.currentPlayer] >= 1) {
      try {
        await showStratagemPopup(gameState.phase);
      } catch (e) {
        console.error("Stratagem popup error:", e);
      }
    }
  }
}

function endTurn() {
  // ç·šä¸Šæ¨¡å¼æª¢æŸ¥æ˜¯å¦ç‚ºè‡ªå·±çš„å›åˆ
  if (isOnlineMode && !isMyTurn()) {
    log('ä¸æ˜¯ä½ çš„å›åˆï¼', 'miss');
    return;
  }

  // æ¸…é™¤æ‰€æœ‰è¦–è¦ºç‰¹æ•ˆå’ŒUI
  clearAllUIEffects();

  // é‡ç½®å–®ä½ç‹€æ…‹
  gameState.units.forEach(u => {
    u.hasMoved = false;
    u.hasShot = false;
    u.hasCharged = false;
    u.hasFought = false;
  });

  // é‡ç½®æŒ‡æ®é‡æ“²
  gameState.pendingReroll = null;

  // åˆ‡æ›ç©å®¶
  gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;

  // å¦‚æœå›åˆ°ç©å®¶ä¸€ï¼Œæ–°å›åˆ
  if (gameState.currentPlayer === 1) {
    gameState.round++;
    document.getElementById("roundNum").textContent = gameState.round;
    document.getElementById("roundDisplay").textContent = gameState.round;

    // éŸ³æ•ˆï¼šæ–°å›åˆ
    playSound('roundStart');

    // æ–°å›åˆæ¸…ç©ºæ—¥èªŒï¼ˆä¿æŒç°¡æ½”ï¼‰
    clearLog();
    log(`â•â•â•â•â•â• ç¬¬ ${gameState.round} å›åˆé–‹å§‹ â•â•â•â•â•â•`, "phase");

    // æ¯å›åˆé–‹å§‹æ™‚æ¸…ç†å·²æ­»äº¡å–®ä½ï¼ˆæ¸›å°‘é™£åˆ—å¤§å°ä»¥æå‡æ€§èƒ½ï¼‰
    const deadUnits = gameState.units.filter(u => !u.alive);
    if (deadUnits.length > 0) {
      gameState.units = gameState.units.filter(u => u.alive);
      log(`æ¸…é™¤ ${deadUnits.length} å€‹æ®˜éª¸`, "info");
    }
  }

  let playerName;
  if (gameState.currentPlayer === 1) {
    playerName = ai1Enabled ? "ğŸ¤– AI-1" : "ç©å®¶ä¸€";
  } else {
    playerName = ai2Enabled ? "ğŸ¤– AI-2" : "ç©å®¶äºŒ";
  }
  document.getElementById("currentPlayerName").textContent = playerName;

  // é¡¯ç¤ºç•¶å‰ç¨®æ—è¦å‰‡
  const det = playerDetachments[gameState.currentPlayer];
  document.getElementById("currentDetachment").textContent = det ? det.name : "";

  gameState.selectedUnit = null;
  clearAction();
  updateSelectedUnitInfo();
  updateUnitLists();
  updateCPDisplay();
  render();

  const currentName = gameState.currentPlayer === 1 ?
    (ai1Enabled ? "AI-1" : "ç©å®¶ä¸€") :
    (ai2Enabled ? "AI-2" : "ç©å®¶äºŒ");
  log(`=== ${currentName} å›åˆ ===`, "phase");

  // ç·šä¸Šæ¨¡å¼ï¼šåŒæ­¥ç‹€æ…‹ä¸¦é€šçŸ¥å°æ‰‹
  if (isOnlineMode) {
    sendAction({ type: 'endTurn' });
    syncGameStateToFirebase();
  }

  // æ ¹æ“šæ˜¯å¦AIæ±ºå®šåŸ·è¡Œæ–¹å¼
  const isAITurn = (gameState.currentPlayer === 1 && ai1Enabled) || (gameState.currentPlayer === 2 && ai2Enabled);

  // ç·šä¸Šæ¨¡å¼ä¸ä½¿ç”¨AI
  if (isOnlineMode) {
    if (isMyTurn()) {
      startCommandPhase();
    }
    return;
  }

  if (isAITurn) {
    // AIå›åˆï¼šç”±runAITurnè™•ç†æ‰€æœ‰éšæ®µ
    setTimeout(() => runAITurn(), 500);
  } else {
    // ç©å®¶å›åˆï¼šåŸ·è¡ŒæŒ‡æ®éšæ®µ
    startCommandPhase();
  }
}

function getPhaseNameChinese(phase) {
  const names = { deployment: "éƒ¨ç½²éšæ®µ", command: "æŒ‡æ®éšæ®µ", movement: "ç§»å‹•éšæ®µ", shooting: "å°„æ“Šéšæ®µ", charge: "è¡é‹’éšæ®µ", fight: "è¿‘æˆ°éšæ®µ" };
  return names[phase] || phase;
}

function updatePhaseDisplay() {
  document.querySelectorAll(".phase-pip").forEach(pip => {
    pip.classList.remove("active", "done");
    if (pip.dataset.phase === gameState.phase) pip.classList.add("active");
  });
  updateActionButtons();

  // æ›´æ–°æˆ°ç•¥é¢æ¿ï¼ˆå¦‚æœå·²å±•é–‹ï¼‰
  const stratagemPanel = document.getElementById("stratagemPanel");
  if (stratagemPanel && stratagemPanel.style.display !== "none") {
    updateStratagemPanel();
  }
}

function updateActionButtons() {
  const phase = gameState.phase;
  const unit = gameState.selectedUnit;
  const isMyUnit = unit && unit.player === gameState.currentPlayer;

  document.getElementById("btnMove").disabled = !(phase === "movement" && isMyUnit && !unit?.hasMoved);
  document.getElementById("btnShoot").disabled = !(phase === "shooting" && isMyUnit && !unit?.hasShot);
  document.getElementById("btnCharge").disabled = !(phase === "charge" && isMyUnit && !unit?.hasCharged);
  document.getElementById("btnFight").disabled = !(phase === "fight" && isMyUnit && !unit?.hasFought);
}

function updateVPDisplay() {
  document.getElementById("vp1Display").textContent = gameState.vp[1];
  document.getElementById("vp2Display").textContent = gameState.vp[2];
  document.getElementById("p1VPDisplay").textContent = gameState.vp[1];
  document.getElementById("p2VPDisplay").textContent = gameState.vp[2];
}

// ========== å‹åˆ©æª¢æŸ¥ ==========
function checkVictory() {
  const p1Alive = gameState.units.filter(u => u.player === 1 && u.alive).length;
  const p2Alive = gameState.units.filter(u => u.player === 2 && u.alive).length;

  if (p1Alive === 0) {
    const winner = ai2Enabled ? "ğŸ¤– AI-2" : "ç©å®¶äºŒ";
    const loser = ai1Enabled ? "AI-1" : "ç©å®¶ä¸€";
    playSound('victory'); // éŸ³æ•ˆï¼šå‹åˆ©
    log(`ğŸ† ${winner} å‹åˆ©ï¼`, "phase");
    if (ai1Enabled && ai2Enabled) {
      alert(`ğŸ¤– VS ğŸ¤– å°æˆ°çµæŸï¼\n${winner} æ“Šæ•—äº† ${loser}ï¼`);
    } else {
      alert(`éŠæˆ²çµæŸï¼${winner}å‹åˆ©ï¼`);
    }
  } else if (p2Alive === 0) {
    const winner = ai1Enabled ? "ğŸ¤– AI-1" : "ç©å®¶ä¸€";
    const loser = ai2Enabled ? "AI-2" : "ç©å®¶äºŒ";
    playSound('victory'); // éŸ³æ•ˆï¼šå‹åˆ©
    log(`ğŸ† ${winner} å‹åˆ©ï¼`, "phase");
    if (ai1Enabled && ai2Enabled) {
      alert(`ğŸ¤– VS ğŸ¤– å°æˆ°çµæŸï¼\n${winner} æ“Šæ•—äº† ${loser}ï¼`);
    } else if (ai2Enabled) {
      alert("ğŸ‰ æ­å–œï¼ä½ æ“Šæ•—äº†AIï¼");
    } else {
      alert(`éŠæˆ²çµæŸï¼${winner}å‹åˆ©ï¼`);
    }
  }
}

// ========== UI æ›´æ–° ==========
function updateUnitLists() {
  const list1 = document.getElementById("team1List");
  const list2 = document.getElementById("team2List");

  list1.innerHTML = "";
  list2.innerHTML = "";

  gameState.units.forEach(unit => {
    const container = unit.player === 1 ? list1 : list2;
    const hpPct = (unit.currentHP / unit.maxHP) * 100;

    let classes = "unit-item";
    if (!unit.alive) classes += " dead";
    if (unit.hasMoved && unit.hasShot && unit.hasFought) classes += " acted";
    if (gameState.selectedUnit?.id === unit.id) classes += " selected";

    const div = document.createElement("div");
    div.className = classes;
    div.onclick = () => selectUnit(unit);
    const statusIcons = [
      gameState.phase === "deployment" && !unit.deployed ? "ğŸ“" : "",
      gameState.phase === "deployment" && unit.deployed ? "âœ“" : "",
      unit.inCover ? "ğŸ›¡ï¸" : "",
      unit.battleShocked ? "ğŸ’€" : ""
    ].filter(Boolean).join(" ");

    div.innerHTML = `
      <div class="unit-avatar"><img src="${unit.img}" onerror="this.style.display='none'"></div>
      <div class="unit-info">
        <div class="unit-name">${unit.name}</div>
        <div class="unit-stats-mini">HP: ${unit.currentHP}/${unit.maxHP} ${statusIcons}</div>
        <div class="unit-hp-bar"><div class="unit-hp-fill" style="width: ${hpPct}%"></div></div>
      </div>
    `;
    container.appendChild(div);
  });

  const faction1 = UNIT_DATABASE[armyRosters[1][0]?.faction]?.name || "ç©å®¶ä¸€";
  const faction2 = UNIT_DATABASE[armyRosters[2][0]?.faction]?.name || "ç©å®¶äºŒ";
  const det1 = playerDetachments[1]?.name ? ` (${playerDetachments[1].name.split(' ')[0]})` : "";
  const det2 = playerDetachments[2]?.name ? ` (${playerDetachments[2].name.split(' ')[0]})` : "";
  document.getElementById("team1Label").textContent = faction1 + det1;
  document.getElementById("team2Label").textContent = faction2 + det2;
}

function highlightSelectedUnit() {
  document.querySelectorAll(".unit-item").forEach(item => item.classList.remove("selected"));
}

function log(message, type = "", sync = true) {
  const logContent = document.getElementById("logContent");
  if (!logContent) return;

  const entry = document.createElement("div");
  entry.className = `log-entry ${type}`;
  entry.textContent = message;
  logContent.appendChild(entry);

  // é™åˆ¶æ—¥èªŒæ¢ç›®æ•¸é‡ä»¥é˜²æ­¢lag
  const MAX_LOG_ENTRIES = 30;
  while (logContent.children.length > MAX_LOG_ENTRIES) {
    logContent.removeChild(logContent.firstChild);
  }

  logContent.scrollTop = logContent.scrollHeight;

  // ç·šä¸Šæ¨¡å¼åŒæ­¥ç´€éŒ„åˆ°å°æ‰‹
  if (sync && isOnlineMode && roomRef && isMyTurn()) {
    syncCombatLog(message, type);
  }
}

// æ¸…ç©ºæˆ°é¬¥æ—¥èªŒ
function clearLog() {
  const logContent = document.getElementById("logContent");
  if (logContent) {
    logContent.innerHTML = "";
  }
}

// ========== æ¸²æŸ“ ==========
let lastRenderTime = 0;
const TARGET_FPS = 30; // é™ä½ç›®æ¨™å¹€ç‡ä»¥æ¸›å°‘CPUä½¿ç”¨
const FRAME_TIME = 1000 / TARGET_FPS;

function render() {
  if (!ctx) return;

  // å¹€ç‡é™åˆ¶
  const now = performance.now();
  if (now - lastRenderTime < FRAME_TIME) {
    requestAnimationFrame(render);
    return;
  }
  lastRenderTime = now;

  // å®šæœŸæ¸…ç†è¨˜æ†¶é«”
  periodicCleanup();

  const w = gameState.canvasWidth || canvas.getBoundingClientRect().width;
  const h = gameState.canvasHeight || canvas.getBoundingClientRect().height;

  // æ¸…é™¤æ•´å€‹ç•«å¸ƒï¼ˆä½¿ç”¨canvaså¯¦éš›å°ºå¯¸ï¼Œä¸å—ç¸®æ”¾å½±éŸ¿ï¼‰
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®ç‚ºåŸå§‹è®Šæ›
  ctx.fillStyle = "#1a2a1a";
  ctx.fillRect(0, 0, canvas.width, canvas.height); // ä½¿ç”¨canvaså¯¦éš›åƒç´ å°ºå¯¸
  ctx.restore();

  // æ‡‰ç”¨ç¸®æ”¾å’Œå¹³ç§»
  ctx.save();
  ctx.setTransform(
    devicePixelRatio * viewZoom, 0,
    0, devicePixelRatio * viewZoom,
    viewOffsetX * devicePixelRatio,
    viewOffsetY * devicePixelRatio
  );

  // ç¹ªè£½ç¶²æ ¼ï¼ˆæ‰¹æ¬¡ç¹ªè£½ä»¥æå‡æ€§èƒ½ï¼‰
  ctx.strokeStyle = "rgba(255,255,255,0.05)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let x = 0; x < w; x += 50) {
    ctx.moveTo(x, 0);
    ctx.lineTo(x, h);
  }
  for (let y = 0; y < h; y += 50) {
    ctx.moveTo(0, y);
    ctx.lineTo(w, y);
  }
  ctx.stroke();

  // ç¹ªè£½éƒ¨ç½²å€ï¼ˆéƒ¨ç½²éšæ®µæ™‚é¡¯ç¤ºï¼‰
  if (gameState.phase === "deployment") {
    // deployZone å·²ç¶“åŒ…å«ç¸®æ”¾ï¼Œç›´æ¥ä½¿ç”¨
    const deployZoneWidth = gameState.deployZone || 12 * INCH;

    // ç©å®¶ä¸€éƒ¨ç½²å€ï¼ˆå·¦å´ï¼‰
    ctx.fillStyle = gameState.deploy.deployingPlayer === 1 ? "rgba(70, 130, 180, 0.3)" : "rgba(70, 130, 180, 0.1)";
    ctx.fillRect(0, 0, deployZoneWidth, h);
    ctx.strokeStyle = "rgba(70, 130, 180, 0.8)";
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, deployZoneWidth, h);

    // ç©å®¶äºŒéƒ¨ç½²å€ï¼ˆå³å´ï¼‰
    ctx.fillStyle = gameState.deploy.deployingPlayer === 2 ? "rgba(220, 80, 80, 0.3)" : "rgba(220, 80, 80, 0.1)";
    ctx.fillRect(w - deployZoneWidth, 0, deployZoneWidth, h);
    ctx.strokeStyle = "rgba(220, 80, 80, 0.8)";
    ctx.lineWidth = 2;
    ctx.strokeRect(w - deployZoneWidth, 0, deployZoneWidth, h);

    // æ¨™ç±¤
    ctx.font = "14px sans-serif";
    ctx.textAlign = "center";
    ctx.fillStyle = gameState.deploy.deployingPlayer === 1 ? "#4682B4" : "#666";
    ctx.fillText("ç©å®¶ä¸€éƒ¨ç½²å€", deployZoneWidth / 2, 20);
    ctx.fillStyle = gameState.deploy.deployingPlayer === 2 ? "#DC5050" : "#666";
    ctx.fillText("ç©å®¶äºŒéƒ¨ç½²å€", w - deployZoneWidth / 2, 20);
  }

  // ç¹ªè£½åœ°å½¢
  for (const t of gameState.terrain) {
    ctx.fillStyle = TERRAIN_TYPES[t.type].color;
    ctx.globalAlpha = 0.6;
    ctx.fillRect(t.x - t.width/2, t.y - t.height/2, t.width, t.height);
    ctx.globalAlpha = 1;
    ctx.strokeStyle = TERRAIN_TYPES[t.type].color;
    ctx.lineWidth = 2;
    ctx.strokeRect(t.x - t.width/2, t.y - t.height/2, t.width, t.height);

    // æ¨™ç±¤
    ctx.font = "10px sans-serif";
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.fillText(TERRAIN_TYPES[t.type].name, t.x, t.y);
  }

  // ç¹ªè£½ç›®æ¨™é»
  const OBJ_RANGE = 3 * INCH;
  for (const obj of gameState.objectives) {
    // æ§åˆ¶ç¯„åœ
    ctx.beginPath();
    ctx.arc(obj.x, obj.y, OBJ_RANGE, 0, Math.PI * 2);
    ctx.strokeStyle = obj.control === 1 ? "rgba(59,130,246,0.6)" :
                      obj.control === 2 ? "rgba(220,38,38,0.6)" :
                      "rgba(251,191,36,0.4)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // æ¨™è¨˜
    ctx.beginPath();
    ctx.arc(obj.x, obj.y, 12, 0, Math.PI * 2);
    ctx.fillStyle = obj.control === 1 ? "#3b82f6" :
                    obj.control === 2 ? "#dc2626" : "#fbbf24";
    ctx.fill();
    ctx.font = "bold 12px sans-serif";
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(obj.id.toString(), obj.x, obj.y);
  }

  // ç¹ªè£½ç§»å‹•/å°„æ“Šç¯„åœï¼ˆé¸ä¸­å–®ä½æ™‚è‡ªå‹•é¡¯ç¤ºï¼‰
  if (gameState.selectedUnit && gameState.selectedUnit.player === gameState.currentPlayer) {
    const unit = gameState.selectedUnit;
    const phase = gameState.phase;
    const action = gameState.currentAction;

    // æ ¹æ“šéšæ®µæˆ–å‹•ä½œæ±ºå®šé¡¯ç¤ºçš„ç¯„åœ
    let ranges = [];

    // ç§»å‹•ç¯„åœï¼ˆç§»å‹•éšæ®µæˆ–ç§»å‹•å‹•ä½œï¼‰
    if ((phase === "movement" || action === "move") && !unit.hasMoved) {
      ranges.push({ range: unit.stats.M * INCH, color: "rgba(34,197,94,0.3)", label: "ç§»å‹•" });
    }

    // å°„æ“Šç¯„åœï¼ˆå°„æ“Šéšæ®µæˆ–å°„æ“Šå‹•ä½œï¼‰
    if ((phase === "shooting" || action === "shoot") && unit.weapons.ranged && !unit.hasShot) {
      ranges.push({ range: unit.weapons.ranged.range * INCH, color: "rgba(251,191,36,0.2)", label: "å°„æ“Š" });
    }

    // è¡é‹’ç¯„åœï¼ˆè¡é‹’éšæ®µæˆ–è¡é‹’å‹•ä½œï¼‰
    if ((phase === "charge" || action === "charge") && !unit.hasCharged && !unit.battleShocked) {
      ranges.push({ range: 12 * INCH, color: "rgba(220,38,38,0.2)", label: "è¡é‹’" });
    }

    // è¿‘æˆ°ç¯„åœï¼ˆè¿‘æˆ°éšæ®µï¼‰
    if ((phase === "fight" || action === "fight") && unit.weapons.melee && !unit.hasFought) {
      ranges.push({ range: 1.5 * INCH, color: "rgba(168,85,247,0.3)", label: "è¿‘æˆ°" });
    }

    // ç¹ªè£½æ‰€æœ‰ç¯„åœ
    for (const r of ranges) {
      if (r.range > 0) {
        ctx.beginPath();
        ctx.arc(unit.x, unit.y, r.range, 0, Math.PI * 2);
        ctx.fillStyle = r.color;
        ctx.fill();
        ctx.strokeStyle = r.color.replace("0.2", "0.6").replace("0.3", "0.8");
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
  }

  // ç¹ªè£½å–®ä½
  for (const unit of gameState.units) {
    // éƒ¨ç½²éšæ®µåªé¡¯ç¤ºå·²éƒ¨ç½²çš„å–®ä½
    if (gameState.phase === "deployment" && !unit.deployed) continue;

    // å‹•æ…‹è¨ˆç®—åº•æ¿å¤§å°
    const BASE_SIZE = getUnitBaseSize(unit);

    ctx.globalAlpha = unit.alive ? 1 : 0.3;

    const faction = UNIT_DATABASE[unit.faction];
    const color = faction?.color || (unit.player === 1 ? "#3b82f6" : "#dc2626");
    const isSelected = gameState.selectedUnit?.id === unit.id;

    // é¸ä¸­å…‰ç’°
    if (isSelected) {
      ctx.beginPath();
      ctx.arc(unit.x, unit.y, BASE_SIZE + 6, 0, Math.PI * 2);
      ctx.strokeStyle = "#fbbf24";
      ctx.lineWidth = 3;
      ctx.setLineDash([4, 4]);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // ç©å®¶é¡è‰²åº•åœˆ
    ctx.beginPath();
    ctx.arc(unit.x, unit.y, BASE_SIZE + 2, 0, Math.PI * 2);
    ctx.fillStyle = unit.player === 1 ? "rgba(59,130,246,0.8)" : "rgba(220,38,38,0.8)";
    ctx.fill();

    // å˜—è©¦ç¹ªè£½å–®ä½åœ–åƒ
    const img = unitImageCache[unit.img];
    if (img && img.complete && img.naturalWidth > 0) {
      // å‰µå»ºåœ“å½¢è£åˆ‡è·¯å¾‘
      ctx.save();
      ctx.beginPath();
      ctx.arc(unit.x, unit.y, BASE_SIZE, 0, Math.PI * 2);
      ctx.clip();

      // ç¹ªè£½åœ–åƒï¼ˆç½®ä¸­è£åˆ‡ï¼‰
      const imgSize = BASE_SIZE * 2;
      ctx.drawImage(img, unit.x - BASE_SIZE, unit.y - BASE_SIZE, imgSize, imgSize);
      ctx.restore();

      // åœ–åƒé‚Šæ¡†
      ctx.beginPath();
      ctx.arc(unit.x, unit.y, BASE_SIZE, 0, Math.PI * 2);
      ctx.strokeStyle = isSelected ? "#fbbf24" : "#000";
      ctx.lineWidth = 2;
      ctx.stroke();
    } else {
      // ç„¡åœ–åƒæ™‚é¡¯ç¤ºé¡è‰²åœ“å½¢å’Œé¦–å­—æ¯
      loadUnitImage(unit);
      ctx.beginPath();
      ctx.arc(unit.x, unit.y, BASE_SIZE, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.strokeStyle = isSelected ? "#fbbf24" : "#000";
      ctx.lineWidth = 2;
      ctx.stroke();

      // é¡¯ç¤ºé¦–å­—æ¯ï¼ˆæ ¹æ“šåº•æ¿å¤§å°èª¿æ•´å­—é«”ï¼‰
      const fontSize = Math.max(10, Math.min(20, BASE_SIZE * 0.7));
      ctx.font = `bold ${fontSize}px sans-serif`;
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(unit.name.charAt(0), unit.x, unit.y);
    }

    // HP ç’°ï¼ˆå¤–åœˆï¼‰
    const hpPct = unit.currentHP / unit.maxHP;
    const hpColor = hpPct > 0.5 ? "#22c55e" : hpPct > 0.25 ? "#f59e0b" : "#ef4444";
    ctx.beginPath();
    ctx.arc(unit.x, unit.y, BASE_SIZE + 5, -Math.PI/2, -Math.PI/2 + hpPct * Math.PI * 2);
    ctx.strokeStyle = hpColor;
    ctx.lineWidth = 3;
    ctx.stroke();

    // HP èƒŒæ™¯ç’°
    ctx.beginPath();
    ctx.arc(unit.x, unit.y, BASE_SIZE + 5, -Math.PI/2 + hpPct * Math.PI * 2, Math.PI * 1.5);
    ctx.strokeStyle = "rgba(100,100,100,0.3)";
    ctx.lineWidth = 3;
    ctx.stroke();

    // ç‹€æ…‹æ¨™è¨˜ - æ©è­·
    if (unit.inCover) {
      ctx.fillStyle = "#22c55e";
      ctx.beginPath();
      ctx.arc(unit.x + BASE_SIZE, unit.y - BASE_SIZE, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.font = "10px sans-serif";
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ğŸ›¡", unit.x + BASE_SIZE, unit.y - BASE_SIZE);
    }

    // ç‹€æ…‹æ¨™è¨˜ - æˆ°æ…„
    if (unit.battleShocked) {
      ctx.fillStyle = "#ef4444";
      ctx.beginPath();
      ctx.arc(unit.x - BASE_SIZE, unit.y - BASE_SIZE, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.font = "10px sans-serif";
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ğŸ’€", unit.x - BASE_SIZE, unit.y - BASE_SIZE);
    }

    // åç¨±ï¼ˆå¸¶é™°å½±ï¼‰
    ctx.font = "bold 10px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    const shortName = unit.name.split(" ")[0].slice(0, 8);
    ctx.fillStyle = "#000";
    ctx.fillText(shortName, unit.x + 1, unit.y - BASE_SIZE - 14);
    ctx.fillStyle = "#fff";
    ctx.fillText(shortName, unit.x, unit.y - BASE_SIZE - 15);

    // OCå€¼é¡¯ç¤º
    if (unit.stats.OC > 0) {
      ctx.font = "bold 9px sans-serif";
      ctx.fillStyle = "#fbbf24";
      ctx.textAlign = "center";
      ctx.fillText(`OC${unit.stats.OC}`, unit.x, unit.y + BASE_SIZE + 8);
    }

    ctx.globalAlpha = 1;
  }

  // æ¸²æŸ“è¦–è¦ºç‰¹æ•ˆï¼ˆæ”»æ“Šå°„ç·šã€å‚·å®³æ•¸å­—ã€æŠ€èƒ½æ–‡å­—ï¼‰
  renderVisualEffects();

  // æ¢å¾©åŸå§‹è®Šæ›
  ctx.restore();

  requestAnimationFrame(render);
}

// åˆå§‹åŒ–
init();
</script>
</body>
</html>
