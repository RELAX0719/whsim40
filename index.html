<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>æˆ°éš 40K ç¬¬åç‰ˆï¼šå®˜æ–¹è¦å‰‡æˆ°æ£‹æ¨¡æ“¬å™¨</title>
<style>
:root {
  --bg: #0a0e14;
  --panel: #111827;
  --panel2: #0f172a;
  --line: #1e3a5f;
  --txt: #e5e7eb;
  --muted: #9ca3af;
  --gold: #fbbf24;
  --red: #ef4444;
  --blue: #3b82f6;
  --green: #22c55e;
}

* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; font-family: "Microsoft JhengHei", "Noto Sans TC", sans-serif; background: var(--bg); color: var(--txt); overflow: hidden; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }

/* ===== éŠæˆ²ç•«é¢ ===== */
.game-screen { display: none; height: 100dvh; min-height: 100dvh; flex-direction: column; }
.game-screen.active { display: flex; }

/* Header */
.game-header {
  padding: 8px 16px;
  background: linear-gradient(180deg, #1a1a2e, transparent);
  border-bottom: 1px solid var(--line);
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.game-title { font-size: 16px; color: var(--gold); }
.phase-indicator {
  display: flex;
  gap: 4px;
}
.phase-pip {
  padding: 4px 10px;
  font-size: 11px;
  border-radius: 4px;
  background: rgba(255,255,255,0.1);
  color: var(--muted);
}
.phase-pip.active { background: var(--gold); color: #000; font-weight: bold; }
.phase-pip.done { background: var(--green); color: #000; }

/* Main Layout */
.game-main {
  flex: 1;
  display: flex;
  overflow: hidden;
}

/* Flexbox å…§å®¹è£åˆ‡ä¿®æ­£ï¼šå…è¨±å­å±¤å®¹å™¨æ­£ç¢ºæ»¾å‹•ï¼ˆé¿å…è¢«ç ï¼‰ */
.game-main, .units-panel, .battlefield-container, .info-panel, .combat-log { min-height: 0; }
.units-panel, .battlefield-container, .info-panel { min-width: 0; }
.units-list, .log-content { min-height: 0; }
.selected-unit-info { max-height: 45%; overflow: auto; }
.battlefield-wrap { min-height: 0; }


/* Left Panel - Units */
.units-panel {
  width: 280px;
  background: var(--panel);
  border-right: 1px solid var(--line);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.panel-header {
  padding: 10px 12px;
  font-size: 13px;
  color: var(--gold);
  border-bottom: 1px solid var(--line);
  display: flex;
  justify-content: space-between;
}
.units-list {
  flex: 1;
  overflow-y: auto;
  padding: 6px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(52px, 1fr));
  gap: 4px;
  align-content: start;
}

.unit-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 4px;
  background: rgba(0,0,0,0.3);
  border: 2px solid transparent;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
}
.unit-item:hover { background: rgba(255,255,255,0.1); transform: scale(1.05); }
.unit-item.selected { border-color: var(--gold); background: rgba(251,191,36,0.15); }
.unit-item.enemy { border-color: var(--red); }
.unit-item.dead { opacity: 0.4; pointer-events: auto; }
.unit-item.dead::after { content: "ğŸ’€"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; }
.unit-item.acted { opacity: 0.5; }

.unit-avatar {
  width: 44px;
  height: 44px;
  border-radius: 4px;
  background: #1a1a2e;
  overflow: hidden;
  flex-shrink: 0;
}
.unit-avatar img { width: 100%; height: 100%; object-fit: cover; }

.unit-info { width: 100%; text-align: center; }
.unit-name { font-size: 9px; font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-top: 2px; }
.unit-stats-mini { display: none; }
.unit-hp-bar { height: 3px; background: #1a1a2e; border-radius: 2px; margin-top: 2px; overflow: hidden; }
.unit-hp-fill { height: 100%; background: linear-gradient(90deg, var(--red), var(--green)); transition: width 0.3s; }

.unit-status-icon {
  position: absolute;
  top: 2px;
  right: 2px;
  font-size: 10px;
  text-shadow: 0 0 3px #000;
}

/* Center - Battlefield */
.battlefield-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.battlefield-toolbar {
  padding: 8px 12px;
  background: var(--panel);
  border-bottom: 1px solid var(--line);
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
}
.toolbar-btn {
  padding: 6px 12px;
  font-size: 12px;
  border: 1px solid var(--line);
  background: rgba(255,255,255,0.05);
  color: var(--txt);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
}
.toolbar-btn:hover { background: rgba(255,255,255,0.1); }
.toolbar-btn.primary { background: var(--blue); border-color: var(--blue); }
.toolbar-btn.danger { background: var(--red); border-color: var(--red); }
.toolbar-btn.success { background: var(--green); border-color: var(--green); color: #000; }
.toolbar-btn:disabled { opacity: 0.4; cursor: not-allowed; }

.action-hint {
  margin-left: auto;
  font-size: 12px;
  color: var(--gold);
  padding: 4px 10px;
  background: rgba(251,191,36,0.1);
  border-radius: 4px;
}

.battlefield-wrap {
  flex: 1;
  position: relative;
  overflow: hidden;
  min-height: 200px;
  background: linear-gradient(135deg, #1a2a1a 0%, #0f1a0f 100%);
  display: flex;
  align-items: center;
  justify-content: center;
}
#gameCanvas {
  display: block;
  border: none;
  box-shadow: 0 0 20px rgba(0,0,0,0.5);
}

/* Right Panel - Info & Log */
.info-panel {
  width: 320px;
  background: var(--panel);
  border-left: 1px solid var(--line);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.selected-unit-info {
  padding: 12px;
  border-bottom: 1px solid var(--line);
}
.selected-unit-header {
  display: flex;
  gap: 12px;
  margin-bottom: 10px;
}
.selected-avatar {
  width: 64px;
  height: 64px;
  border-radius: 8px;
  overflow: hidden;
  background: #1a1a2e;
}
.selected-avatar img { width: 100%; height: 100%; object-fit: cover; }
.selected-details { flex: 1; }
.selected-name { font-size: 14px; font-weight: bold; color: var(--gold); }
.selected-faction { font-size: 11px; color: var(--muted); }

.stats-grid {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 4px;
  margin-top: 10px;
}
.stat-cell {
  text-align: center;
  padding: 6px 4px;
  background: rgba(0,0,0,0.3);
  border-radius: 4px;
}
.stat-label { font-size: 9px; color: var(--muted); }
.stat-value { font-size: 14px; font-weight: bold; }

.weapons-section {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--line);
}
.weapon-item {
  padding: 6px 8px;
  margin-bottom: 4px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
  font-size: 11px;
  border: 1px solid transparent;
  transition: all 0.2s ease;
}
.weapon-item.weapon-clickable {
  cursor: pointer;
  border-color: var(--gold);
}
.weapon-item.weapon-clickable:hover {
  background: rgba(251,191,36,0.2);
  transform: translateX(2px);
}
.weapon-item.weapon-selected {
  background: rgba(59,130,246,0.3);
  border: 2px solid #3b82f6;
}
.weapon-item.weapon-used {
  opacity: 0.4;
  cursor: not-allowed;
}
.weapon-name { color: var(--gold); font-weight: bold; }
.weapon-stats { color: var(--muted); margin-top: 2px; }

/* éƒ¨ç½²é¸ä¸­æ¨£å¼ */
.unit-item.deploy-selected {
  border: 2px solid #22c55e;
  background: rgba(34,197,94,0.2);
}
/* å¯æ‹–æ›³éƒ¨ç½²æ¨£å¼ */
.unit-item[draggable="true"] {
  border: 2px dashed #22c55e;
  cursor: grab;
}
.unit-item[draggable="true"]:hover {
  background: rgba(34,197,94,0.15);
  transform: scale(1.08);
}
.unit-item[draggable="true"]:active {
  cursor: grabbing;
}

.combat-log {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.log-content {
  flex: 1;
  overflow-y: auto;
  padding: 10px;
  font-size: 11px;
  line-height: 1.6;
  font-family: Consolas, monospace;
}
.log-entry { margin-bottom: 4px; padding: 2px 6px; border-left: 2px solid var(--line); }
.log-entry.hit { border-color: var(--green); color: #86efac; }
.log-entry.miss { border-color: var(--red); color: #fca5a5; }
.log-entry.damage { border-color: #f97316; color: #fdba74; }
.log-entry.phase { border-color: var(--gold); color: var(--gold); font-weight: bold; }
.log-entry.info { border-color: var(--blue); color: #93c5fd; }

/* ===== éª°å­è¦–è¦ºåŒ– ===== */
.dice-overlay {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.9);
  border: 3px solid var(--gold);
  border-radius: 16px;
  padding: 20px 30px;
  z-index: 1000;
  display: none;
  flex-direction: column;
  align-items: center;
  gap: 15px;
  min-width: 300px;
  box-shadow: 0 0 40px rgba(251, 191, 36, 0.3);
}
.dice-overlay.active { display: flex; animation: dicePopIn 0.3s ease-out; }
@keyframes dicePopIn {
  from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
  to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
}
.dice-roll-btn {
  animation: diceButtonPulse 1s infinite;
  transition: all 0.2s;
}
.dice-roll-btn:hover {
  transform: scale(1.1);
  box-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
}
@keyframes diceButtonPulse {
  0%, 100% { box-shadow: 0 0 10px rgba(251, 191, 36, 0.3); }
  50% { box-shadow: 0 0 25px rgba(251, 191, 36, 0.6); }
}
.dice-title {
  font-size: 14px;
  color: var(--gold);
  text-transform: uppercase;
  letter-spacing: 2px;
}
.dice-container {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center;
  max-width: 400px;
}
.dice {
  width: 48px;
  height: 48px;
  background: linear-gradient(135deg, #2a2a3a, #1a1a2a);
  border: 2px solid #444;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  font-weight: bold;
  color: #fff;
  transition: all 0.3s;
  position: relative;
}
.dice.rolling { animation: diceRoll 0.1s infinite; }
@keyframes diceRoll {
  0%, 100% { transform: rotate(-5deg); }
  50% { transform: rotate(5deg); }
}
.dice.success { border-color: var(--green); color: var(--green); box-shadow: 0 0 10px rgba(34, 197, 94, 0.5); }
.dice.fail { border-color: var(--red); color: var(--red); opacity: 0.6; }
.dice.critical { border-color: var(--gold); color: var(--gold); box-shadow: 0 0 15px rgba(251, 191, 36, 0.7); animation: diceCrit 0.5s ease-out; }
@keyframes diceCrit {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.2); }
}
.dice-result {
  font-size: 18px;
  color: var(--txt);
  text-align: center;
}
.dice-result .success-count { color: var(--green); font-weight: bold; }
.dice-result .fail-count { color: var(--red); }

/* Score Bar */
.score-bar {
  padding: 8px 12px;
  background: rgba(0,0,0,0.3);
  border-top: 1px solid var(--line);
  display: flex;
  justify-content: space-around;
  font-size: 12px;
}
.score-item { text-align: center; }
.score-label { color: var(--muted); font-size: 10px; }
.score-value { font-size: 16px; font-weight: bold; color: var(--gold); }

/* ===== è»è¡¨é…ç½®ç•«é¢ ===== */
.setup-screen {
  height: 100vh;
  background: radial-gradient(ellipse at 30% 20%, #1a2340 0%, var(--bg) 60%);
  overflow-y: auto;
  padding: 20px;
}

.setup-header {
  text-align: center;
  margin-bottom: 30px;
}
.setup-header h1 {
  font-size: 32px;
  color: var(--gold);
  text-shadow: 0 0 20px rgba(251,191,36,0.3);
}
.setup-header p {
  color: var(--muted);
  margin-top: 8px;
}

.setup-container {
  max-width: 1400px;
  margin: 0 auto;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
}

.army-builder {
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 16px;
}
.army-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--line);
}
.army-title { font-size: 16px; font-weight: bold; }
.army-title.player1 { color: var(--blue); }
.army-title.player2 { color: var(--red); }
.points-display {
  font-size: 14px;
  padding: 4px 12px;
  background: rgba(0,0,0,0.3);
  border-radius: 6px;
}

.faction-select {
  margin-bottom: 16px;
}
.faction-select label {
  display: block;
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 6px;
}
.faction-select select {
  width: 100%;
  padding: 8px 12px;
  background: rgba(0,0,0,0.3);
  border: 1px solid var(--line);
  border-radius: 6px;
  color: var(--txt);
  font-size: 14px;
}

.available-units {
  margin-bottom: 16px;
}
.available-units h4 {
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 8px;
}
.unit-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 8px;
  max-height: 300px;
  overflow-y: auto;
}
.unit-option {
  display: flex;
  gap: 8px;
  padding: 8px;
  background: rgba(0,0,0,0.2);
  border: 1px solid var(--line);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
}
.unit-option:hover { background: rgba(255,255,255,0.05); border-color: var(--gold); }
.unit-option img {
  width: 40px;
  height: 40px;
  border-radius: 4px;
  object-fit: cover;
}
.unit-option-info { flex: 1; }
.unit-option-name { font-size: 11px; font-weight: bold; }
.unit-option-cost { font-size: 10px; color: var(--gold); }

.selected-roster {
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  padding: 12px;
  min-height: 150px;
}
.selected-roster h4 {
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 8px;
}
.roster-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 8px;
  background: rgba(255,255,255,0.05);
  border-radius: 4px;
  margin-bottom: 4px;
  font-size: 12px;
}
.roster-item .remove-btn {
  background: var(--red);
  border: none;
  color: #fff;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 14px;
  line-height: 1;
}

.setup-actions {
  text-align: center;
  margin-top: 30px;
}
.start-game-btn {
  padding: 16px 48px;
  font-size: 18px;
  background: linear-gradient(135deg, #dc2626, #991b1b);
  border: 2px solid var(--gold);
  color: var(--gold);
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.2s;
}
.start-game-btn:hover { transform: scale(1.05); }
.start-game-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

/* Terrain Legend */
.terrain-legend {
  margin-top: 20px;
  padding: 12px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
}
.terrain-legend h4 { font-size: 12px; color: var(--gold); margin-bottom: 8px; }
.terrain-item {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 4px;
  font-size: 11px;
}
.terrain-color {
  width: 16px;
  height: 16px;
  border-radius: 4px;
}

/* Responsive */
@media (max-width: 1200px) {
  .units-panel, .info-panel { width: 240px; }
}
@media (max-width: 900px) {
  .game-main { flex-direction: column; height: auto; min-height: 100vh; }
  .units-panel { width: 100%; height: auto; max-height: 180px; order: 1; flex-direction: row; }
  .units-panel .panel-header { padding: 6px 8px; font-size: 11px; }
  .units-list { grid-template-columns: repeat(auto-fill, minmax(48px, 1fr)); gap: 3px; padding: 4px; }
  .unit-avatar { width: 40px; height: 40px; }
  .unit-name { font-size: 8px; }
  .battlefield-container { width: 100%; min-height: 50vh; order: 2; flex: none; }
  .battlefield-wrap { min-height: 45vh; }
  .info-panel { width: 100%; height: auto; max-height: 200px; order: 3; }
  .setup-container { grid-template-columns: 1fr; }
  .battlefield-toolbar { flex-wrap: wrap; justify-content: center; padding: 6px; }
  .toolbar-btn { padding: 4px 8px; font-size: 11px; }
  .action-hint { margin-left: 0; margin-top: 6px; width: 100%; text-align: center; }
}
@media (max-width: 600px) {
  .battlefield-container { min-height: 40vh; }
  .battlefield-wrap { min-height: 35vh; overflow: visible; }
  .units-panel { max-height: 140px; }
  .units-list { grid-template-columns: repeat(auto-fill, minmax(42px, 1fr)); gap: 2px; }
  .unit-avatar { width: 36px; height: 36px; }
  .unit-name { font-size: 7px; }
  .info-panel { max-height: 120px; font-size: 11px; }
  .toolbar-btn { padding: 3px 6px; font-size: 10px; }
}
</style>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-database-compat.js"></script>
</head>
<body>

<!-- ===== è»è¡¨é…ç½®ç•«é¢ ===== -->
<div class="setup-screen" id="setupScreen">
  <div class="setup-header">
    <h1>âš”ï¸ æˆ°éš 40,000 âš”ï¸</h1>
    <p>ç¬¬åç‰ˆæ ¸å¿ƒè¦å‰‡ - è»è¡¨é…ç½®</p>
    <p style="font-size: 11px; color: #666; margin-top: 4px;">ç‰ˆæœ¬ 1.4.4 (2026-02-07)</p>
  </div>

  <!-- é€£ç·šå°æˆ°é¸é … -->
  <div style="max-width: 600px; margin: 0 auto 20px; padding: 15px; background: rgba(59,130,246,0.15); border: 1px solid var(--blue); border-radius: 10px;">
    <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; justify-content: center; margin-bottom: 10px;">
      <span style="font-weight: bold; color: var(--blue); font-size: 16px;">ğŸŒ éŠæˆ²æ¨¡å¼</span>
      <select id="gameMode" onchange="switchGameMode(this.value)" style="padding: 8px 12px; background: var(--panel); border: 1px solid var(--line); border-radius: 6px; color: var(--txt); font-size: 14px;">
        <option value="local">æœ¬åœ°å°æˆ° / AI</option>
        <option value="online">ç·šä¸Šå°æˆ°</option>
      </select>
    </div>

    <!-- ç·šä¸Šå°æˆ°é¢æ¿ -->
    <div id="onlinePanel" style="display: none; margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px;">
      <div id="roomLobby">
        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
          <button onclick="createRoom()" style="padding: 12px 24px; background: linear-gradient(135deg, #22c55e, #16a34a); border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 14px;">
            â• å»ºç«‹æˆ¿é–“
          </button>
          <div style="display: flex; gap: 5px;">
            <input type="text" id="joinRoomCode" placeholder="è¼¸å…¥æˆ¿é–“ç¢¼" maxlength="6" style="width: 120px; padding: 12px; background: var(--panel); border: 1px solid var(--line); border-radius: 8px; color: var(--txt); text-align: center; font-size: 16px; text-transform: uppercase;">
            <button onclick="joinRoom()" style="padding: 12px 24px; background: linear-gradient(135deg, #3b82f6, #2563eb); border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 14px;">
              ğŸšª åŠ å…¥
            </button>
          </div>
        </div>
      </div>

      <!-- æˆ¿é–“è³‡è¨Šï¼ˆå»ºç«‹/åŠ å…¥å¾Œé¡¯ç¤ºï¼‰ -->
      <div id="roomInfo" style="display: none; text-align: center;">
        <div style="font-size: 14px; color: var(--muted); margin-bottom: 10px;">æˆ¿é–“ç¢¼</div>
        <div id="roomCodeDisplay" style="font-size: 32px; font-weight: bold; color: var(--gold); letter-spacing: 8px; margin-bottom: 10px;"></div>
        <div id="roomStatus" style="font-size: 14px; color: var(--green);">ç­‰å¾…å°æ‰‹åŠ å…¥...</div>
        <button onclick="leaveRoom()" style="margin-top: 15px; padding: 8px 16px; background: rgba(239,68,68,0.2); border: 1px solid var(--red); border-radius: 6px; color: var(--red); cursor: pointer;">é›¢é–‹æˆ¿é–“</button>
      </div>
    </div>
  </div>

  <!-- é»æ•¸ä¸Šé™è¨­å®š -->
  <div style="max-width: 600px; margin: 0 auto 20px; padding: 15px; background: rgba(251,191,36,0.1); border: 1px solid var(--gold); border-radius: 10px;">
    <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; justify-content: center;">
      <label style="font-weight: bold; color: var(--gold);">âš¡ é»æ•¸ä¸Šé™:</label>
      <input type="range" id="maxPointsSlider" min="500" max="3000" step="250" value="1000"
             onchange="updateMaxPoints(this.value)" style="flex: 1; min-width: 150px; max-width: 300px;">
      <span style="font-size: 20px; font-weight: bold; color: var(--gold); min-width: 80px;" id="maxPointsDisplay">1000</span>
      <select id="maxPointsPreset" onchange="setPointsPreset(this.value)" style="padding: 6px 10px; background: var(--panel); border: 1px solid var(--line); border-radius: 6px; color: var(--txt);">
        <option value="500">Combat Patrol (500)</option>
        <option value="1000" selected>Incursion (1000)</option>
        <option value="2000">Strike Force (2000)</option>
        <option value="3000">Onslaught (3000)</option>
      </select>
    </div>
  </div>

  <div class="setup-container">
    <!-- ç©å®¶ä¸€è»è¡¨ -->
    <div class="army-builder" id="army1Builder">
      <div class="army-header">
        <span class="army-title player1">ğŸ‘¤ <span id="p1ModeLabel">ç©å®¶ä¸€</span></span>
        <span class="points-display">é»æ•¸: <span id="p1Points">0</span> / <span class="max-pts">1000</span></span>
      </div>

      <div class="ai-toggle" style="margin-bottom: 12px; padding: 10px; background: rgba(59,130,246,0.1); border: 1px solid var(--blue); border-radius: 8px;">
        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
          <input type="checkbox" id="ai1ModeToggle" onchange="toggleAI1Mode()" style="width: 18px; height: 18px;">
          <span style="font-size: 14px; font-weight: bold; color: var(--blue);">ğŸ¤– AIæ§åˆ¶</span>
        </label>
        <div id="ai1DifficultyWrapper" style="margin-top: 8px; display: none;">
          <label style="font-size: 11px; color: var(--muted);">AI-1é›£åº¦ï¼š</label>
          <select id="ai1Difficulty" style="padding: 4px 8px; background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 4px; color: var(--txt); font-size: 12px;">
            <option value="easy">ç°¡å–® - éš¨æ©Ÿè¡Œå‹•</option>
            <option value="normal" selected>æ™®é€š - åŸºæœ¬ç­–ç•¥</option>
            <option value="hard">å›°é›£ - é€²éšç­–ç•¥</option>
          </select>
        </div>
      </div>

      <div class="faction-select">
        <label>é¸æ“‡é™£ç‡Ÿ</label>
        <select id="p1Faction" onchange="updateAvailableUnits(1); updateDetachmentOptions(1);">
          <option value="space-marines">æ˜Ÿéš›æˆ°å£« Adeptus Astartes</option>
          <option value="necrons">æ­»éˆ Necrons</option>
          <option value="tyranids">æ³°å€«èŸ²æ— Tyranids</option>
          <option value="chaos">æ··æ²Œæˆ°å£« Chaos Space Marines</option>
          <option value="orks">æ­å…‹è »äºº Orks</option>
        </select>
      </div>

      <div class="faction-select">
        <label>ç¨®æ—è¦å‰‡ Detachment</label>
        <select id="p1Detachment" onchange="selectDetachment(1)">
        </select>
        <div id="p1DetachmentDesc" style="font-size: 11px; color: var(--muted); margin-top: 6px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;"></div>
      </div>

      <!-- Meta è‡ªå‹•é…ç½®æŒ‰éˆ• -->
      <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
        <button onclick="autoConfigMeta(1)" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #667eea, #764ba2); border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 13px;">
          ğŸ† Metaé…ç½®
        </button>
        <button onclick="autoConfigBalanced(1)" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #11998e, #38ef7d); border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 13px;">
          âš–ï¸ å‡è¡¡é…ç½®
        </button>
        <button onclick="clearRoster(1)" style="padding: 10px 15px; background: rgba(239,68,68,0.2); border: 1px solid var(--red); border-radius: 8px; color: var(--red); font-weight: bold; cursor: pointer; font-size: 13px;">
          ğŸ—‘ï¸ æ¸…ç©º
        </button>
      </div>

      <div class="available-units">
        <h4>å¯ç”¨å–®ä½ï¼ˆé»æ“Šæ·»åŠ ï¼‰</h4>
        <div class="unit-grid" id="p1UnitGrid"></div>
      </div>

      <div class="selected-roster">
        <h4>å·²é¸å–®ä½</h4>
        <div id="p1Roster"></div>
      </div>
    </div>

    <!-- ç©å®¶äºŒè»è¡¨ -->
    <div class="army-builder" id="army2Builder">
      <div class="army-header">
        <span class="army-title player2">ğŸ¤– <span id="p2ModeLabel">ç©å®¶äºŒ</span></span>
        <span class="points-display">é»æ•¸: <span id="p2Points">0</span> / <span class="max-pts">1000</span></span>
      </div>

      <div class="ai-toggle" style="margin-bottom: 12px; padding: 10px; background: rgba(220,38,38,0.1); border: 1px solid var(--red); border-radius: 8px;">
        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
          <input type="checkbox" id="aiModeToggle" onchange="toggleAIMode()" checked style="width: 18px; height: 18px;">
          <span style="font-size: 14px; font-weight: bold; color: var(--red);">ğŸ¤– AIå°æ‰‹æ¨¡å¼</span>
        </label>
        <div style="margin-top: 8px;">
          <label style="font-size: 11px; color: var(--muted);">AIé›£åº¦ï¼š</label>
          <select id="aiDifficulty" style="padding: 4px 8px; background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 4px; color: var(--txt); font-size: 12px;">
            <option value="easy">ç°¡å–® - éš¨æ©Ÿè¡Œå‹•</option>
            <option value="normal" selected>æ™®é€š - åŸºæœ¬ç­–ç•¥</option>
            <option value="hard">å›°é›£ - é€²éšç­–ç•¥</option>
          </select>
        </div>
        <div style="margin-top: 8px;">
          <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 11px; color: var(--muted);">
            <input type="checkbox" id="diceAnimToggle" checked style="width: 14px; height: 14px;">
            <span>éª°å­å‹•ç•«ï¼ˆé—œé–‰å¯åŠ é€ŸAIå°æˆ°ï¼‰</span>
          </label>
        </div>
      </div>

      <div class="faction-select">
        <label>é¸æ“‡é™£ç‡Ÿ</label>
        <select id="p2Faction" onchange="updateAvailableUnits(2); updateDetachmentOptions(2);">
          <option value="necrons">æ­»éˆ Necrons</option>
          <option value="tyranids">æ³°å€«èŸ²æ— Tyranids</option>
          <option value="chaos">æ··æ²Œæˆ°å£« Chaos Space Marines</option>
          <option value="orks">æ­å…‹è »äºº Orks</option>
          <option value="space-marines">æ˜Ÿéš›æˆ°å£« Adeptus Astartes</option>
        </select>
      </div>

      <div class="faction-select">
        <label>ç¨®æ—è¦å‰‡ Detachment</label>
        <select id="p2Detachment" onchange="selectDetachment(2)">
        </select>
        <div id="p2DetachmentDesc" style="font-size: 11px; color: var(--muted); margin-top: 6px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px;"></div>
      </div>

      <!-- Meta è‡ªå‹•é…ç½®æŒ‰éˆ• -->
      <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
        <button onclick="autoConfigMeta(2)" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #667eea, #764ba2); border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 13px;">
          ğŸ† Metaé…ç½®
        </button>
        <button onclick="autoConfigBalanced(2)" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #11998e, #38ef7d); border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 13px;">
          âš–ï¸ å‡è¡¡é…ç½®
        </button>
        <button onclick="clearRoster(2)" style="padding: 10px 15px; background: rgba(239,68,68,0.2); border: 1px solid var(--red); border-radius: 8px; color: var(--red); font-weight: bold; cursor: pointer; font-size: 13px;">
          ğŸ—‘ï¸ æ¸…ç©º
        </button>
      </div>

      <div class="available-units">
        <h4>å¯ç”¨å–®ä½ï¼ˆé»æ“Šæ·»åŠ ï¼‰</h4>
        <div class="unit-grid" id="p2UnitGrid"></div>
      </div>

      <div class="selected-roster">
        <h4>å·²é¸å–®ä½</h4>
        <div id="p2Roster"></div>
      </div>
    </div>
  </div>

  <!-- æˆ°å ´è¨­å®š -->
  <div class="battlefield-settings" style="margin-top: 20px; padding: 16px; background: rgba(0,0,0,0.3); border: 1px solid var(--line); border-radius: 8px;">
    <h3 style="color: var(--gold); margin-bottom: 12px; font-size: 14px;">ğŸ—ºï¸ æˆ°å ´è¨­å®š</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
      <div class="faction-select">
        <label>æˆ°å ´å°ºå¯¸</label>
        <select id="battlefieldSize" onchange="updateBattlefieldPreview()">
          <option value="combat-patrol">Combat Patrol - 44" x 30" (å°å‹)</option>
          <option value="incursion">Incursion - 44" x 30"</option>
          <option value="strike-force" selected>Strike Force - 60" x 44" (æ¨™æº–)</option>
          <option value="onslaught">Onslaught - 90" x 44" (å¤§å‹)</option>
        </select>
        <div id="sizeDesc" style="font-size: 11px; color: var(--muted); margin-top: 4px;">æ¨™æº–å°æˆ°å°ºå¯¸ï¼Œé©åˆ 1000-2000 é»</div>
      </div>
      <div class="faction-select">
        <label>åœ°åœ–å ´æ™¯</label>
        <select id="mapScenario" onchange="updateBattlefieldPreview()">
          <option value="standard">æ¨™æº–æˆ°å ´ - å‡è¡¡åœ°å½¢</option>
          <option value="city">åŸå¸‚å»¢å¢Ÿ - å¤§é‡æ©é«”</option>
          <option value="forest">å¯†æ—åœ°å¸¶ - æ¨¹æ—ç‚ºä¸»</option>
          <option value="wasteland">è’é‡æˆ°å ´ - é–‹æ”¾å¹³åŸ</option>
          <option value="fortress">è¦å¡æ”»é˜² - é˜²ç¦¦å·¥äº‹</option>
          <option value="random">éš¨æ©Ÿç”Ÿæˆ</option>
        </select>
        <div id="mapDesc" style="font-size: 11px; color: var(--muted); margin-top: 4px;">å‡è¡¡é…ç½®çš„æ¨™æº–åœ°å½¢</div>
      </div>
    </div>
    <div id="battlefieldPreview" style="margin-top: 12px; padding: 10px; background: rgba(0,0,0,0.4); border-radius: 6px; text-align: center;">
      <canvas id="previewCanvas" width="300" height="200" style="border: 1px solid var(--line); border-radius: 4px;"></canvas>
      <div style="font-size: 11px; color: var(--muted); margin-top: 6px;">é è¦½ (æ¯”ä¾‹ç¸®å°)</div>
    </div>
  </div>

  <div class="terrain-legend">
    <h4>åœ°å½¢è¦å‰‡èªªæ˜ï¼ˆå®˜æ–¹10ç‰ˆï¼‰</h4>
    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
      <div class="terrain-item"><div class="terrain-color" style="background: #4a5568;"></div> å»¢å¢Ÿ Ruinsï¼šå®Œå…¨åœ¨å…§æˆ–ä¸å®Œå…¨å¯è¦‹æ™‚+1è­·ç”²è±å…</div>
      <div class="terrain-item"><div class="terrain-color" style="background: #2d5a27;"></div> æ¨¹æ— Woodsï¼šå®Œå…¨åœ¨å…§æˆ–ä¸å®Œå…¨å¯è¦‹æ™‚+1è­·ç”²è±å…</div>
      <div class="terrain-item"><div class="terrain-color" style="background: #78716c;"></div> éšœç¤™ç‰© Barricadesï¼š3"å…§ä¸”ä¸å®Œå…¨å¯è¦‹æ™‚+1è­·ç”²è±å…</div>
      <div class="terrain-item"><div class="terrain-color" style="background: #854d0e;"></div> å½ˆå‘ Cratersï¼šå®Œå…¨åœ¨å…§æ™‚+1è­·ç”²è±å…</div>
      <div class="terrain-item"><div class="terrain-color" style="background: #1e40af;"></div> å»ºç¯‰ç‰© Buildingsï¼šé˜»æ“‹è¦–ç·šï¼Œå¯æä¾›æ©è­·</div>
      <div class="terrain-item"><div class="terrain-color" style="background: #fbbf24;"></div> ç›®æ¨™é» Objectivesï¼š3"ç¯„åœå…§ä»¥OCå€¼è¨ˆç®—æ§åˆ¶</div>
    </div>
    <p style="margin-top: 8px; font-size: 11px; color: var(--muted);">
      <b>æ©è­·è¦å‰‡ï¼š</b>æ©è­·æä¾›+1è­·ç”²è±å…ï¼ˆå°é ç¨‹æ”»æ“Šï¼‰ã€‚è­·ç”²3+æˆ–æ›´å¥½çš„æ¨¡å‹é¢å°AP0æ­¦å™¨æ™‚ä¸é©ç”¨æ©è­·åŠ æˆã€‚
    </p>
    <p style="margin-top: 4px; font-size: 11px; color: var(--muted);">
      <b>å‚·å®³è¡¨ï¼š</b>Sâ‰¥2Ã—T=2+ | S>T=3+ | S=T=4+ | S<T=5+ | Sâ‰¤T/2=6+
    </p>
  </div>

  <div class="setup-actions">
    <button class="start-game-btn" id="startGameBtn" onclick="startBattle()" disabled>
      âš”ï¸ é–‹å§‹æˆ°é¬¥ âš”ï¸
    </button>
    <p style="color: var(--muted); margin-top: 10px; font-size: 12px;">é›™æ–¹éƒ½éœ€è¦è‡³å°‘é¸æ“‡ä¸€å€‹å–®ä½</p>
  </div>
</div>

<!-- ===== éŠæˆ²ç•«é¢ ===== -->
<div class="game-screen" id="gameScreen">
  <div class="game-header">
    <div class="game-title">âš”ï¸ æˆ°éš 40K - å›åˆ <span id="roundNum">1</span></div>
    <div class="phase-indicator">
      <div class="phase-pip" data-phase="deployment">éƒ¨ç½²</div>
      <div class="phase-pip" data-phase="command">æŒ‡æ®</div>
      <div class="phase-pip" data-phase="movement">ç§»å‹•</div>
      <div class="phase-pip" data-phase="shooting">å°„æ“Š</div>
      <div class="phase-pip" data-phase="charge">è¡é‹’</div>
      <div class="phase-pip" data-phase="fight">è¿‘æˆ°</div>
    </div>
    <div style="font-size: 12px;">
      ç•¶å‰: <span id="currentPlayerName" style="color: var(--gold);">ç©å®¶ä¸€</span>
      <span id="aiIndicator" style="margin-left: 8px; padding: 2px 6px; background: var(--red); border-radius: 4px; font-size: 10px; display: none;">ğŸ¤– AIæ¨¡å¼</span>
      <span id="currentDetachment" style="margin-left: 8px; padding: 2px 6px; background: var(--green); border-radius: 4px; font-size: 10px;"></span>
    </div>
  </div>

  <div class="game-main">
    <!-- Left: Units List -->
    <div class="units-panel">
      <div class="panel-header">
        <span id="team1Label">ç©å®¶ä¸€</span>
        <span style="color: var(--green);">VP: <span id="vp1Display">0</span></span>
      </div>
      <div class="units-list" id="team1List"></div>

      <div class="panel-header" style="border-top: 1px solid var(--line);">
        <span id="team2Label">ç©å®¶äºŒ</span>
        <span style="color: var(--red);">VP: <span id="vp2Display">0</span></span>
      </div>
      <div class="units-list" id="team2List"></div>
    </div>

    <!-- Center: Battlefield -->
    <div class="battlefield-container">
      <div class="battlefield-toolbar">
        <button class="toolbar-btn success" id="btnStartRound" onclick="finishDeploymentAndStart()" style="display:none;">é–‹å§‹å›åˆ â–¶</button>
        <button class="toolbar-btn" id="btnSwitchDeploy" onclick="switchDeploySide()" style="display:none;">åˆ‡æ›éƒ¨ç½²æ–¹</button>
        <button class="toolbar-btn primary" id="btnNextPhase" onclick="nextPhase()">ä¸‹ä¸€éšæ®µ â–¶</button>
        <button class="toolbar-btn" id="btnMove" onclick="setAction('move')" disabled>ç§»å‹•</button>
        <button class="toolbar-btn" id="btnAdvance" onclick="setAction('advance')" disabled style="background: #228855;">ğŸƒ æ€¥è¡Œ</button>
        <button class="toolbar-btn" id="btnFallBack" onclick="setAction('fallback')" disabled style="background: #885522;">ğŸ”™ æ’¤é€€</button>
        <button class="toolbar-btn" id="btnDeepStrike" onclick="setAction('deepstrike')" disabled style="background: #6622aa;">ğŸ“¡ æ·±å…¥æ‰“æ“Š</button>
        <button class="toolbar-btn" id="btnEmbark" onclick="setAction('embark')" disabled style="background: #447799; display: none;">ğŸš æ­è¼‰</button>
        <button class="toolbar-btn" id="btnDisembark" onclick="setAction('disembark')" disabled style="background: #774499; display: none;">ğŸšª ä¸‹è»Š</button>
        <button class="toolbar-btn" id="btnHover" onclick="toggleSelectedUnitHover()" disabled style="background: #338899; display: none;">ğŸš æ‡¸åœ</button>
        <button class="toolbar-btn" id="btnShoot" onclick="setAction('shoot')" disabled>å°„æ“Š</button>
        <button class="toolbar-btn" id="btnCharge" onclick="setAction('charge')" disabled>è¡é‹’</button>
        <button class="toolbar-btn" id="btnFight" onclick="setAction('fight')" disabled>è¿‘æˆ°</button>
        <button class="toolbar-btn danger" id="btnConfirmAttack" onclick="confirmAttack()" style="display:none;">âš”ï¸ ç¢ºèªæ”»æ“Š</button>
        <button class="toolbar-btn" id="btnReroll" onclick="useCommandReroll()" disabled title="èŠ±è²»1CPé‡æ“²ä¸€é¡†éª°å­">ğŸ² æŒ‡æ®é‡æ“²</button>
        <span style="font-size: 11px; color: var(--gold); margin-left: 4px;">CP: <b id="cpDisplay">0</b></span>
        <button class="toolbar-btn danger" id="btnEndTurn" onclick="endTurn()">çµæŸå›åˆ</button>
        <div style="display: flex; align-items: center; gap: 6px; margin-left: 10px; padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 6px;">
          <span style="font-size: 16px; cursor: pointer;" onclick="toggleMute()" id="soundIcon">ğŸ”Š</span>
          <input type="range" id="volumeSlider" min="0" max="100" value="50"
            style="width: 60px; height: 4px; cursor: pointer; accent-color: var(--gold);"
            oninput="setVolume(this.value)" title="éŸ³é‡èª¿ç¯€">
          <span style="font-size: 10px; color: var(--muted); min-width: 28px;" id="volumeDisplay">50%</span>
        </div>
        <div style="display: flex; align-items: center; gap: 4px; margin-left: 10px; padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 6px;">
          <button onclick="zoomOut()" style="width: 24px; height: 24px; background: var(--panel); border: 1px solid var(--line); border-radius: 4px; color: var(--txt); cursor: pointer; font-size: 14px;" title="ç¸®å°">âˆ’</button>
          <span style="font-size: 10px; color: var(--muted); min-width: 36px; text-align: center;" id="zoomDisplay">100%</span>
          <button onclick="zoomIn()" style="width: 24px; height: 24px; background: var(--panel); border: 1px solid var(--line); border-radius: 4px; color: var(--txt); cursor: pointer; font-size: 14px;" title="æ”¾å¤§">+</button>
          <button onclick="zoomReset()" style="padding: 2px 6px; background: var(--panel); border: 1px solid var(--line); border-radius: 4px; color: var(--txt); cursor: pointer; font-size: 10px;" title="é‡ç½®ç¸®æ”¾">é‡ç½®</button>
        </div>
        <div class="action-hint" id="actionHint">é¸æ“‡ä¸€å€‹å–®ä½é–‹å§‹è¡Œå‹•</div>
      </div>
      <div class="battlefield-wrap">
        <canvas id="gameCanvas"></canvas>
      </div>
    </div>

    <!-- Right: Info Panel -->
    <div class="info-panel">
      <div class="selected-unit-info" id="selectedUnitInfo">
        <p style="color: var(--muted); text-align: center; padding: 20px;">é»æ“Šå–®ä½æŸ¥çœ‹è©³ç´°è³‡è¨Š</p>
      </div>

      <div class="panel-header" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
        <span onclick="toggleCombatLog()" style="flex: 1;">æˆ°é¬¥æ—¥èªŒ</span>
        <button onclick="clearCombatLog(); event.stopPropagation();" style="padding: 2px 6px; font-size: 9px; background: var(--red); border: none; color: white; border-radius: 3px; cursor: pointer; margin-right: 8px;" title="æ¸…ç©ºæ—¥èªŒ">ğŸ—‘ï¸</button>
        <span id="combatLogToggle" style="font-size: 10px;" onclick="toggleCombatLog()">â–¼</span>
      </div>
      <div class="combat-log" id="combatLogContainer">
        <div class="log-content" id="logContent"></div>
      </div>

      <!-- æˆ°ç•¥é¢æ¿ -->
      <div class="panel-header" style="cursor: pointer;" onclick="toggleStratagemPanel()">
        ğŸ´ æˆ°ç•¥ (Stratagems) <span id="stratagemToggle">â–¼</span>
      </div>
      <div id="stratagemPanel" style="max-height: 150px; overflow-y: auto; margin-bottom: 10px; display: none;">
        <div id="stratagemList" style="font-size: 11px; color: var(--txt);">
          <p style="color: var(--muted); padding: 8px;">é–‹å§‹éŠæˆ²å¾Œé¡¯ç¤ºå¯ç”¨æˆ°ç•¥</p>
        </div>
      </div>

      <!-- ä»»å‹™é¢æ¿ -->
      <div class="panel-header" style="cursor: pointer;" onclick="toggleMissionPanel()">
        ğŸ“‹ ä»»å‹™ (Missions) <span id="missionToggle">â–¼</span>
      </div>
      <div id="missionPanel" style="max-height: 200px; overflow-y: auto; margin-bottom: 10px; display: none;">
        <div id="missionContent" style="font-size: 11px; color: var(--txt); padding: 8px;">
          <p style="color: var(--muted);">é–‹å§‹éŠæˆ²å¾Œé¡¯ç¤ºä»»å‹™</p>
        </div>
      </div>

      <div class="score-bar">
        <div class="score-item">
          <div class="score-label">å›åˆ</div>
          <div class="score-value" id="roundDisplay">1</div>
        </div>
        <div class="score-item">
          <div class="score-label">ç©å®¶ä¸€ VP</div>
          <div class="score-value" style="color: var(--blue);" id="p1VPDisplay">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">ç©å®¶äºŒ VP</div>
          <div class="score-value" style="color: var(--red);" id="p2VPDisplay">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">ç©å®¶ä¸€ CP</div>
          <div class="score-value" style="color: var(--blue);" id="p1CPDisplay">0</div>
        </div>
        <div class="score-item">
          <div class="score-label">ç©å®¶äºŒ CP</div>
          <div class="score-value" style="color: var(--red);" id="p2CPDisplay">0</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- éª°å­è¦–è¦ºåŒ–è¦†è“‹å±¤ -->
<div class="dice-overlay" id="diceOverlay">
  <div class="dice-title" id="diceTitle">å‘½ä¸­æ“²éª°</div>
  <div class="dice-container" id="diceContainer"></div>
  <div class="dice-result" id="diceResult"></div>
  <button id="diceRollBtn" class="dice-roll-btn" style="display: none; margin-top: 15px; padding: 12px 40px; font-size: 16px; font-weight: bold; background: linear-gradient(135deg, var(--gold), #d97706); border: none; border-radius: 8px; color: #000; cursor: pointer; animation: pulse 1s infinite;">ğŸ² æ“²éª°</button>
</div>

<!-- æ­¦å™¨é¸æ“‡å½ˆçª— -->
<div class="dice-overlay" id="weaponPopup" style="display: none;">
  <div style="background: rgba(20,20,30,0.98); border: 2px solid var(--gold); border-radius: 12px; padding: 20px; max-width: 450px; max-height: 80vh; overflow-y: auto;">
    <div style="font-size: 18px; font-weight: bold; color: var(--gold); margin-bottom: 15px;">âš”ï¸ é¸æ“‡æ­¦å™¨</div>
    <div id="weaponPopupInfo" style="font-size: 12px; color: var(--muted); margin-bottom: 15px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 6px;"></div>
    <div id="weaponPopupList" style="display: flex; flex-direction: column; gap: 8px;"></div>
    <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: center;">
      <button onclick="closeWeaponPopup()" style="padding: 10px 30px; background: rgba(100,100,100,0.3); border: 1px solid var(--line); border-radius: 8px; color: var(--txt); cursor: pointer; font-size: 14px;">å–æ¶ˆ</button>
    </div>
  </div>
</div>

<!-- æˆ°ç•¥é¸æ“‡å½ˆçª— -->
<div class="dice-overlay" id="stratagemPopup" style="display: none;">
  <div style="background: rgba(20,20,30,0.98); border: 2px solid var(--gold); border-radius: 12px; padding: 20px; max-width: 500px; max-height: 80vh; overflow-y: auto;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
      <div style="font-size: 18px; font-weight: bold; color: var(--gold);">ğŸ´ <span id="stratagemPopupTitle">é¸æ“‡æˆ°ç•¥</span></div>
      <div style="font-size: 14px; color: var(--muted);">CP: <span id="stratagemPopupCP" style="color: var(--green); font-weight: bold;">0</span></div>
    </div>
    <div id="stratagemPopupPhase" style="font-size: 12px; color: var(--muted); margin-bottom: 15px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 6px;"></div>
    <div id="stratagemPopupList" style="display: flex; flex-direction: column; gap: 8px;"></div>
    <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: center;">
      <button onclick="closeStratagemPopup()" style="padding: 10px 30px; background: rgba(100,100,100,0.3); border: 1px solid var(--line); border-radius: 8px; color: var(--txt); cursor: pointer; font-size: 14px;">è·³é (ä¸ä½¿ç”¨æˆ°ç•¥)</button>
    </div>
  </div>
</div>

<script>
// ========== Firebase é€£ç·šç³»çµ± ==========
const firebaseConfig = {
  apiKey: "AIzaSyBfrS-b2dpZUt8yJvSYKDap0AjZsy8UJ0I",
  authDomain: "wh40k-game.firebaseapp.com",
  databaseURL: "https://wh40k-game-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "wh40k-game",
  storageBucket: "wh40k-game.firebasestorage.app",
  messagingSenderId: "1074789310261",
  appId: "1:1074789310261:web:4a1a81a63ef48e0589f67c"
};

// åˆå§‹åŒ– Firebase
firebase.initializeApp(firebaseConfig);
const database = firebase.database();

// é€£ç·šç‹€æ…‹
let isOnlineMode = false;
let currentRoomCode = null;
let isHost = false;  // æˆ¿ä¸» = ç©å®¶1
let onlinePlayerId = null;  // 1 æˆ– 2
let roomRef = null;
let gameStateRef = null;
let lastDiceTimestamp = 0;  // éª°å­åŒæ­¥æ™‚é–“æˆ³
let lastLogTimestamp = 0;   // ç´€éŒ„åŒæ­¥æ™‚é–“æˆ³
let lastActionTimestamp = 0;  // å‹•ä½œåŒæ­¥æ™‚é–“æˆ³
let lastGameStateTimestamp = 0;  // éŠæˆ²ç‹€æ…‹åŒæ­¥æ™‚é–“æˆ³
let gameInitialized = false;  // éŠæˆ²æ˜¯å¦å·²åˆå§‹åŒ–å®Œæˆ
let turnInProgress = false;  // é˜²æ­¢é‡è¤‡è§¸ç™¼å›åˆ
let lastProcessedRound = 0;  // ä¸Šæ¬¡è™•ç†çš„å›åˆ
let lastProcessedPlayer = 0;  // ä¸Šæ¬¡è™•ç†çš„ç©å®¶
let lastSyncToFirebaseTime = 0;  // ä¸Šæ¬¡åŒæ­¥åˆ°Firebaseçš„æ™‚é–“
const SYNC_THROTTLE_MS = 100;  // åŒæ­¥ç¯€æµé–“éš”ï¼ˆæ¯«ç§’ï¼‰

// ç”¢ç”Ÿéš¨æ©Ÿæˆ¿é–“ç¢¼
function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 6; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

// åˆ‡æ›éŠæˆ²æ¨¡å¼
function switchGameMode(mode) {
  isOnlineMode = (mode === 'online');
  document.getElementById('onlinePanel').style.display = isOnlineMode ? 'block' : 'none';

  const army1Builder = document.getElementById('army1Builder');
  const army2Builder = document.getElementById('army2Builder');

  // ç·šä¸Šæ¨¡å¼è¨­å®š
  if (isOnlineMode) {
    // æç¤ºï¼šå…ˆå»ºç«‹/åŠ å…¥æˆ¿é–“
    document.getElementById('p1ModeLabel').textContent = 'ç©å®¶ä¸€ï¼ˆæˆ¿ä¸»ï¼‰';
    document.getElementById('p2ModeLabel').textContent = 'ç©å®¶äºŒï¼ˆåŠ å…¥è€…ï¼‰';
  } else {
    // æœ¬åœ°æ¨¡å¼ï¼šæ¢å¾©æ­£å¸¸
    document.getElementById('p1ModeLabel').textContent = 'ç©å®¶ä¸€';
    document.getElementById('p2ModeLabel').textContent = 'ç©å®¶äºŒ';
    army1Builder.style.opacity = '1';
    army1Builder.style.pointerEvents = 'auto';
    army2Builder.style.opacity = '1';
    army2Builder.style.pointerEvents = 'auto';
  }
}

// æ ¹æ“šç©å®¶èº«ä»½é¡¯ç¤ºå°æ‡‰çš„è¨­å®šå€
function updateOnlineSetupUI() {
  if (!isOnlineMode) return;

  const army1Builder = document.getElementById('army1Builder');
  const army2Builder = document.getElementById('army2Builder');

  if (onlinePlayerId === 1) {
    // æˆ¿ä¸»ï¼šåªèƒ½ç·¨è¼¯ç©å®¶ä¸€
    army1Builder.style.opacity = '1';
    army1Builder.style.pointerEvents = 'auto';
    army2Builder.style.opacity = '0.5';
    army2Builder.style.pointerEvents = 'none';
    document.getElementById('p1ModeLabel').textContent = 'ğŸ‘¤ ä½ çš„è»éšŠ';
    document.getElementById('p2ModeLabel').textContent = 'â³ ç­‰å¾…å°æ‰‹...';
  } else if (onlinePlayerId === 2) {
    // åŠ å…¥è€…ï¼šåªèƒ½ç·¨è¼¯ç©å®¶äºŒ
    army1Builder.style.opacity = '0.5';
    army1Builder.style.pointerEvents = 'none';
    army2Builder.style.opacity = '1';
    army2Builder.style.pointerEvents = 'auto';
    document.getElementById('p1ModeLabel').textContent = 'ğŸ‘‘ å°æ‰‹è»éšŠ';
    document.getElementById('p2ModeLabel').textContent = 'ğŸ‘¤ ä½ çš„è»éšŠ';
  }
}

// å»ºç«‹æˆ¿é–“
async function createRoom() {
  currentRoomCode = generateRoomCode();
  isHost = true;
  onlinePlayerId = 1;
  isOnlineMode = true;  // ç¢ºä¿è¨­ç‚ºç·šä¸Šæ¨¡å¼
  console.warn('[createRoom] å»ºç«‹æˆ¿é–“:', { currentRoomCode, isHost, onlinePlayerId, isOnlineMode });

  roomRef = database.ref('rooms/' + currentRoomCode);

  // å»ºç«‹æˆ¿é–“è³‡æ–™
  await roomRef.set({
    host: onlinePlayerId,
    status: 'waiting',
    createdAt: firebase.database.ServerValue.TIMESTAMP,
    players: {
      1: { ready: false, faction: document.getElementById('p1Faction').value }
    }
  });

  // ç›£è½æˆ¿é–“ç‹€æ…‹
  listenToRoom();

  // æ›´æ–°UI
  document.getElementById('roomLobby').style.display = 'none';
  document.getElementById('roomInfo').style.display = 'block';
  document.getElementById('roomCodeDisplay').textContent = currentRoomCode;
  document.getElementById('roomStatus').textContent = 'ç­‰å¾…å°æ‰‹åŠ å…¥...';
  document.getElementById('roomStatus').style.color = 'var(--gold)';

  // æ›´æ–°è»éšŠè¨­å®šUI
  updateOnlineSetupUI();

  // æ›´æ–°é–‹å§‹æŒ‰éˆ•
  checkStartButton();

  // æˆ¿é–“æ¸…ç†ï¼ˆæ–·ç·šæ™‚åˆªé™¤ï¼‰
  roomRef.onDisconnect().remove();

  log('æˆ¿é–“å·²å»ºç«‹: ' + currentRoomCode, 'info');
}

// åŠ å…¥æˆ¿é–“
async function joinRoom() {
  const code = document.getElementById('joinRoomCode').value.toUpperCase().trim();
  if (code.length !== 6) {
    alert('è«‹è¼¸å…¥6ä½æˆ¿é–“ç¢¼');
    return;
  }

  currentRoomCode = code;
  roomRef = database.ref('rooms/' + currentRoomCode);

  // æª¢æŸ¥æˆ¿é–“æ˜¯å¦å­˜åœ¨
  const snapshot = await roomRef.once('value');
  if (!snapshot.exists()) {
    alert('æ‰¾ä¸åˆ°æ­¤æˆ¿é–“');
    return;
  }

  const roomData = snapshot.val();
  if (roomData.status !== 'waiting') {
    alert('æ­¤æˆ¿é–“å·²é–‹å§‹éŠæˆ²');
    return;
  }

  isHost = false;
  onlinePlayerId = 2;
  isOnlineMode = true;  // ç¢ºä¿è¨­ç‚ºç·šä¸Šæ¨¡å¼
  console.warn('[joinRoom] åŠ å…¥æˆ¿é–“:', { currentRoomCode, isHost, onlinePlayerId, isOnlineMode });

  // åŠ å…¥æˆ¿é–“
  await roomRef.child('players/2').set({
    ready: false,
    faction: document.getElementById('p2Faction').value
  });
  await roomRef.child('status').set('ready');

  // ç›£è½æˆ¿é–“ç‹€æ…‹
  listenToRoom();

  // æ›´æ–°UI
  document.getElementById('roomLobby').style.display = 'none';
  document.getElementById('roomInfo').style.display = 'block';
  document.getElementById('roomCodeDisplay').textContent = currentRoomCode;
  document.getElementById('roomStatus').textContent = 'å·²é€£æ¥ï¼ç­‰å¾…æˆ¿ä¸»é–‹å§‹...';
  document.getElementById('roomStatus').style.color = 'var(--green)';

  // æ›´æ–°è»éšŠè¨­å®šUI
  updateOnlineSetupUI();

  log('å·²åŠ å…¥æˆ¿é–“: ' + currentRoomCode, 'info');
}

// ç›£è½æˆ¿é–“ç‹€æ…‹
function listenToRoom() {
  if (!roomRef) return;

  roomRef.on('value', (snapshot) => {
    const data = snapshot.val();
    if (!data) {
      // æˆ¿é–“è¢«åˆªé™¤
      alert('æˆ¿é–“å·²é—œé–‰');
      leaveRoom();
      return;
    }

    // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
    if (data.status === 'ready' && isHost) {
      document.getElementById('roomStatus').textContent = 'å°æ‰‹å·²åŠ å…¥ï¼å¯ä»¥é–‹å§‹éŠæˆ²';
      document.getElementById('roomStatus').style.color = 'var(--green)';
      // æ›´æ–°é–‹å§‹æŒ‰éˆ•ç‹€æ…‹
      checkStartButton();
    }

    // å³æ™‚é¡¯ç¤ºå°æ‰‹çš„è»éšŠé…ç½®ï¼ˆè¨­å®šéšæ®µï¼‰
    const setupScreenEl = document.getElementById('setupScreen');
    console.log('[listenToRoom] å®Œæ•´è³‡æ–™:', JSON.stringify(data, null, 2));
    console.log('[listenToRoom] æ”¶åˆ°è³‡æ–™:', { hasArmies: !!data.armies, armies: data.armies, isHost, setupVisible: setupScreenEl?.style.display });
    if (setupScreenEl && setupScreenEl.style.display !== 'none' && data.armies) {
      const opponentId = isHost ? 2 : 1;
      console.log('[listenToRoom] æª¢æŸ¥å°æ‰‹è»éšŠ:', opponentId, data.armies[opponentId]);
      if (data.armies[opponentId] && data.armies[opponentId].roster) {
        console.log('[listenToRoom] é¡¯ç¤ºå°æ‰‹è»éšŠ:', data.armies[opponentId].roster.length, 'å€‹å–®ä½');
        displayOpponentArmy(opponentId, data.armies[opponentId]);
      }
    }

    // éŠæˆ²é–‹å§‹ - éæˆ¿ä¸»æ”¶åˆ°é–‹å§‹è¨Šè™Ÿ
    if (data.gameStarted && !isHost) {
      if (setupScreenEl && setupScreenEl.style.display !== 'none') {
        // ç¢ºä¿è‡ªå·±çš„è»éšŠå·²åŒæ­¥ï¼ˆä»¥é˜²è¬ä¸€ï¼‰
        syncArmyToFirebase(2);

        // è¼‰å…¥æˆ¿ä¸»çš„æˆ°å ´è¨­å®šå’Œè»éšŠ
        const loadPromises = [
          roomRef.child('armies/1').once('value'),
          roomRef.child('battlefieldSettings').once('value')
        ];

        Promise.all(loadPromises).then(([armySnapshot, settingsSnapshot]) => {
          // è¼‰å…¥æˆ¿ä¸»è»éšŠ
          if (armySnapshot.exists()) {
            const hostArmy = armySnapshot.val();
            loadEnemyArmy(hostArmy, 1);
          }

          // ä½¿ç”¨æˆ¿ä¸»çš„æˆ°å ´è¨­å®š
          if (settingsSnapshot.exists()) {
            const settings = settingsSnapshot.val();
            selectedBattlefieldSize = settings.size || selectedBattlefieldSize;
            selectedMapScenario = settings.map || selectedMapScenario;
            console.warn('[Player 2] ä½¿ç”¨æˆ¿ä¸»æˆ°å ´è¨­å®š:', settings);
          }

          // é–‹å§‹éŠæˆ²
          document.getElementById("setupScreen").style.display = "none";
          document.getElementById("gameScreen").classList.add("active");
          resizeCanvas();
          initBattlefield();
          gameInitialized = true;  // æ¨™è¨˜éŠæˆ²å·²åˆå§‹åŒ–å®Œæˆ
          console.warn('[Player 2] éŠæˆ²åˆå§‹åŒ–å®Œæˆï¼Œå–®ä½æ•¸é‡:', gameState.units.length);

          // åˆå§‹åŒ–éƒ¨ç½²ç‹€æ…‹ï¼ˆèˆ‡ startDeployPhase ä¸€è‡´ï¼‰
          gameState.phase = "deployment";
          gameState.round = 1;
          gameState.currentPlayer = 1;
          gameState.deploy = {
            deployingPlayer: 1,
            p1Deployed: false,
            p2Deployed: false
          };

          log('=== æˆ¿ä¸»å·²é–‹å§‹éŠæˆ² ===', 'phase');
          log('=== éƒ¨ç½²éšæ®µ ===', 'phase');
          log('è«‹åœ¨å³å´éƒ¨ç½²å€éƒ¨ç½²ä½ çš„å–®ä½', 'info');
          updatePhaseDisplay();
          updateDeployButtons();
          updateCPDisplay();
          updateUnitLists();
          render();
        });
      }
    }

    // åŒæ­¥éª°å­å‹•ç•«
    if (data.diceRoll && data.diceRoll.timestamp !== lastDiceTimestamp) {
      lastDiceTimestamp = data.diceRoll.timestamp;
      showRemoteDice(data.diceRoll);
    }

    // åŒæ­¥æˆ°é¬¥ç´€éŒ„
    if (data.combatLog && data.combatLog.timestamp !== lastLogTimestamp) {
      lastLogTimestamp = data.combatLog.timestamp;
      log(data.combatLog.message, data.combatLog.type, false);  // false é˜²æ­¢é‡è¤‡åŒæ­¥
    }

    // åŒæ­¥è¦–è¦ºæ•ˆæœ
    if (data.visualEffect && data.visualEffect.timestamp !== lastEffectTimestamp) {
      lastEffectTimestamp = data.visualEffect.timestamp;
      handleRemoteVisualEffect(data.visualEffect);
    }

    // åŒæ­¥éŠæˆ²ç‹€æ…‹ï¼ˆé›™æ–¹éƒ½éœ€è¦æ¥æ”¶å°æ–¹çš„æ›´æ–°ï¼‰
    // éæˆ¿ä¸»éœ€è¦ç­‰å¾…éŠæˆ²åˆå§‹åŒ–å®Œæˆæ‰èƒ½è™•ç†
    if (data.status === 'playing' && data.gameState) {
      // æª¢æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°ï¼ˆæ™‚é–“æˆ³ä¸åŒæˆ–ç¬¬ä¸€æ¬¡æ”¶åˆ°ï¼‰
      const shouldSync = data.gameState.timestamp !== lastGameStateTimestamp;

      if (!isHost && !gameInitialized) {
        console.log('[listenToRoom] ç­‰å¾…éŠæˆ²åˆå§‹åŒ–å®Œæˆ...');
      } else if (shouldSync) {
        lastGameStateTimestamp = data.gameState.timestamp;
        console.warn('[listenToRoom] åŒæ­¥éŠæˆ²ç‹€æ…‹:', {
          phase: data.gameState.phase,
          currentPlayer: data.gameState.currentPlayer,
          myId: onlinePlayerId,
          timestamp: data.gameState.timestamp,
          unitsCount: data.gameState.units ? data.gameState.units.length : 0,
          deployedUnits: data.gameState.units ? data.gameState.units.filter(u => u.deployed).length : 0
        });
        syncGameStateFromFirebase(data.gameState);
      }
    }

    // ç›£è½éŠæˆ²å‹•ä½œ - è™•ç†ä¾†è‡ªå°æ‰‹çš„å‹•ä½œ
    // æ³¨æ„ï¼šaction å’Œ gameState å¯èƒ½åŒæ™‚åˆ°é”ï¼Œå…©è€…éƒ½è¦è™•ç†
    if (data.lastAction && data.lastAction.player !== onlinePlayerId) {
      const shouldHandle = data.lastAction.timestamp !== lastActionTimestamp;

      if (!isHost && !gameInitialized) {
        console.log('[listenToRoom] å‹•ä½œç­‰å¾…éŠæˆ²åˆå§‹åŒ–...');
      } else if (shouldHandle) {
        lastActionTimestamp = data.lastAction.timestamp;
        console.warn('[listenToRoom] æ”¶åˆ°é ç«¯å‹•ä½œ:', data.lastAction);
        handleRemoteAction(data.lastAction);
      }
    }
  });
}

// é›¢é–‹æˆ¿é–“
function leaveRoom() {
  if (roomRef) {
    if (isHost) {
      roomRef.remove();
    } else {
      roomRef.child('players/2').remove();
      roomRef.child('status').set('waiting');
    }
    roomRef.off();
    roomRef = null;
  }

  currentRoomCode = null;
  isHost = false;
  onlinePlayerId = null;

  document.getElementById('roomLobby').style.display = 'block';
  document.getElementById('roomInfo').style.display = 'none';
  document.getElementById('joinRoomCode').value = '';
}

// åŒæ­¥éŠæˆ²ç‹€æ…‹åˆ° Firebase
function syncGameStateToFirebase() {
  if (!isOnlineMode || !roomRef) return;

  // é˜²æ­¢åŒæ­¥ç©ºçš„å–®ä½é™£åˆ—ï¼ˆç„¡æ•ˆç‹€æ…‹ï¼‰
  if (!gameState.units || gameState.units.length === 0) {
    console.warn('[syncGameStateToFirebase] è·³éåŒæ­¥ï¼šå–®ä½é™£åˆ—ç‚ºç©º');
    return;
  }

  // å–å¾—æœ¬åœ°æˆ°å ´å°ºå¯¸ç”¨æ–¼è¨ˆç®—ç›¸å°åº§æ¨™
  const localW = gameState.canvasWidth || 600;
  const localH = gameState.canvasHeight || 440;

  const stateToSync = {
    phase: gameState.phase,
    round: gameState.round,
    currentPlayer: gameState.currentPlayer,
    // ä½¿ç”¨ç›¸å°åº§æ¨™ï¼ˆç™¾åˆ†æ¯”ï¼‰åŒæ­¥å–®ä½ä½ç½®
    units: gameState.units.map(u => ({
      id: u.id,
      xPercent: u.x / localW,  // ç›¸å°Xåº§æ¨™ (0-1)
      yPercent: u.y / localH,  // ç›¸å°Yåº§æ¨™ (0-1)
      currentHP: u.currentHP,
      maxHP: u.maxHP,
      alive: u.alive,
      deployed: u.deployed,
      visible: u.visible !== false,
      hasMoved: u.hasMoved,
      hasShot: u.hasShot,
      hasCharged: u.hasCharged,
      hasFought: u.hasFought,
      battleShocked: u.battleShocked || false,
      inCover: u.inCover || false,
      usedOneUseWeapons: u.usedOneUseWeapons || [],
      activeStratagemEffects: u.activeStratagemEffects || [],
      battleHistory: u.battleHistory || [],
      // é‹è¼¸è¼‰å…·åŒæ­¥
      embarkedIn: u.embarkedIn || null,
      embarkedUnits: u.embarkedUnits || [],
      // é£›è¡Œå™¨åŒæ­¥
      isHovering: u.isHovering || false,
      inReserves: u.inReserves || false
    })),
    vp: gameState.vp,
    cp: gameState.cp,
    objectives: gameState.objectives,
    deploy: gameState.deploy || { deployingPlayer: 1, p1Deployed: false, p2Deployed: false },
    // ä»»å‹™ç³»çµ±åŒæ­¥
    primaryMission: gameState.primaryMission || null,
    secondaryMissions: gameState.secondaryMissions || { 1: [], 2: [] },
    missionProgress: gameState.missionProgress || { 1: {}, 2: {} },
    timestamp: Date.now()
  };

  roomRef.child('gameState').set(stateToSync);
}

// å¾ Firebase åŒæ­¥éŠæˆ²ç‹€æ…‹
function syncGameStateFromFirebase(remoteState) {
  if (!remoteState) return;

  // é©—è­‰é ç«¯ç‹€æ…‹æœ‰æ•ˆæ€§
  if (!remoteState.units || remoteState.units.length === 0) {
    console.warn('[syncGameStateFromFirebase] è·³éåŒæ­¥ï¼šé ç«¯å–®ä½é™£åˆ—ç‚ºç©ºæˆ–ç„¡æ•ˆ');
    return;
  }

  // ç¢ºä¿æœ¬åœ°æœ‰å–®ä½æ‰é€²è¡ŒåŒæ­¥
  if (!gameState.units || gameState.units.length === 0) {
    console.warn('[syncGameStateFromFirebase] è·³éåŒæ­¥ï¼šæœ¬åœ°å–®ä½é™£åˆ—ç‚ºç©º');
    return;
  }

  gameState.phase = remoteState.phase;
  gameState.round = remoteState.round;
  gameState.currentPlayer = remoteState.currentPlayer;

  // VP å’Œ CP åªå–è¼ƒå¤§å€¼ï¼Œé˜²æ­¢è¢«è¼ƒèˆŠçš„ç‹€æ…‹è¦†è“‹
  if (remoteState.vp) {
    gameState.vp[1] = Math.max(gameState.vp[1] || 0, remoteState.vp[1] || 0);
    gameState.vp[2] = Math.max(gameState.vp[2] || 0, remoteState.vp[2] || 0);
  }
  if (remoteState.cp) {
    // CP å¯èƒ½æœƒæ¶ˆè€—ï¼Œæ‰€ä»¥é€™è£¡è¦ç‰¹æ®Šè™•ç†ï¼šå–é ç«¯å€¼ï¼ˆå‡è¨­é ç«¯æ˜¯è¼ƒæ–°çš„ï¼‰
    gameState.cp = remoteState.cp;
  }
  if (remoteState.deploy) {
    gameState.deploy = remoteState.deploy;
  }

  // ä»»å‹™ç³»çµ±åŒæ­¥
  if (remoteState.primaryMission) {
    gameState.primaryMission = remoteState.primaryMission;
  }
  if (remoteState.secondaryMissions) {
    gameState.secondaryMissions = remoteState.secondaryMissions;
  }
  if (remoteState.missionProgress) {
    gameState.missionProgress = remoteState.missionProgress;
  }

  // å–å¾—æœ¬åœ°æˆ°å ´å°ºå¯¸ç”¨æ–¼åº§æ¨™è½‰æ›
  const localW = gameState.canvasWidth || 600;
  const localH = gameState.canvasHeight || 440;

  // åŒæ­¥å–®ä½ç‹€æ…‹ï¼ˆä½¿ç”¨ç›¸å°åº§æ¨™è½‰æ›ç‚ºæœ¬åœ°åº§æ¨™ï¼‰
  if (remoteState.units && Array.isArray(remoteState.units)) {
    let syncedCount = 0;
    let missingCount = 0;

    remoteState.units.forEach(remoteUnit => {
      if (!remoteUnit || !remoteUnit.id) return;  // è·³éç„¡æ•ˆå–®ä½

      const localUnit = gameState.units.find(u => u.id === remoteUnit.id);
      if (localUnit) {
        // å°‡ç›¸å°åº§æ¨™è½‰æ›ç‚ºæœ¬åœ°åƒç´ åº§æ¨™ï¼ˆç¢ºä¿åº§æ¨™æœ‰æ•ˆï¼‰
        if (typeof remoteUnit.xPercent === 'number' && typeof remoteUnit.yPercent === 'number') {
          const newX = remoteUnit.xPercent * localW;
          const newY = remoteUnit.yPercent * localH;
          // åªæœ‰åº§æ¨™æœ‰æ•ˆæ™‚æ‰æ›´æ–°
          if (isFinite(newX) && isFinite(newY) && newX >= 0 && newY >= 0) {
            localUnit.x = newX;
            localUnit.y = newY;
          }
        } else if (typeof remoteUnit.x === 'number' && typeof remoteUnit.y === 'number') {
          // å‘å¾Œå…¼å®¹ï¼šå¦‚æœé‚„æ˜¯çµ•å°åº§æ¨™ï¼Œç›´æ¥ä½¿ç”¨
          if (isFinite(remoteUnit.x) && isFinite(remoteUnit.y)) {
            localUnit.x = remoteUnit.x;
            localUnit.y = remoteUnit.y;
          }
        }

        // åªæ›´æ–°å­˜åœ¨ä¸”æœ‰æ•ˆçš„å±¬æ€§
        if (typeof remoteUnit.currentHP === 'number') localUnit.currentHP = remoteUnit.currentHP;
        if (typeof remoteUnit.maxHP === 'number') localUnit.maxHP = remoteUnit.maxHP;
        if (typeof remoteUnit.alive === 'boolean') localUnit.alive = remoteUnit.alive;
        if (typeof remoteUnit.deployed === 'boolean') localUnit.deployed = remoteUnit.deployed;
        localUnit.visible = remoteUnit.visible !== false;
        if (typeof remoteUnit.hasMoved === 'boolean') localUnit.hasMoved = remoteUnit.hasMoved;
        if (typeof remoteUnit.hasShot === 'boolean') localUnit.hasShot = remoteUnit.hasShot;
        if (typeof remoteUnit.hasCharged === 'boolean') localUnit.hasCharged = remoteUnit.hasCharged;
        if (typeof remoteUnit.hasFought === 'boolean') localUnit.hasFought = remoteUnit.hasFought;
        // æ€¥è¡Œ/æ’¤é€€/æ¥æˆ°ç‹€æ…‹åŒæ­¥
        if (typeof remoteUnit.hasAdvanced === 'boolean') localUnit.hasAdvanced = remoteUnit.hasAdvanced;
        if (typeof remoteUnit.hasFallenBack === 'boolean') localUnit.hasFallenBack = remoteUnit.hasFallenBack;
        if (typeof remoteUnit.isInEngagement === 'boolean') localUnit.isInEngagement = remoteUnit.isInEngagement;
        if (remoteUnit.chargeTarget) localUnit.chargeTarget = remoteUnit.chargeTarget;
        localUnit.battleShocked = remoteUnit.battleShocked || false;
        localUnit.inCover = remoteUnit.inCover || false;
        if (remoteUnit.usedOneUseWeapons) localUnit.usedOneUseWeapons = remoteUnit.usedOneUseWeapons;
        if (remoteUnit.activeStratagemEffects) localUnit.activeStratagemEffects = remoteUnit.activeStratagemEffects;
        // ç¢ºä¿æˆ°é¬¥æ­·å²ä¸€å®šæœƒåŒæ­¥ï¼ˆåŒ…æ‹¬ç©ºé™£åˆ—ï¼‰
        if (Array.isArray(remoteUnit.battleHistory)) {
          localUnit.battleHistory = remoteUnit.battleHistory;
        } else if (!localUnit.battleHistory) {
          localUnit.battleHistory = [];
        }
        // é‹è¼¸è¼‰å…·åŒæ­¥
        if (remoteUnit.embarkedIn !== undefined) localUnit.embarkedIn = remoteUnit.embarkedIn;
        if (Array.isArray(remoteUnit.embarkedUnits)) localUnit.embarkedUnits = remoteUnit.embarkedUnits;
        // é£›è¡Œå™¨åŒæ­¥
        if (typeof remoteUnit.isHovering === 'boolean') localUnit.isHovering = remoteUnit.isHovering;
        if (typeof remoteUnit.inReserves === 'boolean') localUnit.inReserves = remoteUnit.inReserves;
        syncedCount++;
      } else {
        console.warn('[syncGameState] æ‰¾ä¸åˆ°æœ¬åœ°å–®ä½:', remoteUnit.id);
        missingCount++;
      }
    });

    console.warn('[syncGameState] åŒæ­¥å®Œæˆ:', {
      é ç«¯å–®ä½æ•¸: remoteState.units.length,
      æœ¬åœ°å–®ä½æ•¸: gameState.units.length,
      æˆåŠŸåŒæ­¥: syncedCount,
      æ‰¾ä¸åˆ°: missingCount,
      å·²éƒ¨ç½²: remoteState.units.filter(u => u.deployed).length
    });
  }

  // æ›´æ–° UI å…ƒç´ 
  if (typeof updateUnitLists === 'function') updateUnitLists();
  if (typeof updateCPDisplay === 'function') updateCPDisplay();
  if (typeof updateVPDisplay === 'function') updateVPDisplay();  // åŒæ­¥VPé¡¯ç¤º
  if (typeof updatePhaseIndicator === 'function') updatePhaseIndicator();
  if (typeof updateSelectedUnitInfo === 'function') updateSelectedUnitInfo();  // æ›´æ–°é¸ä¸­å–®ä½è³‡è¨Šï¼ˆåŒ…æ‹¬æˆ°é¬¥æ­·å²ï¼‰
  if (typeof updateMissionUI === 'function') updateMissionUI();  // åŒæ­¥ä»»å‹™é¡¯ç¤º
  document.getElementById("roundNum").textContent = gameState.round;
  document.getElementById("roundDisplay").textContent = gameState.round;

  // é¡¯ç¤ºç•¶å‰ç©å®¶
  const playerName = gameState.currentPlayer === 1 ? "ç©å®¶ä¸€" : "ç©å®¶äºŒ";
  document.getElementById("currentPlayerName").textContent = playerName;

  // æ›´æ–°ç¨®æ—è¦å‰‡é¡¯ç¤º
  const det = playerDetachments[gameState.currentPlayer];
  const detEl = document.getElementById("currentDetachment");
  if (detEl) detEl.textContent = det ? det.name : "";

  console.warn('[syncGameStateFromFirebase] ç‹€æ…‹æ›´æ–°:', {
    phase: gameState.phase,
    currentPlayer: gameState.currentPlayer,
    isMyTurn: isMyTurn(),
    myId: onlinePlayerId
  });

  // å¦‚æœç¾åœ¨æ˜¯è‡ªå·±çš„å›åˆï¼Œä¸”é‚„æ²’è™•ç†éé€™å€‹å›åˆï¼Œæ‰è§¸ç™¼å›åˆé–‹å§‹
  const isNewTurn = (gameState.round !== lastProcessedRound || gameState.currentPlayer !== lastProcessedPlayer);

  if (isMyTurn() && gameState.phase === 'command' && isNewTurn && !turnInProgress) {
    lastProcessedRound = gameState.round;
    lastProcessedPlayer = gameState.currentPlayer;
    turnInProgress = true;

    log(`è¼ªåˆ°ä½ çš„å›åˆï¼`, 'phase', false);
    const isAITurn = (gameState.currentPlayer === 1 && ai1Enabled) || (gameState.currentPlayer === 2 && ai2Enabled);
    console.warn('[syncGameStateFromFirebase] è§¸ç™¼æˆ‘çš„å›åˆ:', {
      isAITurn,
      currentPlayer: gameState.currentPlayer,
      round: gameState.round,
      myId: onlinePlayerId
    });

    if (isAITurn) {
      setTimeout(async () => { await runAITurn(); turnInProgress = false; }, 500);
    } else {
      setTimeout(async () => { await executeCommandPhase(); turnInProgress = false; }, 100);
    }
  }

  // ä¸æ˜¯è‡ªå·±å›åˆæ™‚ï¼Œé‡ç½®UIç‹€æ…‹
  if (!isMyTurn()) {
    turnInProgress = false;
    hideAttackConfirmButton();
    gameState.targetUnit = null;
  }

  updatePhaseDisplay();
  render();
}

// ç™¼é€å‹•ä½œåˆ° Firebase
function sendAction(action) {
  if (!isOnlineMode || !roomRef) return;

  const actionData = {
    ...action,
    player: onlinePlayerId,
    timestamp: Date.now()  // ä½¿ç”¨å®¢æˆ¶ç«¯æ™‚é–“ç¢ºä¿ä¸€è‡´æ€§
  };

  console.warn('[sendAction] ç™¼é€å‹•ä½œ:', actionData);
  roomRef.child('lastAction').set(actionData);

  // åŒæ­¥éŠæˆ²ç‹€æ…‹
  syncGameStateToFirebase();
}

// è™•ç†é ç«¯å‹•ä½œ
function handleRemoteAction(action) {
  if (!action || action.player === onlinePlayerId) return;

  console.warn('[handleRemoteAction] è™•ç†å‹•ä½œ:', action.type, action);

  switch (action.type) {
    case 'move':
      const moveUnit = gameState.units.find(u => u.id === action.unitId);
      if (moveUnit) {
        moveUnit.x = action.x;
        moveUnit.y = action.y;
        moveUnit.hasMoved = true;
        updateSquadModelPositions(moveUnit); // å°éšŠæ¨¡å‹è‡ªå‹•è·Ÿéš¨
        console.warn('[handleRemoteAction] ç§»å‹•å–®ä½:', moveUnit.name, 'åˆ°', action.x, action.y);
      } else {
        console.warn('[handleRemoteAction] æ‰¾ä¸åˆ°ç§»å‹•å–®ä½:', action.unitId);
      }
      break;

    // ===== æ€¥è¡Œå‹•ä½œåŒæ­¥ =====
    case 'advance':
      const advanceUnit = gameState.units.find(u => u.id === action.unitId);
      if (advanceUnit) {
        advanceUnit.x = action.x;
        advanceUnit.y = action.y;
        advanceUnit.hasMoved = true;
        advanceUnit.hasAdvanced = true;
        updateSquadModelPositions(advanceUnit); // å°éšŠæ¨¡å‹è‡ªå‹•è·Ÿéš¨
        checkCover(advanceUnit);
        log(`ğŸƒ ${advanceUnit.name} æ€¥è¡Œç§»å‹• (D6=${action.roll || '?'})`, "info");
        console.warn('[handleRemoteAction] æ€¥è¡Œå–®ä½:', advanceUnit.name);
      }
      break;

    // ===== æ’¤é€€å‹•ä½œåŒæ­¥ =====
    case 'fallback':
      const fallbackUnit = gameState.units.find(u => u.id === action.unitId);
      if (fallbackUnit) {
        fallbackUnit.x = action.x;
        fallbackUnit.y = action.y;
        fallbackUnit.hasMoved = true;
        fallbackUnit.hasFallenBack = true;
        fallbackUnit.isInEngagement = false;
        updateSquadModelPositions(fallbackUnit); // å°éšŠæ¨¡å‹è‡ªå‹•è·Ÿéš¨
        checkCover(fallbackUnit);
        log(`ğŸ”™ ${fallbackUnit.name} æ’¤é€€`, "info");
        console.warn('[handleRemoteAction] æ’¤é€€å–®ä½:', fallbackUnit.name);
      }
      break;

    // ===== è¡é‹’å‹•ä½œåŒæ­¥ =====
    case 'charge':
      const chargeUnit = gameState.units.find(u => u.id === action.unitId);
      const chargeTarget = gameState.units.find(u => u.id === action.targetId);
      if (chargeUnit) {
        chargeUnit.x = action.x;
        chargeUnit.y = action.y;
        chargeUnit.hasCharged = true;
        chargeUnit.isInEngagement = true;
        chargeUnit.chargeTarget = action.targetId;
        updateSquadModelPositions(chargeUnit); // å°éšŠæ¨¡å‹è‡ªå‹•è·Ÿéš¨
        if (chargeTarget) {
          chargeTarget.isInEngagement = true;
        }
        log(`âš”ï¸ ${chargeUnit.name} è¡é‹’æˆåŠŸï¼`, "hit");
        console.warn('[handleRemoteAction] è¡é‹’å–®ä½:', chargeUnit.name);
      }
      break;

    // ===== å¦å…‹è¡æ“ŠåŒæ­¥ =====
    case 'tankShock':
      const tankShockTarget = gameState.units.find(u => u.id === action.targetId);
      if (tankShockTarget) {
        tankShockTarget.currentHP -= action.damage;
        log(`ğŸš› å¦å…‹è¡æ“Šé€ æˆ ${action.damage} è‡´å‘½å‚·ï¼`, "damage");
        if (tankShockTarget.currentHP <= 0) {
          tankShockTarget.currentHP = 0;
          tankShockTarget.alive = false;
          log(`ğŸ’€ ${tankShockTarget.name} è¢«å¦å…‹è¡æ“Šæ‘§æ¯€ï¼`, "damage");
        }
        console.warn('[handleRemoteAction] å¦å…‹è¡æ“Šç›®æ¨™:', tankShockTarget.name, 'å‚·å®³:', action.damage);
      }
      break;

    // ===== è‹±å‹‡ä»‹å…¥åŒæ­¥ =====
    case 'heroicIntervention':
      const heroicCharacter = gameState.units.find(u => u.id === action.characterId);
      const heroicCharger = gameState.units.find(u => u.id === action.chargerId);
      if (heroicCharacter) {
        heroicCharacter.x = action.x;
        heroicCharacter.y = action.y;
        heroicCharacter.isInEngagement = true;
        if (heroicCharger) {
          heroicCharger.isInEngagement = true;
        }
        log(`âš”ï¸ ${heroicCharacter.name} ç™¼å‹•è‹±å‹‡ä»‹å…¥ï¼`, "phase");
        console.warn('[handleRemoteAction] è‹±å‹‡ä»‹å…¥:', heroicCharacter.name);
      }
      break;

    // ===== æ­è¼‰å‹•ä½œåŒæ­¥ =====
    case 'embark':
      const embarkUnit = gameState.units.find(u => u.id === action.unitId);
      const embarkTransport = gameState.units.find(u => u.id === action.transportId);
      if (embarkUnit && embarkTransport) {
        if (!embarkTransport.embarkedUnits) embarkTransport.embarkedUnits = [];
        embarkTransport.embarkedUnits.push(embarkUnit.id);
        embarkUnit.embarkedIn = embarkTransport.id;
        embarkUnit.visible = false;
        embarkUnit.hasMoved = true;
        log(`ğŸš ${embarkUnit.name} æ­è¼‰åˆ° ${embarkTransport.name}`, "info");
      }
      break;

    // ===== ä¸‹è»Šå‹•ä½œåŒæ­¥ =====
    case 'disembark':
      const disembarkUnit = gameState.units.find(u => u.id === action.unitId);
      const disembarkTransport = gameState.units.find(u => u.id === action.transportId);
      if (disembarkUnit && disembarkTransport) {
        disembarkTransport.embarkedUnits = (disembarkTransport.embarkedUnits || []).filter(id => id !== disembarkUnit.id);
        disembarkUnit.embarkedIn = null;
        disembarkUnit.visible = true;
        disembarkUnit.x = action.x;
        disembarkUnit.y = action.y;
        disembarkUnit.hasMoved = true;
        log(`ğŸš ${disembarkUnit.name} å¾ ${disembarkTransport.name} ä¸‹è»Š`, "info");
      }
      break;

    case 'attack':
      // æ”»æ“Šå‹•ä½œæœƒé€šé gameState åŒæ­¥
      console.log('[handleRemoteAction] æ”»æ“Šå‹•ä½œ (é€égameStateåŒæ­¥)');
      break;
    case 'endTurn':
      // å›åˆçµæŸ
      console.log('[handleRemoteAction] å›åˆçµæŸ');
      break;
    case 'deploy':
      const deployUnit = gameState.units.find(u => u.id === action.unitId);
      if (deployUnit) {
        deployUnit.x = action.x;
        deployUnit.y = action.y;
        deployUnit.deployed = true;
        deployUnit.visible = true;
        console.warn('[handleRemoteAction] éƒ¨ç½²å–®ä½:', deployUnit.name, 'åˆ°', action.x, action.y);
        log(`${deployUnit.name} å·²éƒ¨ç½²`, "info");
        updateUnitLists();
      } else {
        console.error('[handleRemoteAction] æ‰¾ä¸åˆ°éƒ¨ç½²å–®ä½:', action.unitId, 'æœ¬åœ°å–®ä½:', gameState.units.map(u => ({id: u.id, player: u.player})));
      }
      break;
  }

  updateUnitLists();
  render();
}

// æª¢æŸ¥æ˜¯å¦ç‚ºç•¶å‰ç©å®¶çš„å›åˆ
function isMyTurn() {
  if (!isOnlineMode) return true;
  return gameState.currentPlayer === onlinePlayerId;
}

// æª¢æŸ¥æ˜¯å¦å¯ä»¥æ“ä½œè‡ªå·±çš„å–®ä½
function canControlUnit(unit) {
  if (!isOnlineMode) return true;
  // ç·šä¸Šæ¨¡å¼ï¼šåªèƒ½æ“ä½œè‡ªå·±çš„å–®ä½
  return unit && unit.player === onlinePlayerId;
}

// æª¢æŸ¥æ˜¯å¦ç‚ºä¸»æ©Ÿï¼ˆè² è²¬é‚è¼¯é‹ç®—ï¼‰
function isGameHost() {
  return !isOnlineMode || isHost;
}

// åŒæ­¥éª°å­çµæœåˆ° Firebase
function syncDiceRoll(title, results, successCount, failCount) {
  if (!isOnlineMode || !roomRef) return;
  roomRef.child('diceRoll').set({
    title: title,
    results: results,
    successCount: successCount,
    failCount: failCount,
    timestamp: Date.now()
  });
}

// é¡¯ç¤ºé ç«¯éª°å­å‹•ç•«
function showRemoteDice(diceData) {
  if (!diceData) return;
  const overlay = document.getElementById('diceOverlay');
  const container = document.getElementById('diceContainer');
  const titleEl = document.getElementById('diceTitle');
  const resultEl = document.getElementById('diceResult');

  if (!overlay || !container) return;

  titleEl.textContent = diceData.title || 'éª°å­çµæœ';
  container.innerHTML = '';

  if (diceData.results && Array.isArray(diceData.results)) {
    diceData.results.forEach(r => {
      const dice = document.createElement('div');
      dice.className = 'dice ' + (r.success ? 'success' : 'fail');
      if (r.value === 6) dice.classList.add('critical');
      dice.textContent = r.value;
      container.appendChild(dice);
    });
  }

  resultEl.innerHTML = `<span class="success-count">${diceData.successCount || 0} æˆåŠŸ</span> / <span class="fail-count">${diceData.failCount || 0} å¤±æ•—</span>`;

  overlay.classList.add('active');
  setTimeout(() => overlay.classList.remove('active'), 3000);  // å¢åŠ é¡¯ç¤ºæ™‚é–“
}

// åŒæ­¥æˆ°é¬¥ç´€éŒ„åˆ° Firebase
function syncCombatLog(message, type) {
  if (!isOnlineMode || !roomRef) return;
  roomRef.child('combatLog').set({
    message: message,
    type: type,
    timestamp: Date.now()
  });
}

// åŒæ­¥è¦–è¦ºæ•ˆæœåˆ° Firebase
let lastEffectTimestamp = 0;
function syncVisualEffect(effectData) {
  if (!isOnlineMode || !roomRef) return;
  roomRef.child('visualEffect').set({
    ...effectData,
    timestamp: Date.now()
  });
}

// è™•ç†é ç«¯è¦–è¦ºæ•ˆæœ
function handleRemoteVisualEffect(effectData) {
  if (!effectData) return;
  switch (effectData.type) {
    case 'floatingText':
      showFloatingText(effectData.x, effectData.y, effectData.text, effectData.options || {}, false);
      break;
    case 'damageNumber':
      showDamageNumber(effectData.x, effectData.y, effectData.damage, effectData.isCrit || false, false);
      break;
  }
}

// ========== å¸¸æ•¸èˆ‡å°ºå¯¸ç³»çµ± ==========
// ä»¥ç¶²æ ¼ç‚ºåŸºæº–çš„çµ±ä¸€å°ºå¯¸ç³»çµ±
const BASE_GRID_SIZE = 20;  // åŸºç¤ç¶²æ ¼å¤§å°ï¼ˆåƒç´ ï¼‰
const BASE_INCH = BASE_GRID_SIZE * 0.75;  // åŸºç¤1è‹±å‹ = 15åƒç´ 
const INCH = BASE_INCH;  // ä¿æŒå‘å¾Œå…¼å®¹
let maxPoints = 1000; // å¯èª¿æ•´çš„é»æ•¸ä¸Šé™

// å–å¾—å¯¦éš›ç¶²æ ¼å¤§å°ï¼ˆæ ¹æ“šç•«å¸ƒç¸®æ”¾ï¼‰
function getGridSize() {
  const canvasScale = gameState.canvasScale || 1;
  return BASE_GRID_SIZE * canvasScale;
}

// å–å¾—ç¸®æ”¾å¾Œçš„è‹±å‹å€¼ï¼ˆç”¨æ–¼è·é›¢è¨ˆç®—ï¼‰
function getScaledInch() {
  const canvasScale = gameState.canvasScale || 1;
  return BASE_INCH * canvasScale;
}

// å°‡è‹±å‹è½‰æ›ç‚ºåƒç´ ï¼ˆè€ƒæ…®ç¸®æ”¾ï¼‰
function inchToPixels(inches) {
  return inches * getScaledInch();
}

// å°‡åƒç´ è½‰æ›ç‚ºè‹±å‹ï¼ˆè€ƒæ…®ç¸®æ”¾ï¼‰
function pixelsToInch(pixels) {
  return pixels / getScaledInch();
}

// å°‡åº§æ¨™å¸é™„åˆ°ç¶²æ ¼
function snapToGrid(x, y) {
  const gridSize = getGridSize();
  return {
    x: Math.round(x / gridSize) * gridSize,
    y: Math.round(y / gridSize) * gridSize
  };
}

// å–®ä½å¤§å°ï¼ˆä»¥ç¶²æ ¼ç‚ºå–®ä½ï¼‰- æ¯”ä¾‹å°æ‡‰å®˜æ–¹åº•æ¿å°ºå¯¸
// 25mm=1x, 32mm=1.2x, 40mm=1.6x, 50mm=2x, 80mm=3x, 100mm=4x, 130mm=5x
const UNIT_SIZE_IN_GRIDS = {
  infantry: 0.75,      // 25mm æ¨™æº–æ­¥å…µ (1x)
  default: 0.9,        // 32mm é è¨­ (1.2x)
  elite: 1.2,          // 40mm èè‹±/è§’è‰² (1.6x)
  small_monster: 1.5,  // 50mm å°å‹æ€ªç¸ (2x)
  vehicle: 2.25,       // 60-80mm è¼‰å…·/ä¸­å‹æ€ªç¸ (3x)
  large_monster: 3.0,  // 100mm å¤§å‹æ€ªç¸ (4x)
  titanic: 3.75        // 130mm+ æ³°å¦ç´š (5x)
};

// ========== éŸ³æ•ˆç³»çµ± ==========
let audioContext = null;
let masterVolume = 0.5;
let isMuted = false;

// åˆå§‹åŒ–éŸ³é »ä¸Šä¸‹æ–‡ï¼ˆéœ€è¦ç”¨æˆ¶äº¤äº’å¾Œæ‰èƒ½å•Ÿå‹•ï¼‰
function initAudio() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
}

// è¨­å®šéŸ³é‡
function setVolume(value) {
  masterVolume = value / 100;
  document.getElementById('volumeDisplay').textContent = value + '%';
  document.getElementById('soundIcon').textContent = value == 0 ? 'ğŸ”‡' : (value < 30 ? 'ğŸ”ˆ' : (value < 70 ? 'ğŸ”‰' : 'ğŸ”Š'));
  isMuted = (value == 0);
}

// éœéŸ³åˆ‡æ›
function toggleMute() {
  const slider = document.getElementById('volumeSlider');
  if (isMuted) {
    slider.value = 50;
    setVolume(50);
  } else {
    slider.value = 0;
    setVolume(0);
  }
}

// æ’­æ”¾éŸ³æ•ˆï¼ˆä½¿ç”¨ Web Audio API ç”Ÿæˆï¼‰
function playSound(type, options = {}) {
  if (isMuted || masterVolume <= 0) return;
  initAudio();
  if (!audioContext) return;

  const volume = (options.volume || 1) * masterVolume;

  switch (type) {
    case 'shoot':
      playShotSound(volume, options.weapon || 'rifle');
      break;
    case 'hit':
      playHitSound(volume);
      break;
    case 'explosion':
      playExplosionSound(volume, options.size || 'medium');
      break;
    case 'melee':
      playMeleeSound(volume);
      break;
    case 'miss':
      playMissSound(volume);
      break;
    case 'death':
      playDeathSound(volume);
      break;
    case 'heal':
      playHealSound(volume);
      break;
    case 'select':
      playSelectSound(volume);
      break;
    case 'click':
      playClickSound(volume);
      break;
    case 'roundStart':
      playRoundStartSound(volume);
      break;
    case 'victory':
      playVictorySound(volume);
      break;
    case 'charge':
      playChargeSound(volume);
      break;
    case 'dice':
      playDiceSound(volume);
      break;
  }
}

// å°„æ“ŠéŸ³æ•ˆ
function playShotSound(volume, weapon) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();
  const noise = createNoiseBuffer(0.15);

  // å™ªéŸ³éƒ¨åˆ†ï¼ˆæ§è²ä¸»é«”ï¼‰
  const noiseSource = audioContext.createBufferSource();
  noiseSource.buffer = noise;
  const noiseGain = audioContext.createGain();
  const noiseFilter = audioContext.createBiquadFilter();
  noiseFilter.type = 'bandpass';
  noiseFilter.frequency.value = weapon === 'laser' ? 2000 : 800;
  noiseFilter.Q.value = 1;

  noiseSource.connect(noiseFilter);
  noiseFilter.connect(noiseGain);
  noiseGain.connect(audioContext.destination);

  noiseGain.gain.setValueAtTime(volume * 0.4, audioContext.currentTime);
  noiseGain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.12);

  // éŸ³èª¿éƒ¨åˆ†
  osc.type = weapon === 'laser' ? 'sine' : 'sawtooth';
  osc.frequency.setValueAtTime(weapon === 'laser' ? 1200 : 150, audioContext.currentTime);
  osc.frequency.exponentialDecayTo(weapon === 'laser' ? 800 : 60, audioContext.currentTime + 0.1);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.2, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.1);

  osc.start();
  noiseSource.start();
  osc.stop(audioContext.currentTime + 0.15);
  noiseSource.stop(audioContext.currentTime + 0.15);
}

// å‘½ä¸­éŸ³æ•ˆ
function playHitSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sine';
  osc.frequency.setValueAtTime(400, audioContext.currentTime);
  osc.frequency.exponentialDecayTo(100, audioContext.currentTime + 0.1);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.15);

  osc.start();
  osc.stop(audioContext.currentTime + 0.15);
}

// çˆ†ç‚¸éŸ³æ•ˆ
function playExplosionSound(volume, size) {
  const duration = size === 'large' ? 0.6 : (size === 'small' ? 0.2 : 0.4);
  const noise = createNoiseBuffer(duration);
  const source = audioContext.createBufferSource();
  source.buffer = noise;

  const filter = audioContext.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.setValueAtTime(size === 'large' ? 400 : 600, audioContext.currentTime);
  filter.frequency.exponentialDecayTo(50, audioContext.currentTime + duration);

  const gain = audioContext.createGain();
  gain.gain.setValueAtTime(volume * 0.5, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + duration);

  source.connect(filter);
  filter.connect(gain);
  gain.connect(audioContext.destination);

  source.start();
  source.stop(audioContext.currentTime + duration);
}

// è¿‘æˆ°éŸ³æ•ˆ
function playMeleeSound(volume) {
  const noise = createNoiseBuffer(0.1);
  const source = audioContext.createBufferSource();
  source.buffer = noise;

  const filter = audioContext.createBiquadFilter();
  filter.type = 'highpass';
  filter.frequency.value = 2000;

  const gain = audioContext.createGain();
  gain.gain.setValueAtTime(volume * 0.3, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.1);

  source.connect(filter);
  filter.connect(gain);
  gain.connect(audioContext.destination);

  source.start();
  source.stop(audioContext.currentTime + 0.1);
}

// æœªå‘½ä¸­éŸ³æ•ˆ
function playMissSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sine';
  osc.frequency.setValueAtTime(300, audioContext.currentTime);
  osc.frequency.linearRampToValueAtTime(100, audioContext.currentTime + 0.2);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.1, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.2);

  osc.start();
  osc.stop(audioContext.currentTime + 0.2);
}

// æ­»äº¡éŸ³æ•ˆ
function playDeathSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(200, audioContext.currentTime);
  osc.frequency.exponentialDecayTo(30, audioContext.currentTime + 0.5);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.25, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.5);

  osc.start();
  osc.stop(audioContext.currentTime + 0.5);
}

// æ²»ç™‚éŸ³æ•ˆ
function playHealSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sine';
  osc.frequency.setValueAtTime(400, audioContext.currentTime);
  osc.frequency.linearRampToValueAtTime(800, audioContext.currentTime + 0.1);
  osc.frequency.linearRampToValueAtTime(600, audioContext.currentTime + 0.2);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.15, audioContext.currentTime);
  gain.gain.linearRampToValueAtTime(volume * 0.2, audioContext.currentTime + 0.1);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.3);

  osc.start();
  osc.stop(audioContext.currentTime + 0.3);
}

// é¸æ“‡éŸ³æ•ˆ
function playSelectSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sine';
  osc.frequency.setValueAtTime(600, audioContext.currentTime);
  osc.frequency.linearRampToValueAtTime(800, audioContext.currentTime + 0.05);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.1, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.1);

  osc.start();
  osc.stop(audioContext.currentTime + 0.1);
}

// é»æ“ŠéŸ³æ•ˆ
function playClickSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sine';
  osc.frequency.value = 1000;

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.08, audioContext.currentTime);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.03);

  osc.start();
  osc.stop(audioContext.currentTime + 0.03);
}

// å›åˆé–‹å§‹éŸ³æ•ˆ
function playRoundStartSound(volume) {
  const notes = [523, 659, 784]; // C5, E5, G5
  notes.forEach((freq, i) => {
    setTimeout(() => {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();

      osc.type = 'sine';
      osc.frequency.value = freq;

      osc.connect(gain);
      gain.connect(audioContext.destination);
      gain.gain.setValueAtTime(volume * 0.15, audioContext.currentTime);
      gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.2);

      osc.start();
      osc.stop(audioContext.currentTime + 0.2);
    }, i * 100);
  });
}

// å‹åˆ©éŸ³æ•ˆ
function playVictorySound(volume) {
  const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
  notes.forEach((freq, i) => {
    setTimeout(() => {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();

      osc.type = 'sine';
      osc.frequency.value = freq;

      osc.connect(gain);
      gain.connect(audioContext.destination);
      gain.gain.setValueAtTime(volume * 0.2, audioContext.currentTime);
      gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.4);

      osc.start();
      osc.stop(audioContext.currentTime + 0.4);
    }, i * 150);
  });
}

// è¡é‹’éŸ³æ•ˆ
function playChargeSound(volume) {
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();

  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(100, audioContext.currentTime);
  osc.frequency.linearRampToValueAtTime(300, audioContext.currentTime + 0.3);

  osc.connect(gain);
  gain.connect(audioContext.destination);
  gain.gain.setValueAtTime(volume * 0.15, audioContext.currentTime);
  gain.gain.linearRampToValueAtTime(volume * 0.25, audioContext.currentTime + 0.2);
  gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.35);

  osc.start();
  osc.stop(audioContext.currentTime + 0.35);
}

// éª°å­éŸ³æ•ˆ
function playDiceSound(volume) {
  for (let i = 0; i < 3; i++) {
    setTimeout(() => {
      const noise = createNoiseBuffer(0.05);
      const source = audioContext.createBufferSource();
      source.buffer = noise;

      const filter = audioContext.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 3000;

      const gain = audioContext.createGain();
      gain.gain.setValueAtTime(volume * 0.15, audioContext.currentTime);
      gain.gain.exponentialDecayTo(0.001, audioContext.currentTime + 0.05);

      source.connect(filter);
      filter.connect(gain);
      gain.connect(audioContext.destination);

      source.start();
      source.stop(audioContext.currentTime + 0.05);
    }, i * 50);
  }
}

// å‰µå»ºç™½å™ªéŸ³ç·©è¡å€
function createNoiseBuffer(duration) {
  const sampleRate = audioContext.sampleRate;
  const length = sampleRate * duration;
  const buffer = audioContext.createBuffer(1, length, sampleRate);
  const data = buffer.getChannelData(0);

  for (let i = 0; i < length; i++) {
    data[i] = Math.random() * 2 - 1;
  }

  return buffer;
}

// ç‚º GainNode æ·»åŠ æŒ‡æ•¸è¡°æ¸›æ–¹æ³•
AudioParam.prototype.exponentialDecayTo = function(value, endTime) {
  this.exponentialRampToValueAtTime(Math.max(0.001, value), endTime);
};

// ========== æˆ°å ´å°ºå¯¸è¨­å®š ==========
const BATTLEFIELD_SIZES = {
  "combat-patrol": { width: 44, height: 30, name: "Combat Patrol", desc: "å°å‹å°æˆ°ï¼Œé©åˆ 500 é»ä»¥ä¸‹", deployZone: 6 },
  "incursion": { width: 44, height: 30, name: "Incursion", desc: "å°å‹å°æˆ°ï¼Œé©åˆ 500-1000 é»", deployZone: 9 },
  "strike-force": { width: 60, height: 44, name: "Strike Force", desc: "æ¨™æº–å°æˆ°ï¼Œé©åˆ 1000-2000 é»", deployZone: 12 },
  "onslaught": { width: 90, height: 44, name: "Onslaught", desc: "å¤§å‹å°æˆ°ï¼Œé©åˆ 2000+ é»", deployZone: 12 }
};

// ========== åœ°åœ–å ´æ™¯è¨­å®š ==========
const MAP_SCENARIOS = {
  "standard": {
    name: "æ¨™æº–æˆ°å ´",
    desc: "å‡è¡¡é…ç½®çš„æ¨™æº–åœ°å½¢",
    generate: (w, h) => ({
      terrain: [
        { type: "ruins", x: w * 0.35, y: h * 0.3, width: 80, height: 60 },
        { type: "ruins", x: w * 0.65, y: h * 0.7, width: 80, height: 60 },
        { type: "woods", x: w * 0.2, y: h * 0.6, width: 70, height: 70 },
        { type: "woods", x: w * 0.8, y: h * 0.4, width: 70, height: 70 },
        { type: "crater", x: w * 0.5, y: h * 0.5, width: 50, height: 50 },
        { type: "barricade", x: w * 0.4, y: h * 0.15, width: 60, height: 20 },
        { type: "barricade", x: w * 0.6, y: h * 0.85, width: 60, height: 20 }
      ],
      objectives: [
        { id: 1, x: w * 0.5, y: h * 0.5 },
        { id: 2, x: w * 0.25, y: h * 0.3 },
        { id: 3, x: w * 0.25, y: h * 0.7 },
        { id: 4, x: w * 0.75, y: h * 0.3 },
        { id: 5, x: w * 0.75, y: h * 0.7 }
      ]
    })
  },
  "city": {
    name: "åŸå¸‚å»¢å¢Ÿ",
    desc: "å¯†é›†å»ºç¯‰å’Œæ©é«”ï¼Œé©åˆæ­¥å…µæˆ°",
    generate: (w, h) => ({
      terrain: [
        { type: "ruins", x: w * 0.2, y: h * 0.25, width: 90, height: 70 },
        { type: "ruins", x: w * 0.5, y: h * 0.2, width: 80, height: 60 },
        { type: "ruins", x: w * 0.8, y: h * 0.25, width: 90, height: 70 },
        { type: "ruins", x: w * 0.35, y: h * 0.5, width: 70, height: 50 },
        { type: "ruins", x: w * 0.65, y: h * 0.5, width: 70, height: 50 },
        { type: "ruins", x: w * 0.2, y: h * 0.75, width: 90, height: 70 },
        { type: "ruins", x: w * 0.5, y: h * 0.8, width: 80, height: 60 },
        { type: "ruins", x: w * 0.8, y: h * 0.75, width: 90, height: 70 },
        { type: "barricade", x: w * 0.3, y: h * 0.35, width: 40, height: 15 },
        { type: "barricade", x: w * 0.7, y: h * 0.65, width: 40, height: 15 }
      ],
      objectives: [
        { id: 1, x: w * 0.5, y: h * 0.5 },
        { id: 2, x: w * 0.3, y: h * 0.25 },
        { id: 3, x: w * 0.3, y: h * 0.75 },
        { id: 4, x: w * 0.7, y: h * 0.25 },
        { id: 5, x: w * 0.7, y: h * 0.75 }
      ]
    })
  },
  "forest": {
    name: "å¯†æ—åœ°å¸¶",
    desc: "å¤§ç‰‡æ£®æ—ï¼Œé™åˆ¶è¦–ç·šå’Œç§»å‹•",
    generate: (w, h) => ({
      terrain: [
        { type: "woods", x: w * 0.15, y: h * 0.3, width: 100, height: 90 },
        { type: "woods", x: w * 0.15, y: h * 0.7, width: 100, height: 90 },
        { type: "woods", x: w * 0.4, y: h * 0.5, width: 80, height: 80 },
        { type: "woods", x: w * 0.6, y: h * 0.5, width: 80, height: 80 },
        { type: "woods", x: w * 0.85, y: h * 0.3, width: 100, height: 90 },
        { type: "woods", x: w * 0.85, y: h * 0.7, width: 100, height: 90 },
        { type: "crater", x: w * 0.5, y: h * 0.25, width: 50, height: 50 },
        { type: "crater", x: w * 0.5, y: h * 0.75, width: 50, height: 50 }
      ],
      objectives: [
        { id: 1, x: w * 0.5, y: h * 0.5 },
        { id: 2, x: w * 0.2, y: h * 0.5 },
        { id: 3, x: w * 0.8, y: h * 0.5 },
        { id: 4, x: w * 0.5, y: h * 0.2 },
        { id: 5, x: w * 0.5, y: h * 0.8 }
      ]
    })
  },
  "wasteland": {
    name: "è’é‡æˆ°å ´",
    desc: "é–‹é—˜å¹³åŸï¼Œå°‘é‡æ©é«”ï¼Œé©åˆè¼‰å…·",
    generate: (w, h) => ({
      terrain: [
        { type: "crater", x: w * 0.25, y: h * 0.3, width: 60, height: 60 },
        { type: "crater", x: w * 0.75, y: h * 0.7, width: 60, height: 60 },
        { type: "crater", x: w * 0.5, y: h * 0.5, width: 70, height: 70 },
        { type: "barricade", x: w * 0.35, y: h * 0.6, width: 50, height: 20 },
        { type: "barricade", x: w * 0.65, y: h * 0.4, width: 50, height: 20 },
        { type: "ruins", x: w * 0.15, y: h * 0.5, width: 60, height: 50 },
        { type: "ruins", x: w * 0.85, y: h * 0.5, width: 60, height: 50 }
      ],
      objectives: [
        { id: 1, x: w * 0.5, y: h * 0.5 },
        { id: 2, x: w * 0.25, y: h * 0.25 },
        { id: 3, x: w * 0.25, y: h * 0.75 },
        { id: 4, x: w * 0.75, y: h * 0.25 },
        { id: 5, x: w * 0.75, y: h * 0.75 }
      ]
    })
  },
  "fortress": {
    name: "è¦å¡æ”»é˜²",
    desc: "ä¸€å´æœ‰å¤§å‹é˜²ç¦¦å·¥äº‹ï¼Œæ”»é˜²ä¸å°ç¨±",
    generate: (w, h) => ({
      terrain: [
        // é˜²å®ˆæ–¹ï¼ˆå³å´ï¼‰çš„è¦å¡
        { type: "building", x: w * 0.85, y: h * 0.5, width: 100, height: 150 },
        { type: "barricade", x: w * 0.7, y: h * 0.3, width: 80, height: 25 },
        { type: "barricade", x: w * 0.7, y: h * 0.7, width: 80, height: 25 },
        { type: "barricade", x: w * 0.7, y: h * 0.5, width: 80, height: 25 },
        // é€²æ”»æ–¹çš„æ©è­·
        { type: "crater", x: w * 0.3, y: h * 0.3, width: 60, height: 60 },
        { type: "crater", x: w * 0.3, y: h * 0.7, width: 60, height: 60 },
        { type: "crater", x: w * 0.45, y: h * 0.5, width: 50, height: 50 },
        { type: "ruins", x: w * 0.15, y: h * 0.5, width: 70, height: 60 }
      ],
      objectives: [
        { id: 1, x: w * 0.85, y: h * 0.5 },  // è¦å¡æ ¸å¿ƒ
        { id: 2, x: w * 0.6, y: h * 0.3 },   // è¦å¡å‰ç·š
        { id: 3, x: w * 0.6, y: h * 0.7 },   // è¦å¡å‰ç·š
        { id: 4, x: w * 0.3, y: h * 0.5 },   // ä¸­å ´
        { id: 5, x: w * 0.15, y: h * 0.5 }   // é€²æ”»æ–¹èµ·é»
      ]
    })
  },
  "random": {
    name: "éš¨æ©Ÿç”Ÿæˆ",
    desc: "éš¨æ©Ÿé…ç½®åœ°å½¢å’Œç›®æ¨™é»",
    generate: (w, h) => {
      const terrainTypes = ["ruins", "woods", "crater", "barricade", "building"];
      const terrain = [];
      const numTerrain = 5 + Math.floor(Math.random() * 5);

      for (let i = 0; i < numTerrain; i++) {
        const type = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
        terrain.push({
          type,
          x: w * (0.2 + Math.random() * 0.6),
          y: h * (0.15 + Math.random() * 0.7),
          width: 40 + Math.random() * 60,
          height: type === "barricade" ? 15 + Math.random() * 15 : 40 + Math.random() * 50
        });
      }

      const objectives = [
        { id: 1, x: w * 0.5, y: h * 0.5 }
      ];
      const numObjectives = 4;
      for (let i = 0; i < numObjectives; i++) {
        objectives.push({
          id: i + 2,
          x: w * (0.2 + Math.random() * 0.6),
          y: h * (0.2 + Math.random() * 0.6)
        });
      }

      return { terrain, objectives };
    }
  }
};

// ç•¶å‰é¸æ“‡çš„æˆ°å ´è¨­å®š
let selectedBattlefieldSize = "strike-force";
let selectedMapScenario = "standard";

// ========== ç¨®æ—è¦å‰‡ï¼ˆDetachment Rulesï¼‰==========
const DETACHMENT_RULES = {
  "necrons": {
    "awakened-dynasty": {
      name: "è¦ºé†’ç‹æœ Awakened Dynasty",
      description: "æŒ‡æ®å”è­°ï¼šç•¶è§’è‰²é ˜å°å–®ä½æ™‚ï¼Œè©²å–®ä½æ‰€æœ‰å‘½ä¸­æ“²éª°+1ã€‚",
      effect: "+1 to Hit when CHARACTER leads unit",
      stratagems: [
        { name: "æ°¸æ†äº¡è€…å”è­°", cp: 1, desc: "å¾©æ´»è¢«æ‘§æ¯€çš„è§’è‰²ï¼ˆåŠè¡€ï¼‰", phases: ["command"] },
        { name: "ä¸æ»…è»åœ˜å”è­°", cp: 1, desc: "æ•µæ–¹å°„æ“Š/è¿‘æˆ°å¾Œè§¸ç™¼å¾©æ´»å”è­°", phases: ["shooting", "fight"] },
        { name: "é£¢æ¸´è™›ç©ºå”è­°", cp: 1, desc: "è¿‘æˆ°S+1ï¼Œè§’è‰²é ˜å°æ™‚APæ”¹é€²", phases: ["fight"] },
        { name: "çªè¥²é¢¨æš´å”è­°", cp: 1, desc: "é ç¨‹æ­¦å™¨ç²å¾—[çªæ“Š]ï¼Œè§’è‰²é ˜å°å¯é‡æ“²è¡åˆº", phases: ["movement", "shooting"] },
        { name: "å¾æœæš´å›å”è­°", cp: 1, desc: "åŠå°„ç¨‹å…§é‡æ“²å‘½ä¸­1ï¼Œè§’è‰²é ˜å°å…¨é‡æ“²", phases: ["shooting"] },
        { name: "å¾©ä»‡æ˜Ÿè¾°å”è­°", cp: 2, desc: "æ•µæ–¹æ‘§æ¯€é™„è¿‘å–®ä½å¾Œï¼Œè§’è‰²å–®ä½å¯å°„æ“Š", phases: ["shooting", "fight"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Character") || context.hasLeader) {
          return { hitBonus: 1 };
        }
        return {};
      }
    },
    "annihilation-legion": {
      name: "æ®²æ»…è»åœ˜ Annihilation Legion",
      description: "æ®²æ»…å”è­°ï¼šæ¯€æ»…è€…å’Œå‰çš®è€…å¯é‡æ“²è¡é‹’ï¼Œè‹¥ç›®æ¨™ä½æ–¼åŠè¡€å‰‡+1è¡é‹’ã€‚æ¯€æ»…è€…å°„æ“Šæœ€è¿‘ç›®æ¨™æ™‚AP+1ã€‚",
      effect: "Destroyer Cult/Flayed Ones re-roll charges, +1 if target below half. +1 AP vs closest",
      stratagems: [
        { name: "æ­»äº¡é¢å…·", cp: 1, desc: "æ•µæ–¹å‘½ä¸­-1", phases: ["shooting", "fight"] },
        { name: "è™›å¼±æ°£æ¯", cp: 1, desc: "æ”»æ“Šå—å‚·æ•µäººå‘½ä¸­/è‡´å‚·+1", phases: ["shooting", "fight"] },
        { name: "æ®ºæˆ®å¾©æ´»", cp: 1, desc: "æ‘§æ¯€æ•µäººå¾Œè§¸ç™¼å¾©æ´»å”è­°", phases: ["fight"] },
        { name: "ç„¡æƒ…çµæ‰‹", cp: 1, desc: "å †ç–Š/æ•´åˆç§»å‹•æ“´å±•è‡³6\"", phases: ["fight"] },
        { name: "è¡€è…¥æ®˜æš´", cp: 1, desc: "æ•µæ–¹æ’¤é€€æ™‚é€ æˆè‡´å‘½å‚·ä¸¦è¿½æ“Š", phases: ["movement"] },
        { name: "ç˜‹ç‹‚ä¹‹æ€’", cp: 1, desc: "è¢«æ‘§æ¯€å¾Œå‘æ•µæ–¹ç§»å‹•", phases: ["shooting", "fight"] }
      ],
      apply: (attacker, target, context) => {
        const isDestroyer = attacker.keywords?.includes("Destroyer") || attacker.keywords?.includes("Flayed");
        if (isDestroyer) {
          let bonus = { rerollCharge: true };
          if (target && target.currentHP <= target.maxHP / 2) {
            bonus.chargeBonus = 1;
          }
          if (context.phase === "shooting" && context.isClosestTarget) {
            bonus.apBonus = 1;
          }
          return bonus;
        }
        return {};
      }
    },
    "canoptek-court": {
      name: "å¹½éˆæ§‹è£é«”æ³•åº­ Canoptek Court",
      description: "èƒ½é‡çŸ©é™£ï¼šç¥•è¡“å¸«å’Œå¹½éˆæ§‹è£é«”é‡æ“²å‘½ä¸­1ï¼Œå®Œå…¨åœ¨çŸ©é™£å…§å‰‡å…¨é‡æ“²ã€‚çŸ©é™£æ ¹æ“šç›®æ¨™æ§åˆ¶æ“´å¼µã€‚",
      effect: "Cryptek/Canoptek re-roll 1s, full re-roll in Power Matrix",
      stratagems: [
        { name: "ç¥•è¡“å¸«è©›å’’", cp: 1, desc: "ç¥•è¡“å¸«è¢«æ‘§æ¯€å¾Œå¹½éˆæ§‹è£é«”å‘½ä¸­/è‡´å‚·+1", phases: ["shooting", "fight"] },
        { name: "æ®²æ»…æ ¸å¿ƒ", cp: 2, desc: "çŸ©é™£å…§ç¥•è¡“å¸«/å¹½éˆæ§‹è£é«”ç²å¾—[æ¯€æ»…æ€§å‚·å£]", phases: ["shooting", "fight"] },
        { name: "å¤ªé™½è„ˆè¡", cp: 1, desc: "ç›®æ¨™æ¨™è¨˜é™„è¿‘æ­¦å™¨ç²å¾—[ç„¡è¦–æ©è­·]", phases: ["shooting"] },
        { name: "åæ‡‰å­ç¨‹åº", cp: 1, desc: "å¹½éˆæ§‹è£é«”å¢å¼·ç§»å‹•åæ‡‰", phases: ["movement"] }
      ],
      apply: (attacker, target, context) => {
        const isCryptek = attacker.keywords?.includes("Cryptek");
        const isCanoptek = attacker.keywords?.includes("Canoptek");
        if (isCryptek || isCanoptek) {
          if (context.inPowerMatrix) {
            return { rerollAllHits: true };
          }
          return { rerollHitOnes: true };
        }
        return {};
      }
    },
    "hypercrypt-legion": {
      name: "è¶…ç¶­å¯†å®¤è»åœ˜ Hypercrypt Legion",
      description: "è¶…ç¶­ç›¸ç§»ï¼šå–®ä½å¯åœ¨ç§»å‹•éšæ®µæ¶ˆå¤±ä¸¦åœ¨å°„æ“Šéšæ®µå‰é‡æ–°å‡ºç¾æ–¼9\"å¤–ã€‚æ·±å…¥æ‰“æ“Šå¾Œå¯èŠ±è²»2CPè¡é‹’ã€‚",
      effect: "Units can hyperphase, 2CP to charge after deep strike",
      stratagems: [
        { name: "è¶…ç¶­ä½ç§»", cp: 1, desc: "ç§»å‹•éšæ®µç§»é™¤å–®ä½ï¼Œå°„æ“Šéšæ®µå‰9\"å¤–é‡æ–°éƒ¨ç½²", phases: ["movement"] },
        { name: "é–ƒç¾è¡é‹’", cp: 2, desc: "æ·±å…¥æ‰“æ“Šå¾Œå¯è¡é‹’", phases: ["charge"] },
        { name: "ç¶­åº¦è£‚éš™", cp: 1, desc: "æ•µæ–¹ç„¡æ³•å°å‰›å‡ºç¾çš„å–®ä½åæ‡‰å°„æ“Š", phases: ["movement"] }
      ],
      apply: (attacker, target, context) => {
        return { canHyperphase: true };
      }
    },
    "cryptek-conclave": {
      name: "ç¥•è¡“å¸«é›†æœƒ Cryptek Conclave",
      description: "ç§‘æŠ€è‡³ä¸Šï¼šç¥•è¡“å¸«å’Œå¹½éˆæ§‹è£é«”ç²å¾—4+ç„¡æ•µè±å…ã€‚ç¥•è¡“å¸«é ˜å°æ™‚çµ¦äºˆå–®ä½5+ç„¡æ‡¼æ­»äº¡ã€‚",
      effect: "Cryptek/Canoptek 4+ invulnerable, led units get 5+ FNP",
      stratagems: [
        { name: "å¥ˆç±³èŸ²ä¿®å¾©", cp: 1, desc: "å¹½éˆæ§‹è£é«”æ¢å¾©D3å‚·å£", phases: ["command"] },
        { name: "æ™‚é–“åŠ é€Ÿ", cp: 2, desc: "ç¥•è¡“å¸«æˆ–å¹½éˆæ§‹è£é«”å¯ä»¥åœ¨å°„æ“Šéšæ®µå¾Œå†ç§»å‹•", phases: ["shooting"] },
        { name: "æŠ€è¡“è¦†è“‹", cp: 1, desc: "ç¥•è¡“å¸«12\"å…§æ•µæ–¹è»Šè¼›å’Œç„¡ç•æ©Ÿç”²-1å‘½ä¸­", phases: ["shooting", "fight"] },
        { name: "ç¥•è¡“å¸«åº‡è­·", cp: 1, desc: "ç¥•è¡“å¸«æ­»äº¡æ™‚å¯è½‰ç§»å‚·å®³çµ¦å¹½éˆæ§‹è£é«”", phases: ["shooting", "fight"] }
      ],
      apply: (attacker, target, context) => {
        const isCryptek = attacker.keywords?.includes("Cryptek");
        const isCanoptek = attacker.keywords?.includes("Canoptek");
        if (isCryptek || isCanoptek) {
          let bonus = { invSave: 4 };
          if (isCryptek && context.hasLedUnit) {
            bonus.feelNoPain = 5;
          }
          return bonus;
        }
        return {};
      }
    },
    "starshatter-arsenal": {
      name: "æ˜Ÿç¢è»æ¢°åº« Starshatter Arsenal",
      description: "ç„¡æƒ…çŒ›æ”»ï¼šæ”»æ“Šç›®æ¨™æ¨™è¨˜ç¯„åœå…§çš„å–®ä½æ™‚ï¼Œå‘½ä¸­+1ã€‚è¼‰å…·å’Œé¨ä¹˜å–®ä½é ç¨‹æ­¦å™¨ç²å¾—[çªæ“Š]ã€‚",
      effect: "+1 Hit vs units near objectives, Vehicles/Mounted get Assault",
      stratagems: [
        { name: "é›†ä¸­ç«åŠ›", cp: 1, desc: "åŒä¸€ç›®æ¨™å¤šå–®ä½å°„æ“Šæ™‚è‡´å‚·+1", phases: ["shooting"] },
        { name: "æ¯€æ»…å…‰æŸ", cp: 2, desc: "ä¸€å€‹å–®ä½æ‰€æœ‰æ­¦å™¨ç²å¾—[æ¯€æ»…æ€§å‚·å£]", phases: ["shooting"] },
        { name: "å£“åˆ¶ç«åŠ›", cp: 1, desc: "è¢«å°„æ“Šçš„å–®ä½ä¸‹å›åˆç§»å‹•-2\"", phases: ["shooting"] }
      ],
      apply: (attacker, target, context) => {
        let bonus = {};
        if (context.phase === "shooting" && context.nearObjective) {
          bonus.hitBonus = 1;
        }
        if (attacker.keywords?.includes("Vehicle") || attacker.keywords?.includes("Mounted")) {
          bonus.assault = true;
        }
        return bonus;
      }
    },
    "cursed-legion": {
      name: "è©›å’’è»åœ˜ Cursed Legion",
      description: "å†·é…·ç‹‚ç†±ï¼šæ¯€æ»…è€…æ­¦å™¨S+2ã€‚æ¯€æ»…è€…æ®²æ»…æ•µè»å¾Œï¼Œå‹è»æ­»éˆæ­¦å™¨S+2ï¼ˆæŒçºŒåˆ°å›åˆçµæŸï¼‰ã€‚",
      effect: "+2 Strength for Destroyer Cult, spreads on kill",
      stratagems: [
        { name: "ç„¡æ­¢ç›¡æ†æ¨", cp: 1, desc: "æ¯€æ»…è€…æ”»æ“Šæ™‚é‡æ“²æ‰€æœ‰è‡´å‚·" },
        { name: "ç˜‹ç‹‚å± æ®º", cp: 2, desc: "è¿‘æˆ°é¡å¤–æ”»æ“Šæ¬¡æ•¸ç­‰æ–¼å·²é€ æˆå‚·å®³æ•¸" }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Destroyer")) {
          return { strengthBonus: 2 };
        }
        if (context.destroyerKilledThisTurn) {
          return { strengthBonus: 2 };
        }
        return {};
      }
    },
    "pantheon-of-woe": {
      name: "ç½ç¦è¬ç¥æ®¿ Pantheon of Woe",
      description: "å®‡å®™æ‰­æ›²ï¼šC'tanç¢ç‰‡å’Œæ€ªç¸å–®ä½ç²å¾—æ‰­æ›²åŠ›å ´å…‰ç’°ï¼š6\"å…§æ•µè»å—åˆ°æ”»æ“Šæ™‚AP+1ã€‚å¯å¸¶å¤šå€‹C'tanã€‚",
      effect: "C'tan/Monster aura: +1 AP vs enemies within 6\"",
      stratagems: [
        { name: "ç¾å¯¦æ’•è£‚", cp: 2, desc: "C'tançš„æ”»æ“Šè‡ªå‹•é€ æˆè‡´å‘½å‚·ï¼ˆæ›¿ä»£æ­£å¸¸å‚·å®³ï¼‰" },
        { name: "æ˜Ÿç¥ä¹‹åŠ›", cp: 1, desc: "C'tançš„éˆèƒ½æ­¦å™¨å‚·å®³+1" },
        { name: "æ­»éˆçš®è†šç¶å®š", cp: 1, desc: "C'tanå—å‚·æ™‚é™„è¿‘æ­»éˆå–®ä½å¯åˆ†æ“”å‚·å®³" }
      ],
      apply: (attacker, target, context) => {
        if (context.nearAllyMonster || context.nearAllyCtan) {
          return { apBonus: 1 };
        }
        return {};
      }
    }
  },
  "tyranids": {
    "invasion-fleet": {
      name: "å…¥ä¾µè‰¦éšŠ Invasion Fleet",
      description: "è¶…é©æ‡‰ï¼šæˆ°é¬¥é–‹å§‹é¸æ“‡ä¸€ç¨®é©æ‡‰ï¼šèœ‚æ¹§æœ¬èƒ½ï¼ˆå°æ­¥å…µ/èŸ²ç¾¤æŒçºŒå‘½ä¸­1ï¼‰ã€è¶…ç´šä¾µç•¥ï¼ˆå°æ€ªç¸/è¼‰å…·è‡´å‘½æ‰“æ“Šï¼‰ã€èŸ²å·¢çµæ‰‹ï¼ˆå°è§’è‰²ç²¾æº–æ‰“æ“Šï¼‰ã€‚",
      effect: "Choose: Sustained Hits 1 vs Infantry, Lethal Hits vs Monster/Vehicle, or Precision vs Characters",
      stratagems: [
        { name: "å¿«é€Ÿå†ç”Ÿ", cp: 1, desc: "ç²å¾—6+ç„¡æ‡¼æ­»äº¡ï¼ˆçªè§¸ç¯„åœå…§5+ï¼‰" },
        { name: "è…ä¸Šè…ºç´ æ¿€å¢", cp: 2, desc: "è¿‘æˆ°æœªä¿®æ­£5+ç‚ºè‡´å‘½æ‰“æ“Š" },
        { name: "ç„¡ç›¡èŸ²ç¾¤", cp: 1, desc: "ç„¡ç›¡ç¾¤é«”å–®ä½æ¢å¾©D3+3æ¨¡å‹" },
        { name: "ç‹‚æš´çªè¥²", cp: 1, desc: "è¡é‹’å¾Œè¿‘æˆ°å‘½ä¸­+1" },
        { name: "è¶…é©æ‡‰é€²åŒ–", cp: 1, desc: "æœ¬å›åˆæ”¹è®Šè¶…é©æ‡‰é¸æ“‡" }
      ],
      adaptations: {
        "swarming": { name: "èœ‚æ¹§æœ¬èƒ½", effect: "vs Infantry/Swarm: Sustained Hits 1" },
        "aggression": { name: "è¶…ç´šä¾µç•¥", effect: "vs Monster/Vehicle: Lethal Hits" },
        "predator": { name: "èŸ²å·¢çµæ‰‹", effect: "vs Characters: Precision" }
      },
      apply: (attacker, target, context) => {
        const adaptation = context.selectedAdaptation || "swarming";
        if (adaptation === "swarming" && (target?.keywords?.includes("Infantry") || target?.keywords?.includes("Swarm"))) {
          return { sustainedHits: 1 };
        }
        if (adaptation === "aggression" && (target?.keywords?.includes("Monster") || target?.keywords?.includes("Vehicle"))) {
          return { lethalHits: true };
        }
        if (adaptation === "predator" && target?.keywords?.includes("Character")) {
          return { precision: true };
        }
        return {};
      }
    },
    "crusher-stampede": {
      name: "ç¢¾å£“ç‹‚æ½® Crusher Stampede",
      description: "ç‹‚æ€’å·¨ç¸ï¼šæ€ªç¸å–®ä½ä½æ–¼èµ·å§‹æ¨¡å‹æ•¸æ™‚å‘½ä¸­+1ï¼Œä½æ–¼åŠè¡€æ™‚è‡´å‚·+1ã€‚æ»¿ç·¨æ™‚OC+2ã€‚",
      effect: "Monsters: +1 Hit if below starting, +1 Wound if below half, +2 OC at full",
      stratagems: [
        { name: "è…è•å…§è‡Ÿ", cp: 1, desc: "è‡´å‘½çˆ†ç™¼è‡ªå‹•é€ æˆè‡´å‘½å‚·" },
        { name: "ç‹‚æš´æ€ªç¸", cp: 1, desc: "è¿‘æˆ°é‡æ“²æ‰€æœ‰å‘½ä¸­" },
        { name: "å·¨å¤§è¡æ“Š", cp: 1, desc: "è¡é‹’å¾Œæ“²6D6ï¼Œ4+å„é€ æˆ1è‡´å‘½å‚·" },
        { name: "å …éŸŒå¤–æ®¼", cp: 1, desc: "æ€ªç¸ç²å¾—5+ç„¡æ‡¼æ­»äº¡" }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Monster")) {
          let bonus = {};
          if (attacker.currentHP < attacker.maxHP) {
            bonus.hitBonus = 1;
          }
          if (attacker.currentHP <= attacker.maxHP / 2) {
            bonus.woundBonus = 1;
          }
          if (attacker.currentHP === attacker.maxHP) {
            bonus.ocBonus = 2;
          }
          return bonus;
        }
        return {};
      }
    },
    "unending-swarm": {
      name: "ç„¡ç›¡èŸ²æ½® Unending Swarm",
      description: "ç„¡å¯é˜»æ“‹ï¼šç„¡ç›¡ç¾¤é«”å–®ä½è¢«å°„æ“Šå¾Œé€²è¡Œã€Œæ¹§å‹•ç§»å‹•ã€ï¼Œå‘æœ€è¿‘æ•µäººç§»å‹•D6\"ã€‚",
      effect: "Endless Multitude units Surge D6\" toward enemies after being shot",
      stratagems: [
        { name: "çªè§¸é©…ç­–", cp: 1, desc: "é‡æ“²æ¹§å‹•è·é›¢ï¼Œå¯æ”¹å‘ç›®æ¨™æ¨™è¨˜ç§»å‹•", phases: ["shooting"] },
        { name: "ç„¡ç›¡æ³¢æµª", cp: 2, desc: "è¢«æ‘§æ¯€çš„ç„¡ç›¡ç¾¤é«”è¿”å›æˆ°ç•¥é å‚™éšŠï¼ˆæ¯æˆ°ä¸€æ¬¡ï¼‰", phases: ["command"] },
        { name: "èœ‚æ¹§ç¾¤é«”", cp: 1, desc: "15+æ¨¡å‹æ™‚æŒçºŒå‘½ä¸­1ï¼Œ5+ç‚ºè‡´å‘½æ‰“æ“Š", phases: ["shooting", "fight"] },
        { name: "æ·¹æ²’æˆ°ç·š", cp: 1, desc: "ç„¡ç›¡ç¾¤é«”è¡é‹’æ™‚æ•µæ–¹ç„¡æ³•åæ‡‰å°„æ“Š", phases: ["charge"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Endless Multitude")) {
          return { canSurge: true, surgeDistance: "D6" };
        }
        return {};
      }
    },
    "assimilation-swarm": {
      name: "åŒåŒ–èŸ²ç¾¤ Assimilation Swarm",
      description: "é¤µé¤ŠèŸ²ç¾¤ï¼šæ”¶å‰²è€…å–®ä½åœ¨ç›®æ¨™æ¨™è¨˜é™„è¿‘å¯é€²è¡Œå†ç”Ÿï¼Œæ¢å¾©å‚·å£æˆ–å¾©æ´»æ¨¡å‹ã€‚åŸºå› ç«Šå–è€…æ¯å¤šä¸€å–®ä½OC+1ã€‚",
      effect: "Harvesters regenerate near objectives, Genestealers +1 OC per unit",
      stratagems: [
        { name: "æ„ŸæŸ“å­˜åœ¨", cp: 1, desc: "åŸºå› ç«Šå–è€…æ”»æ“Šå¾Œæ•µäººå¿…é ˆæˆ°æ…„æ¸¬è©¦", phases: ["fight"] },
        { name: "ç•°å½¢é£¢é¤“", cp: 1, desc: "æ”¶å‰²è€…æ®ºæ•µå¾Œæ¢å¾©D3å‚·å£", phases: ["fight"] },
        { name: "æ•™åœ˜å´›èµ·", cp: 2, desc: "åŸºå› ç«Šå–è€…æ·±å…¥æ‰“æ“Šè·é›¢æ”¹ç‚º6\"", phases: ["movement"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.name?.includes("åŸºå› ç«Šå–è€…") || attacker.name?.includes("Genestealers")) {
          return { ocBonus: context.genestealerUnitCount || 1 };
        }
        if (attacker.keywords?.includes("Harvester") && context.nearObjective) {
          return { canRegenerate: true };
        }
        return {};
      }
    },
    "synaptic-nexus": {
      name: "çªè§¸ç¯€é» Synaptic Nexus",
      description: "çªè§¸å‘½ä»¤ï¼šæ¯å€‹æŒ‡æ®éšæ®µå¯å•Ÿå‹•å¼·å¤§çš„çªè§¸èƒ½åŠ›ï¼Œå½±éŸ¿çªè§¸ç¯„åœå…§æ‰€æœ‰å–®ä½ã€‚",
      effect: "Activate powerful Synaptic Imperatives each Command phase",
      stratagems: [
        { name: "èŸ²å·¢æ„å¿—", cp: 1, desc: "çªè§¸å–®ä½å’Œç¯„åœå…§å–®ä½é‡æ“²å‘½ä¸­1", phases: ["shooting", "fight"] },
        { name: "é©æ‡‰æœ¬èƒ½", cp: 1, desc: "é¸æ“‡å–®ä½ç²å¾—ä¸€ç¨®æ­¦å™¨é—œéµå­—åˆ°å›åˆçµæŸ", phases: ["command"] },
        { name: "éˆèƒ½å°–å˜¯", cp: 2, desc: "6\"å…§æ•µäºº-1é ˜å°å€¼ä¸¦å—D3è‡´å‘½å‚·", phases: ["command"] },
        { name: "èŸ²å·¢è­·ç›¾", cp: 1, desc: "çªè§¸ç¯„åœå…§å–®ä½ç²å¾—5+ç„¡æ‡¼æ­»äº¡", phases: ["shooting", "fight"] }
      ],
      imperatives: {
        "aggression": { name: "ä¾µç•¥å‘½ä»¤", effect: "è¿‘æˆ°æ”»æ“Š+1" },
        "adaptation": { name: "é©æ‡‰å‘½ä»¤", effect: "è­·ç”²è±å…+1" },
        "dominion": { name: "çµ±å¾¡å‘½ä»¤", effect: "OCç¿»å€" }
      },
      apply: (attacker, target, context) => {
        if (context.inSynapseRange) {
          const imperative = context.activeImperative || "aggression";
          if (imperative === "aggression") return { attackBonus: 1 };
          if (imperative === "adaptation") return { saveBonus: 1 };
          if (imperative === "dominion") return { ocMultiplier: 2 };
        }
        return {};
      }
    },
    "vanguard-onslaught": {
      name: "å…ˆé‹’æ”»å‹¢ Vanguard Onslaught",
      description: "æœå°‹è§¸é¬šï¼šä¼æ“Šè€…å’Œç¥ç¶“ä¼æ“Šè€…ç²å¾—å¢å¼·ç§»å‹•å’Œæ›´é çš„æ»²é€éƒ¨ç½²ã€‚",
      effect: "Lictors/Neurolictors enhanced infiltrate and movement",
      stratagems: [
        { name: "éš±åŒ¿æ½›ä¼è€…", cp: 1, desc: "ä¼æ“Šè€…åœ¨æ©è­·ä¸­-1è¢«å‘½ä¸­", phases: ["shooting"] },
        { name: "æš—å½±çªè¥²", cp: 1, desc: "æ·±å…¥æ‰“æ“Šå¾Œå¯å°„æ“Šä¸¦è¡é‹’", phases: ["movement"] },
        { name: "ææ‡¼ä¹‹æº", cp: 2, desc: "æ•µæ–¹å–®ä½å¿…é ˆé€²è¡Œæˆ°æ…„æ¸¬è©¦æˆ–ç„¡æ³•åæ‡‰", phases: ["charge"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.name?.includes("ä¼æ“Šè€…") || attacker.name?.includes("Lictor")) {
          return { enhancedInfiltrate: true, extraMove: 2 };
        }
        return {};
      }
    },
    "subterranean-assault": {
      name: "åœ°åº•çªè¥² Subterranean Assault",
      description: "çªæ“Šéš§é“ï¼šç©¿åœ°ç¸å’Œå·¨å£ç¸å¯å‰µå»ºéš§é“æ¨™è¨˜ã€‚å…¶ä»–é‘½åœ°è€…å¯å¾éš§é“éƒ¨ç½²ã€‚æ”»æ“Šæ™‚é‡æ“²å‘½ä¸­1ã€‚",
      effect: "Trygon/Mawloc create tunnels, Burrowers deploy from them, re-roll 1s to Hit",
      stratagems: [
        { name: "åœ°åº•ä¼æ“Š", cp: 2, desc: "å¾éš§é“éƒ¨ç½²çš„å–®ä½æœ¬å›åˆå¯è¡é‹’", phases: ["charge"] },
        { name: "ææ€–çªç¾", cp: 1, desc: "å·¨å£ç¸æ·±å…¥æ‰“æ“Šæ™‚å°3\"å…§æ•µäººé€ æˆD3+3è‡´å‘½å‚·", phases: ["movement"] },
        { name: "éš§é“ç¶²çµ¡", cp: 1, desc: "é‘½åœ°è€…å¯åœ¨éš§é“é–“å‚³é€", phases: ["movement"] }
      ],
      apply: (attacker, target, context) => {
        return { rerollHitOnes: true };
      }
    },
    "warrior-bioform-onslaught": {
      name: "æˆ°å£«ç”Ÿé«”æ”»å‹¢ Warrior Bioform Onslaught",
      description: "é ˜è¢–å·¨ç¸ï¼šæ³°å€«æˆ°å£«ã€èŸ²æ—æˆ°å£«é¦–é ˜å’Œé£›ç¿¼é¦–é ˜ç²å¾—5+ç„¡æ•µè±å…å’Œçªè§¸èƒ½åŠ›ã€‚",
      effect: "Warriors/Prime get 5+ invulnerable save and Synapse",
      stratagems: [
        { name: "ç”Ÿé«”é©æ‡‰", cp: 1, desc: "æˆ°å£«å–®ä½ç²å¾—ä¸€ç¨®æ­¦å™¨é—œéµå­—", phases: ["command"] },
        { name: "èŸ²ç¾¤é ˜è¢–", cp: 1, desc: "æˆ°å£«é ˜å°çš„å–®ä½é‡æ“²å‘½ä¸­1", phases: ["shooting", "fight"] },
        { name: "å¼·åŒ–ç”²æ®¼", cp: 1, desc: "æˆ°å£«ç²å¾—4+ç„¡æ•µè±å…åˆ°å›åˆçµæŸ", phases: ["shooting", "fight"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.name?.includes("æˆ°å£«") || attacker.name?.includes("Warriors") || attacker.name?.includes("Prime")) {
          return { invSave: 5, hasSynapse: true };
        }
        return {};
      }
    }
  },
  "space-marines": {
    "gladius-task-force": {
      name: "æ ¼æ‹‰è¿ªçƒæ–¯ç‰¹é£éšŠ Gladius Task Force",
      description: "æˆ°é¬¥æ•™æ¢ï¼šæ¯å›åˆå¯å•Ÿå‹•ä¸€ç¨®æ•™æ¢ï¼ˆæ¯€æ»…ã€æˆ°è¡“ã€çªæ“Šï¼‰ï¼Œæ¯ç¨®æ¯å ´åªèƒ½ç”¨ä¸€æ¬¡ã€‚",
      effect: "Combat Doctrines: Devastator/Tactical/Assault bonus once per battle",
      stratagems: [
        { name: "å”¯æ­»æ–¹ä¼‘", cp: 2, desc: "è¢«æ‘§æ¯€çš„æ¨¡å‹å¯åœ¨ç§»é™¤å‰æ”»æ“Šä¸€æ¬¡", phases: ["fight"] },
        { name: "æ¦®è€€æˆ°åœ˜", cp: 1, desc: "è¿‘æˆ°éšæ®µé¡å¤–æ”»æ“Š", phases: ["fight"] },
        { name: "è”‘è¦–ä¹‹ç”²", cp: 1, desc: "å—åˆ°æ”»æ“Šæ™‚AP-1", phases: ["shooting", "fight"] },
        { name: "é©æ‡‰æˆ°ç•¥", cp: 1, desc: "æ”¹è®Šç•¶å‰æˆ°é¬¥æ•™æ¢", phases: ["command"] },
        { name: "ç«åŠ›é¢¨æš´", cp: 1, desc: "å°„æ“Šæ™‚é‡æ“²å‘½ä¸­1", phases: ["shooting"] },
        { name: "å°éšŠæˆ°è¡“", cp: 1, desc: "å–®ä½å¯åœ¨æ•µæ–¹ç§»å‹•å¾Œç§»å‹•6\"", phases: ["movement"] }
      ],
      apply: (attacker, target, context) => {
        return { rerollWoundOnes: true };
      }
    },
    "anvil-siege-force": {
      name: "éµç §åœåŸéƒ¨éšŠ Anvil Siege Force",
      description: "å¸åœ‹ä¹‹ç›¾ï¼šé ç¨‹æ­¦å™¨ç²å¾—[Heavy]ï¼›æœªç§»å‹•å–®ä½å‘½ä¸­+1ï¼Œè‹¥å·²æœ‰Heavyå‰‡è‡´å‚·+1ã€‚",
      effect: "Ranged weapons gain Heavy; stationary units +1 Hit or +1 Wound",
      stratagems: [
        { name: "åš´æ ¼ç´€å¾‹", cp: 1, desc: "å–®ä½è‡ªå‹•é€šéæˆ°æ…„æ¸¬è©¦", phases: ["command"] },
        { name: "æˆ°é¬¥æ¼”ç·´", cp: 1, desc: "é‡æ“²æ‰€æœ‰å‘½ä¸­éª°", phases: ["shooting"] },
        { name: "å¾©ä»‡ä¹‹é›¹", cp: 2, desc: "å°æ”»æ“Šéå·±æ–¹çš„æ•µäººå‘½ä¸­+1", phases: ["shooting"] },
        { name: "ç„¡æ‡¼å¨è„…", cp: 2, desc: "å°è¼‰å…·/æ€ªç¸è‡´å‚·+1", phases: ["shooting"] },
        { name: "å¯¸æ­¥ä¸é€€", cp: 1, desc: "ç²å¾—5+ç„¡æ‡¼æ­»äº¡", phases: ["shooting", "fight"] },
        { name: "è”‘è¦–ä¹‹ç”²", cp: 1, desc: "å—åˆ°æ”»æ“Šæ™‚AP-1", phases: ["shooting", "fight"] }
      ],
      apply: (attacker, target, context) => {
        let bonus = { heavy: true };
        if (!attacker.hasMoved) {
          bonus.hitBonus = 1;
        }
        return bonus;
      }
    },
    "firestorm-assault-force": {
      name: "ç«é¢¨æš´çªæ“Šéƒ¨éšŠ Firestorm Assault Force",
      description: "è¿‘è·æ®²æ»…ï¼šé ç¨‹æ­¦å™¨ç²å¾—[Assault]ï¼›12\"å…§ç›®æ¨™æ™‚S+1ã€‚",
      effect: "Ranged weapons gain Assault; +1 Strength within 12\"",
      stratagems: [
        { name: "æˆ°ç«è©¦ç…‰", cp: 1, desc: "è¡é‹’å¾Œè¿‘æˆ°å‘½ä¸­+1", phases: ["fight"] },
        { name: "ç«åŠ›çŒ›æ”»", cp: 1, desc: "å°„æ“Šæ™‚ç²å¾—[æŒçºŒå‘½ä¸­1]", phases: ["shooting"] },
        { name: "ç‡ƒç‡’å¾©ä»‡", cp: 1, desc: "è¢«æ‘§æ¯€çš„å–®ä½å¯å°„æ“Šä¸€æ¬¡", phases: ["shooting"] },
        { name: "å¿«é€Ÿç™»è»Š", cp: 1, desc: "ä¸‹è»Šå¾Œä»å¯è¡é‹’", phases: ["movement"] },
        { name: "ç„šç‡’å”è­°", cp: 2, desc: "ç«ç„°æ­¦å™¨è‡ªå‹•æœ€å¤§æ”»æ“Šæ¬¡æ•¸", phases: ["shooting"] },
        { name: "è”‘è¦–ä¹‹ç”²", cp: 1, desc: "å—åˆ°æ”»æ“Šæ™‚AP-1", phases: ["shooting", "fight"] }
      ],
      apply: (attacker, target, context) => {
        let bonus = { assault: true };
        if (context.distance && context.distance <= 12) {
          bonus.strengthBonus = 1;
        }
        return bonus;
      }
    },
    "ironstorm-spearhead": {
      name: "éµé¢¨æš´çŸ›é ­ Ironstorm Spearhead",
      description: "è£ç”²ä¹‹æ€’ï¼šæ¯å–®ä½æ¯éšæ®µå¯é‡æ“²ä¸€å€‹å‘½ä¸­ã€è‡´å‚·æˆ–å‚·å®³éª°ã€‚",
      effect: "Re-roll one Hit, Wound, or Damage roll per unit per phase",
      stratagems: [
        { name: "è”‘è¦–ä¹‹ç”²", cp: 1, desc: "å—åˆ°æ”»æ“Šæ™‚AP-1", phases: ["shooting", "fight"] },
        { name: "å¾©ä»‡æ€¨éˆ", cp: 1, desc: "ç„¡ç•æ©Ÿç”²è¢«æ‘§æ¯€æ™‚å¯æ”»æ“Š", phases: ["fight"] },
        { name: "é å¤ä¹‹æ€’", cp: 1, desc: "ç„¡ç•æ©Ÿç”²è¿‘æˆ°æ”»æ“Š+1", phases: ["fight"] },
        { name: "æ©Ÿé­‚ä¹‹åŠ›", cp: 1, desc: "è¼‰å…·å¿½ç•¥å—æç‹€æ…‹æ‡²ç½°", phases: ["shooting", "fight"] },
        { name: "ä¸å±ˆä¿¡å¿µ", cp: 1, desc: "è¼‰å…·ç²å¾—6+ç„¡æ‡¼æ­»äº¡", phases: ["shooting", "fight"] },
        { name: "ä»æ…ˆå³è»Ÿå¼±", cp: 1, desc: "å°åŠè¡€æ•µäººå‚·å®³+1", phases: ["shooting", "fight"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Vehicle") || attacker.keywords?.includes("Dreadnought")) {
          return { rerollOneDie: true };
        }
        return {};
      }
    },
    "stormlance-task-force": {
      name: "é¢¨æš´çŸ›ç‰¹é£éšŠ Stormlance Task Force",
      description: "é–ƒé›»çªè¥²ï¼šå–®ä½å¯åœ¨æ€¥è¡Œå¾Œè¡é‹’ï¼Œæˆ–æ’¤é€€å¾Œè¡é‹’ã€‚",
      effect: "Units can Advance and Charge, or Fall Back and Charge",
      stratagems: [
        { name: "è”‘è¦–ä¹‹ç”²", cp: 1, desc: "å—åˆ°æ”»æ“Šæ™‚AP-1", phases: ["shooting", "fight"] },
        { name: "ç–¾é¢¨é–ƒé¿", cp: 1, desc: "è¢«å°„æ“Šæ™‚-1å‘½ä¸­", phases: ["shooting"] },
        { name: "å…¨é€Ÿå‰é€²", cp: 2, desc: "æ€¥è¡Œæ“²éª°è‡ªå‹•ç‚º6", phases: ["movement"] },
        { name: "é–ƒæ“Šé½Šå°„", cp: 1, desc: "æ€¥è¡Œå¾Œå°„æ“Šä¸å—æ‡²ç½°", phases: ["shooting"] },
        { name: "éœ‡æ’¼çªè¥²", cp: 1, desc: "è¡é‹’æˆåŠŸå¾Œè¿‘æˆ°S+1", phases: ["fight"] },
        { name: "ç–¾é¦³è¡é‹’", cp: 1, desc: "è¡é‹’æ“²éª°+2", phases: ["charge"] }
      ],
      apply: (attacker, target, context) => {
        return { advanceAndCharge: true, fallBackAndCharge: true };
      }
    },
    "vanguard-spearhead": {
      name: "å…ˆé‹’çŸ›é ­ Vanguard Spearhead",
      description: "æš—å½±å¤§å¸«ï¼šæ•µæ–¹å°„æ“Š-1å‘½ä¸­ï¼›è¶…é12\"å¤–ç²å¾—æ©è­·ã€‚",
      effect: "-1 to enemy shooting; Cover beyond 12\"",
      stratagems: [
        { name: "è”‘è¦–ä¹‹ç”²", cp: 1, desc: "å—åˆ°æ”»æ“Šæ™‚AP-1", phases: ["shooting", "fight"] },
        { name: "æš—å½±çªè¥²", cp: 1, desc: "æ·±å…¥æ‰“æ“Šå¾Œå¯å°„æ“Šä¸¦è¡é‹’", phases: ["movement"] },
        { name: "ç²¾æº–æ‰“æ“Š", cp: 2, desc: "æ”»æ“Šè§’è‰²æ™‚ç„¡è¦–[ç¨è¡Œä¿ ]", phases: ["shooting"] },
        { name: "è¨ˆç®—ä½¯æ”»", cp: 1, desc: "æ’¤é€€å¾Œä»å¯å°„æ“Š", phases: ["movement"] },
        { name: "æ¸¸æ“Šæˆ°è¡“", cp: 1, desc: "æˆ°é¬¥å¾Œå¯å¾æˆ°å ´ç§»é™¤é€²å…¥é å‚™éšŠ", phases: ["fight"] },
        { name: "è‡´å‘½èª˜é¤Œ", cp: 1, desc: "æ•µæ–¹è¡é‹’æ™‚é€²è¡Œåæ‡‰å°„æ“Š", phases: ["charge"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Phobos")) {
          return { stealth: true, infiltrate: true };
        }
        return { stealth: true };
      }
    },
    "1st-company-task-force": {
      name: "ç¬¬ä¸€é€£ç‰¹é£éšŠ 1st Company Task Force",
      description: "æ¥µç«¯å¨è„…ï¼šæ¯å ´æˆ°é¬¥ä¸€æ¬¡ï¼Œæ”»æ“Šèª“ç´„ç›®æ¨™æ™‚å¯é‡æ“²æ‰€æœ‰è‡´å‚·éª°ã€‚",
      effect: "Re-roll all Wound rolls vs Oath target once per game",
      stratagems: [
        { name: "è”‘è¦–ä¹‹ç”²", cp: 1, desc: "å—åˆ°æ”»æ“Šæ™‚AP-1", phases: ["shooting", "fight"] },
        { name: "è·è²¬èˆ‡æ¦®è€€", cp: 1, desc: "çµ‚çµè€…ç²å¾—5+ç„¡æ‡¼æ­»äº¡", phases: ["shooting", "fight"] },
        { name: "ææ€–ç²¾é€š", cp: 1, desc: "è¿‘æˆ°æ”»æ“Šç²å¾—[è‡´å‘½å‘½ä¸­]", phases: ["fight"] },
        { name: "æˆ°åœ˜è‹±é›„", cp: 1, desc: "è§’è‰²å¯è‹±å‹‡ä»‹å…¥6\"", phases: ["charge"] },
        { name: "è»Œé“å‚³é€", cp: 1, desc: "çµ‚çµè€…å¯å¾é å‚™éšŠ9\"å¤–éƒ¨ç½²", phases: ["movement"] },
        { name: "å‚³å¥‡å …éŸŒ", cp: 1, desc: "æ¸›å°‘1é»å—åˆ°çš„å‚·å®³ï¼ˆæœ€ä½1ï¼‰", phases: ["shooting", "fight"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Terminator")) {
          return { rerollWounds: true, invSave: 4 };
        }
        return {};
      }
    }
  },
  "chaos": {
    "slaves-to-darkness": {
      name: "é»‘æš—å¥´åƒ•",
      description: "Let the Galaxy Burnï¼šæ”»æ“Šç›®æ¨™æ¨™è¨˜ç¯„åœå…§å–®ä½æ™‚è‡´å‚·+1ã€‚",
      effect: "+1 to Wound vs units near objectives",
      apply: (attacker, target, context) => {
        if (context.nearObjective) return { woundBonus: 1 };
        return {};
      }
    }
  },
  "orks": {
    "war-horde": {
      name: "æˆ°çˆ­éƒ¨è½ War Horde",
      description: "æŒçºŒæ‰“æ“Šï¼šæ­å…‹è¿‘æˆ°æ­¦å™¨ç²å¾—[æŒçºŒå‘½ä¸­1]ã€‚",
      effect: "Ork melee weapons gain Sustained Hits 1",
      stratagems: [
        { name: "å¤±æ§è¡æ’", cp: 1, desc: "è¢«æ‘§æ¯€çš„è¼‰å…·å¯ç§»å‹•å¾Œå†çˆ†ç‚¸", phases: ["shooting", "fight"] },
        { name: "æ­å…‹æ°¸ä¸å€’", cp: 2, desc: "è¢«æ‘§æ¯€çš„æ¨¡å‹å¯å…ˆæ”»æ“Šå†ç§»é™¤", phases: ["fight"] },
        { name: "ç‹‚æš´å± æ®º", cp: 1, desc: "æœªä¿®æ­£5+å‘½ä¸­è¦–ç‚ºè‡´å‘½å‘½ä¸­", phases: ["fight"] },
        { name: "ç¡¬å¦‚é‡˜å­", cp: 1, desc: "æ•µæ–¹è‡´å‚·-1", phases: ["shooting", "fight"] },
        { name: "æš´æ°‘è¦å‰‡", cp: 1, desc: "10+æ¨¡å‹å–®ä½è‡ªå‹•è§£é™¤æˆ°æ…„", phases: ["command"] },
        { name: "è¡å•Šï¼", cp: 1, desc: "æ­¥å…µæ€¥è¡Œå’Œè¡é‹’æ“²éª°+2", phases: ["movement", "charge"] }
      ],
      apply: (attacker, target, context) => {
        if (context.phase === "fight") {
          return { sustainedHits: 1 };
        }
        return {};
      }
    },
    "da-big-hunt": {
      name: "å¤§ç‹©çµ Da Big Hunt",
      description: "ç‹©çµç›®æ¨™ï¼šæ¯æŒ‡æ®éšæ®µé¸æ“‡æ•µæ–¹æ€ªç¸/è¼‰å…·/è»é–¥ç‚ºçµç‰©ã€‚ç¸è¥²è€…å°çµç‰©é‡æ“²è¡é‹’ï¼ŒAP+1ã€‚",
      effect: "Beast Snaggas re-roll charges and +1 AP vs designated Prey",
      stratagems: [
        { name: "æ‹–å€’ç‰ ", cp: 1, desc: "è¿‘æˆ°ç²å¾—[æŒçºŒå‘½ä¸­1]ï¼Œå°çµç‰©5+è‡´å‘½å‘½ä¸­", phases: ["fight"] },
        { name: "å‹¢ä¸å¯æ“‹", cp: 1, desc: "é¨ä¹˜å–®ä½è¡é‹’æ¯æ¨¡å‹æ“²D6ï¼Œ4+é€ æˆè‡´å‘½å‚·", phases: ["charge"] },
        { name: "æ›´å¤§çš„çµç‰©", cp: 1, desc: "æ€¥è¡Œ/æ’¤é€€å¾Œä»å¯å°çµç‰©è¡é‹’", phases: ["charge"] },
        { name: "ä¼‘æƒ³è·‘", cp: 1, desc: "æ•µäººæ’¤é€€å¾Œå¯ç§»å‹•6\"è¿½æ“Š", phases: ["movement"] },
        { name: "æ½›è¡Œæˆ°è¡“", cp: 1, desc: "ç²å¾—æ©è­·ï¼›æ­¥å…µé¡å¤–ç²å¾—éš±åŒ¿", phases: ["shooting"] },
        { name: "æœ¬èƒ½çµæ‰‹", cp: 1, desc: "æˆ°é¬¥å¾Œå¯ç§»é™¤é€²å…¥é å‚™éšŠ", phases: ["fight"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Beast Snagga")) {
          let bonus = { rerollCharge: true };
          if (target?.keywords?.includes("Monster") || target?.keywords?.includes("Vehicle") || target?.isWarlord) {
            bonus.apBonus = 1;
          }
          return bonus;
        }
        return {};
      }
    },
    "kult-of-speed": {
      name: "é€Ÿåº¦å´‡æ‹œ Kult of Speed",
      description: "æ€¥é€Ÿç‹‚å¾’ï¼šé€Ÿåº¦ç‹‚å¾’å–®ä½æ€¥è¡Œæˆ–æ’¤é€€å¾Œä»å¯å°„æ“Šå’Œè¡é‹’ã€‚",
      effect: "Speed Freeks can shoot and charge after Advance or Fall Back",
      stratagems: [
        { name: "æœ€å¿«ç‹‚å¾’", cp: 1, desc: "ç²å¾—5+ç„¡æ•µï¼ˆT8ä»¥ä¸‹è¼‰å…·4+ï¼‰", phases: ["shooting", "fight"] },
        { name: "æŠ•æ“²æ¾é¼ ", cp: 1, desc: "9\"å…§æ•µäººé ˆé€²è¡Œæˆ°æ…„æ¸¬è©¦-1", phases: ["shooting"] },
        { name: "ç«åŠ›é¢¨æš´", cp: 1, desc: "å°„æ“Šç²å¾—[æŒçºŒå‘½ä¸­1]ï¼Œ9\"å…§ç‚º[æŒçºŒå‘½ä¸­2]", phases: ["shooting"] },
        { name: "é–ƒæ“Šå°„æ“Š", cp: 1, desc: "å°„æ“Šç²å¾—[è‡´å‘½å‘½ä¸­]ï¼Œ9\"å…§5+ç‚ºè‡´å‘½å‘½ä¸­", phases: ["shooting"] },
        { name: "å…¨é€Ÿå‰é€²", cp: 1, desc: "è¡é‹’å¾Œè¿‘æˆ°è‡´å‚·+1", phases: ["fight"] },
        { name: "æ›´å¤šå°å­", cp: 1, desc: "æ•µäººé€²å…¥9\"å…§å¾Œå¯ç§»å‹•6\"", phases: ["movement"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Speed Freeks") || attacker.keywords?.includes("Vehicle")) {
          return { advanceAndShoot: true, advanceAndCharge: true, fallBackAndShoot: true };
        }
        return {};
      }
    },
    "dread-mob": {
      name: "ææ‡¼æš´æ°‘ Dread Mob",
      description: "æ©Ÿæ¢°ç‹‚ç†±ï¼šæ©Ÿå¸«/æ­¥è¡Œæ©Ÿ/æ ¼é›·ç´è¼‰å…·å°„æ“Š/è¿‘æˆ°æ™‚æ“²D6ç²å¾—éš¨æ©ŸåŠ æˆã€‚",
      effect: "Roll D6 for random weapon abilities; Gretchin gain Battleline",
      stratagems: [
        { name: "é—é˜å·¨çˆª", cp: 1, desc: "è¿‘æˆ°S+2ï¼Œå‚·å®³+1ï¼Œç²å¾—[å±éšª]", phases: ["fight"] },
        { name: "è¶…ç´šç‡ƒæ–™", cp: 1, desc: "é‡æ“²æ€¥è¡Œï¼›å°„æ“Šç²å¾—[çªæ“Š]", phases: ["movement", "shooting"] },
        { name: "å¤§å‚¢ä¼™å°ˆç”¨å½ˆ", cp: 1, desc: "å°æ€ªç¸/è¼‰å…·è‡´å‚·+1ï¼Œç²å¾—[å±éšª]", phases: ["shooting"] },
        { name: "å™ å™ å™ ï¼", cp: 1, desc: "é‡æ“²å‘½ä¸­1ï¼ˆæ¨é€²æ™‚é‡æ“²å…¨éƒ¨ï¼‰ï¼Œç²å¾—[å±éšª]", phases: ["shooting"] },
        { name: "ç‹¡çŒ¾å°é¬¼", cp: 1, desc: "æ ¼é›·ç´å°æ•µäººé€ æˆD3+1è‡´å‘½å‚·ä¸¦ç§»å‹•6\"", phases: ["movement"] },
        { name: "é¡å¤–é›¶ä»¶", cp: 1, desc: "æ­¥è¡Œæ©Ÿ/è¼‰å…·å—å‚·å‚·å®³-1", phases: ["shooting", "fight"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Walker") || attacker.keywords?.includes("Mek")) {
          const roll = Math.floor(Math.random() * 6) + 1;
          if (roll <= 2) return { sustainedHits: 1 };
          if (roll <= 4) return { lethalHits: true };
          return { criticalWoundAP: 1 };
        }
        return {};
      }
    },
    "green-tide": {
      name: "ç¶ æ½® Green Tide",
      description: "æš´æ°‘å¿ƒæ…‹ï¼šæ­¥å…µå–®ä½ç²å¾—5+ç„¡æ•µï¼›10+æ¨¡å‹å–®ä½å¯é‡æ“²è±å…1ã€‚",
      effect: "Infantry 5+ invulnerable; 10+ models re-roll saves of 1",
      stratagems: [
        { name: "ç«¶çˆ­æœ¬èƒ½", cp: 1, desc: "è¿‘æˆ°é‡æ“²è‡´å‚·1ï¼ˆ10+æ¨¡å‹é‡æ“²å…¨éƒ¨ï¼‰", phases: ["fight"] },
        { name: "æ¨åœŸæ©Ÿæš´åŠ›", cp: 1, desc: "3\"å…§æ¨¡å‹å¯æ”»æ“Š3\"å…§æ•µäºº", phases: ["fight"] },
        { name: "å¹å™“æ¬Š", cp: 1, desc: "å…©å€‹6\"å…§çš„ç”·å­©å–®ä½è¦–ç‚º10+æ¨¡å‹", phases: ["command"] },
        { name: "ä¾†å§å°å­ï¼", cp: 1, desc: "ç”·å­©å–®ä½æ¢å¾©D3+2æ¨¡å‹", phases: ["command"] },
        { name: "è‚Œè‚‰æµªæ½®", cp: 1, desc: "è¡é‹’æ“²éª°+ç•¶å‰å›åˆæ•¸", phases: ["charge"] },
        { name: "ä¸Šå•Šï¼", cp: 1, desc: "å‘æœ€è¿‘æ•µäººç§»å‹•D6\"ï¼ˆ10+æ¨¡å‹ç§»å‹•6\"ï¼‰", phases: ["movement"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Infantry")) {
          let bonus = { invSave: 5 };
          if (attacker.modelsAlive >= 10) {
            bonus.rerollSaveOnes = true;
          }
          return bonus;
        }
        return {};
      }
    },
    "bully-boyz": {
      name: "éœ¸å‡Œç”·å­© Bully Boyz",
      description: "é›™é‡WAAAGH!ï¼šå¯ç‚ºå·¨ç”²é ­é ­/é ­é ­/æˆ°çˆ­é ­é ­ç™¼å‹•ç¬¬äºŒæ¬¡WAAAGH!ã€‚",
      effect: "Call a second Waaagh! for Nobz/Meganobz/Warboss units",
      stratagems: [
        { name: "æ­¦è£åˆ°ç‰™", cp: 1, desc: "é ­é ­/å·¨ç”²é‡æ“²å‘½ä¸­1ï¼ˆWAAAGHæ™‚é‡æ“²å…¨éƒ¨ï¼‰", phases: ["shooting", "fight"] },
        { name: "å‚²æ…¢åˆ°æ­»", cp: 1, desc: "è¢«æ‘§æ¯€çš„é ­é ­5+å¯å…ˆæ”»æ“Šï¼ˆWAAAGHæ™‚7+ï¼‰", phases: ["fight"] },
        { name: "æ°¸é æ‰¾èŒ¬", cp: 1, desc: "æ¶ˆæ»…æ•µäººå¾Œæ•´åˆD3+3\"ï¼ˆWAAAGHæ™‚6\"ï¼‰", phases: ["fight"] },
        { name: "ç¢¾å£“è¡æ“Š", cp: 1, desc: "æ¥æˆ°ç¯„åœæ¯æ¨¡å‹æ“²D6ï¼Œ5+è‡´å‘½å‚·ï¼ˆWAAAGHæ™‚4+ï¼‰", phases: ["fight"] },
        { name: "ç å€’ä»–å€‘", cp: 1, desc: "æ•µäººçµ•æœ›é€ƒè„«-1ï¼ˆWAAAGHæ™‚ç”Ÿæ•ˆï¼‰", phases: ["fight"] },
        { name: "é¾å¤§é‡ç¸", cp: 1, desc: "å—åˆ°æ”»æ“ŠAP-1", phases: ["shooting", "fight"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Nobz") || attacker.keywords?.includes("Meganobz") || attacker.name?.includes("é ­é ­")) {
          return { doubleWaaagh: true, feelNoPain: 5 };
        }
        return {};
      }
    },
    "taktikal-brigade": {
      name: "æˆ°è¡“æ—… Taktikal Brigade",
      description: "æˆ°è¡“æŒ‡ä»¤ï¼šé ­é ­/æ©Ÿå¸«/æˆ°çˆ­é ­é ­å¯é€éé ˜å°æ¸¬è©¦çµ¦é™„è¿‘å–®ä½æˆ°è¡“åŠ æˆã€‚",
      effect: "Boss/Mek/Warboss issue Taktiks via Leadership tests",
      stratagems: [
        { name: "é‚£æ˜¯æˆ‘å€‘çš„", cp: 1, desc: "æ¥æˆ°ä¸­å–®ä½OC+1", phases: ["command"] },
        { name: "å¥½å¥½æ‰“", cp: 1, desc: "è¿‘æˆ°é¸æ“‡[æŒçºŒå‘½ä¸­1]æˆ–[è‡´å‘½å‘½ä¸­]", phases: ["fight"] },
        { name: "æˆ°è¡“æ’¤é€€", cp: 1, desc: "æ’¤é€€å¾Œä»å¯å°„æ“Š/è¡é‹’", phases: ["movement"] },
        { name: "ç¢¾å£“é™è‡¨", cp: 1, desc: "é¢¨æš´ç”·å­©è¡é‹’å¾Œ4+é€ æˆè‡´å‘½å‚·", phases: ["charge"] },
        { name: "ä¸‹ä¸€å€‹ç›®æ¨™", cp: 1, desc: "æ•µäººæ’¤é€€å¾Œå¯ç§»å‹•6\"", phases: ["movement"] },
        { name: "æ­»é¬¼æ½›è¡Œ", cp: 1, desc: "çªæ“ŠéšŠ/é¢¨æš´ç”·å­©ç§»é™¤é€²å…¥é å‚™éšŠ", phases: ["movement"] }
      ],
      apply: (attacker, target, context) => {
        if (attacker.keywords?.includes("Character")) {
          return { issueOrders: true, leadershipBonus: 1 };
        }
        return {};
      }
    },
    "more-dakka": {
      name: "æ›´å¤šç«åŠ› More Dakka!",
      description: "ç„¡ç›¡å°„æ“Šï¼šæ­å…‹æ­¥å…µå’Œæ­¥è¡Œæ©Ÿé ç¨‹æ­¦å™¨ç²å¾—[æŒçºŒå‘½ä¸­2]ã€‚",
      effect: "Ork Infantry/Walker ranged weapons gain Sustained Hits 2",
      stratagems: [
        { name: "æ­å…‹é‚„æ˜¯æ­å…‹", cp: 1, desc: "è¿‘æˆ°é‡æ“²è‡´å‚·1ï¼ˆç›®æ¨™é™„è¿‘é‡æ“²å…¨éƒ¨ï¼‰", phases: ["fight"] },
        { name: "è¡å•Šå°å­ï¼", cp: 1, desc: "ç‚ºå–®ä¸€å–®ä½å•Ÿå‹•WAAAGHï¼ˆå³ä½¿å·²ç”¨éï¼‰", phases: ["command"] },
        { name: "è¶…ç´šç‚«è€€", cp: 1, desc: "æ­¥è¡Œæ©ŸM+1ã€Ld+1ã€OC+1ã€å‘½ä¸­+1", phases: ["shooting", "fight"] },
        { name: "é•·æ™‚å¤±æ§æƒå°„", cp: 1, desc: "å°„æ“Šç„¡è¦–18\"å…§æ•µäººæ©è­·", phases: ["shooting"] },
        { name: "ç‰¹æ®Šå½ˆè—¥", cp: 1, desc: "å°18\"å…§æœ€è¿‘æ•µäººå°„æ“ŠAP+1", phases: ["shooting"] },
        { name: "é€™å«ç«åŠ›ï¼Ÿ", cp: 1, desc: "è¢«æ•µäººæ‘§æ¯€æ¨¡å‹å¾Œå¯ç«‹å³å°„æ“Šè©²æ•µäºº", phases: ["shooting", "fight"] }
      ],
      apply: (attacker, target, context) => {
        if ((attacker.keywords?.includes("Infantry") || attacker.keywords?.includes("Walker")) && context.phase === "shooting") {
          return { sustainedHits: 2 };
        }
        return {};
      }
    }
  }
};

// ç©å®¶é¸æ“‡çš„ç¨®æ—è¦å‰‡
let playerDetachments = { 1: null, 2: null };

// ========== å–®ä½è³‡æ–™åº«ï¼ˆæ ¹æ“šå®˜æ–¹10ç‰ˆè¦å‰‡æ›´æ–°ï¼‰==========
const UNIT_DATABASE = {
  "space-marines": {
    name: "æ˜Ÿéš›æˆ°å£«",
    color: "#3b82f6",
    units: [
      {
        id: "sm-captain",
        name: "é€£é•· Captain",
        points: 80,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/f/f6/SMCaptain10th.jpg/250px-SMCaptain10th.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 5, Ld: 6, OC: 1 },
        inv: 4,
        keywords: ["Infantry", "Character"],
        weapons: {
          ranged: { name: "é‡å‹çˆ†çŸ¢æ§", range: 30, A: 4, skill: 2, S: 5, AP: -1, D: 2 },
          melee: { name: "å‹•åŠ›åŠ", A: 5, skill: 2, S: 5, AP: -2, D: 2 }
        },
        abilities: ["é ˜è¢–: 6\"å…§å‹è»é‡æ“²å‘½ä¸­1", "Oath of Moment"]
      },
      {
        id: "sm-intercessors",
        name: "å…ˆé‹’æˆ°å£«Ã—5 Intercessors",
        points: 80,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/2/2a/Intercessor_Models_10E.jpg/300px-Intercessor_Models_10E.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 10, Ld: 6, OC: 2 },
        inv: null,
        keywords: ["Infantry", "Battleline"],
        weapons: {
          ranged: { name: "çˆ†çŸ¢æ­¥æ§ Bolt Rifle", range: 24, A: 2, skill: 3, S: 4, AP: -1, D: 1, keywords: ["Assault", "Heavy"] },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 3, skill: 3, S: 4, AP: 0, D: 1 }
        },
        abilities: ["ç›®æ¨™é–å®š: é¸å®šç›®æ¨™æ™‚+2æ”»æ“Š"]
      },
      {
        id: "sm-tactical",
        name: "æˆ°è¡“å°éšŠÃ—5 Tactical Squad",
        points: 85,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/5/55/TacticalSquad10.jpg/300px-TacticalSquad10.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 10, Ld: 6, OC: 2 },
        inv: null,
        keywords: ["Infantry", "Battleline"],
        weapons: {
          ranged: { name: "çˆ†çŸ¢æ§ Boltgun", range: 24, A: 2, skill: 3, S: 4, AP: 0, D: 1 },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 2, skill: 3, S: 4, AP: 0, D: 1 }
        },
        abilities: ["éˆæ´»éƒ¨ç½²: å¯å¾Œå‚™éƒ¨ç½²"]
      },
      {
        id: "sm-hellblasters",
        name: "åœ°ç„ç«æ§å…µÃ—5 Hellblasters",
        points: 115,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/6/6e/HellblasterMini10th.jpg/180px-HellblasterMini10th.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 10, Ld: 6, OC: 2 },
        inv: null,
        keywords: ["Infantry"],
        weapons: {
          ranged: { name: "ç­‰é›¢å­æ®²æ»…æ§ Plasma Incinerator", range: 24, A: 2, skill: 3, S: 7, AP: -2, D: 2, keywords: ["Hazardous"] },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 2, skill: 3, S: 4, AP: 0, D: 1 }
        },
        abilities: ["éè¼‰: Hazardousæ­¦å™¨"]
      },
      {
        id: "sm-dreadnought",
        name: "ç„¡ç•æ©Ÿç”² Redemptor Dreadnought",
        points: 210,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/c/c6/Redemptor8th.jpeg/220px-Redemptor8th.jpeg",
        stats: { M: 8, T: 10, Sv: 2, W: 12, Ld: 6, OC: 4 },
        inv: null,
        keywords: ["Vehicle", "Walker"],
        weapons: {
          ranged: { name: "é‡å‹ç ²å½ˆåŠ è¾²ç ²", range: 48, A: 6, skill: 3, S: 9, AP: -2, D: 3 },
          melee: { name: "ç„¡ç•ä¹‹æ‹³", A: 5, skill: 3, S: 12, AP: -3, D: 3 }
        },
        abilities: ["å …å®šä¸ç§»: è¡°æ¸›æª”æ¡ˆ"]
      },
      // ===== æ–°å¢ Space Marines å–®ä½ =====
      {
        id: "sm-terminators",
        name: "çµ‚çµè€…Ã—5 Terminators",
        points: 185,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/3/30/TerminatorSquad10th.jpg/250px-TerminatorSquad10th.jpg",
        stats: { M: 5, T: 5, Sv: 2, W: 15, Ld: 6, OC: 1 },
        inv: 4,
        keywords: ["Infantry", "Terminator"],
        weapons: {
          ranged: { name: "é¢¨æš´çˆ†çŸ¢æ§ Storm Bolter", range: 24, A: 2, skill: 3, S: 4, AP: 0, D: 1, keywords: ["Rapid Fire 2"] },
          melee: { name: "å‹•åŠ›æ‹³å¥— Power Fist", A: 3, skill: 3, S: 8, AP: -2, D: 2 }
        },
        abilities: ["æ·±å…¥æ‰“æ“Š", "å …éŸŒ: 4+ç„¡æ•µ"]
      },
      {
        id: "sm-assault-terminators",
        name: "çªæ“Šçµ‚çµè€…Ã—5 Assault Terminators",
        points: 185,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/3/30/TerminatorSquad10th.jpg/250px-TerminatorSquad10th.jpg",
        stats: { M: 5, T: 5, Sv: 2, W: 15, Ld: 6, OC: 1 },
        inv: 4,
        keywords: ["Infantry", "Terminator"],
        weapons: {
          ranged: null,
          melee: { name: "é›·éŒ˜æš´é¢¨ç›¾", A: 3, skill: 4, S: 8, AP: -2, D: 2 }
        },
        abilities: ["æ·±å…¥æ‰“æ“Š", "æš´é¢¨ç›¾: 4+ç„¡æ•µ"]
      },
      {
        id: "sm-assault-marines",
        name: "çªæ“Šé™¸æˆ°éšŠÃ—5 Assault Marines",
        points: 85,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/5/5e/AssaultMarinesMini.jpg/180px-AssaultMarinesMini.jpg",
        stats: { M: 12, T: 4, Sv: 3, W: 10, Ld: 6, OC: 1 },
        inv: null,
        keywords: ["Infantry", "Fly", "Jump Pack"],
        weapons: {
          ranged: { name: "çˆ†çŸ¢æ‰‹æ§ Bolt Pistol", range: 12, A: 1, skill: 3, S: 4, AP: 0, D: 1 },
          melee: { name: "éˆé‹¸åŠ Chainsword", A: 3, skill: 3, S: 4, AP: -1, D: 1 }
        },
        abilities: ["æ·±å…¥æ‰“æ“Š", "é£›è¡Œ"]
      },
      {
        id: "sm-vanguard-veterans",
        name: "å…ˆé‹’è€å…µÃ—5 Vanguard Veterans",
        points: 110,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/5/5e/AssaultMarinesMini.jpg/180px-AssaultMarinesMini.jpg",
        stats: { M: 12, T: 4, Sv: 3, W: 10, Ld: 6, OC: 1 },
        inv: null,
        keywords: ["Infantry", "Fly", "Jump Pack"],
        weapons: {
          ranged: { name: "çˆ†çŸ¢æ‰‹æ§ Bolt Pistol", range: 12, A: 1, skill: 3, S: 4, AP: 0, D: 1 },
          melee: { name: "å‹•åŠ›åŠ", A: 4, skill: 3, S: 5, AP: -2, D: 1 }
        },
        abilities: ["æ·±å…¥æ‰“æ“Š", "é£›è¡Œ"]
      },
      {
        id: "sm-devastators",
        name: "æ¯€æ»…è€…Ã—5 Devastators",
        points: 110,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/6/6a/DevastatorMini10th.jpg/200px-DevastatorMini10th.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 10, Ld: 6, OC: 2 },
        inv: null,
        keywords: ["Infantry"],
        weapons: {
          ranged: { name: "é‡æ­¦å™¨ Heavy Weapons", range: 48, A: 3, skill: 3, S: 9, AP: -3, D: "D6", keywords: ["Heavy"] },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 2, skill: 3, S: 4, AP: 0, D: 1 }
        },
        abilities: ["é‡ç«åŠ›: æœªç§»å‹•æ™‚+1å‘½ä¸­"]
      },
      {
        id: "sm-eradicators",
        name: "æ®²æ»…è€…Ã—3 Eradicators",
        points: 95,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/4/4c/EradicatorsMini.jpg/200px-EradicatorsMini.jpg",
        stats: { M: 5, T: 6, Sv: 3, W: 9, Ld: 6, OC: 1 },
        inv: null,
        keywords: ["Infantry"],
        weapons: {
          ranged: { name: "ç†”æ¯€æ§ Melta Rifle", range: 18, A: 1, skill: 3, S: 9, AP: -4, D: "D6", keywords: ["Melta 2", "Heavy"] },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 2, skill: 3, S: 4, AP: 0, D: 1 }
        },
        abilities: ["æ®²æ»…å”è­°: å¯å°åŒä¸€ç›®æ¨™å°„æ“Šå…©æ¬¡"]
      },
      {
        id: "sm-aggressors",
        name: "ä¾µç•¥è€…Ã—3 Aggressors",
        points: 110,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/a/af/AggressorModels.jpg/200px-AggressorModels.jpg",
        stats: { M: 5, T: 6, Sv: 3, W: 9, Ld: 6, OC: 2 },
        inv: null,
        keywords: ["Infantry", "Gravis"],
        weapons: {
          ranged: { name: "ç«ç„°é¢¨æš´æ‰‹å¥— Flamestorm Gauntlets", range: 12, A: "D6+1", skill: 0, S: 4, AP: 0, D: 1, keywords: ["Torrent", "Twin-linked"] },
          melee: { name: "å‹•åŠ›æ‹³å¥—", A: 3, skill: 3, S: 6, AP: -1, D: 1 }
        },
        abilities: ["è¿‘è·å£“åˆ¶: æœªç§»å‹•æ™‚å°„æ“Šå…©æ¬¡"]
      },
      {
        id: "sm-chaplain",
        name: "ç‰§å¸« Chaplain",
        points: 65,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/6/60/ChaplainPrimaris.jpg/180px-ChaplainPrimaris.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 4, Ld: 5, OC: 1 },
        inv: 4,
        keywords: ["Infantry", "Character"],
        weapons: {
          ranged: { name: "èµ¦ç½ªè€… Absolvor Bolt Pistol", range: 18, A: 1, skill: 2, S: 5, AP: -1, D: 2 },
          melee: { name: "éª·é«æ¬Šæ– Crozius Arcanum", A: 5, skill: 2, S: 6, AP: -1, D: 2 }
        },
        abilities: ["é ˜è¢–: é ˜å°å–®ä½è¿‘æˆ°+1å‘½ä¸­", "æˆ°é¬¥ç¦±è©"]
      },
      {
        id: "sm-librarian",
        name: "åœ–æ›¸é¤¨é•· Librarian",
        points: 75,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/7/70/LibrarianPrimaris10th.jpg/180px-LibrarianPrimaris10th.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 4, Ld: 6, OC: 1 },
        inv: null,
        keywords: ["Infantry", "Character", "Psyker"],
        weapons: {
          ranged: { name: "ç²¾ç¥è¡æ“Š Smite", range: 24, A: "D6", skill: 3, S: 5, AP: -2, D: "D3" },
          melee: { name: "åŠ›é‡ä¹‹æ– Force Stave", A: 4, skill: 3, S: 6, AP: -1, D: "D3" }
        },
        abilities: ["é ˜è¢–", "éˆèƒ½è­·ç›¾: 5+ç„¡æ‡¼æ­»äº¡"]
      },
      {
        id: "sm-apothecary",
        name: "è—¥åŠ‘å¸« Apothecary",
        points: 55,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/6/60/ApothecaryPrimarisModel.jpg/180px-ApothecaryPrimarisModel.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 4, Ld: 6, OC: 1 },
        inv: null,
        keywords: ["Infantry", "Character"],
        weapons: {
          ranged: { name: "èµ¦ç½ªè€…æ‰‹æ§", range: 18, A: 1, skill: 3, S: 5, AP: -1, D: 2 },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 4, skill: 3, S: 4, AP: 0, D: 1 }
        },
        abilities: ["é ˜è¢–: é ˜å°å–®ä½ç²å¾—5+ç„¡æ‡¼æ­»äº¡", "é†«ç™‚: æ¯å›åˆæ¢å¾©D3å‚·å£"]
      },
      {
        id: "sm-rhino",
        name: "çŠ€ç‰›è£ç”²é‹å…µè»Š Rhino",
        points: 75,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/4/4f/RhinoMini10th.jpg/200px-RhinoMini10th.jpg",
        stats: { M: 12, T: 9, Sv: 3, W: 10, Ld: 6, OC: 2 },
        inv: null,
        keywords: ["Vehicle", "Transport", "Dedicated Transport"],
        weapons: {
          ranged: { name: "é¢¨æš´çˆ†çŸ¢æ§", range: 24, A: 2, skill: 3, S: 4, AP: 0, D: 1, keywords: ["Rapid Fire 2"] },
          melee: { name: "æ’æ“Š", A: 3, skill: 4, S: 6, AP: 0, D: 1 }
        },
        abilities: ["é‹è¼¸: 12æ­¥å…µ", "å°„æ“Šè‰™å£6"]
      },
      {
        id: "sm-repulsor",
        name: "æ’æ–¥è€…å¦å…‹ Repulsor",
        points: 195,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/c/ce/RepulsorModel.jpg/220px-RepulsorModel.jpg",
        stats: { M: 10, T: 12, Sv: 3, W: 16, Ld: 6, OC: 5 },
        inv: null,
        keywords: ["Vehicle", "Transport", "Fly"],
        weapons: {
          ranged: { name: "é‡å‹ç ²å½ˆåŠ è¾²ç ²", range: 48, A: 6, skill: 3, S: 9, AP: -2, D: 3 },
          melee: { name: "æ’æ“Š", A: 6, skill: 4, S: 8, AP: -1, D: 2 }
        },
        abilities: ["é‹è¼¸: 12æ­¥å…µ", "æ‡¸æµ®", "è‡´å‘½æœ«æ—¥D6"]
      },
      {
        id: "sm-predator",
        name: "æ å¥ªè€…å¦å…‹ Predator",
        points: 130,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/1/1a/PredatorDestructor10th.jpg/200px-PredatorDestructor10th.jpg",
        stats: { M: 10, T: 10, Sv: 3, W: 11, Ld: 6, OC: 3 },
        inv: null,
        keywords: ["Vehicle"],
        weapons: {
          ranged: { name: "æ å¥ªè€…è‡ªå‹•åŠ è¾²ç ²", range: 48, A: 4, skill: 3, S: 9, AP: -1, D: 3 },
          melee: { name: "æ’æ“Š", A: 3, skill: 4, S: 6, AP: 0, D: 1 }
        },
        abilities: ["è‡´å‘½æœ«æ—¥D3"]
      },
      {
        id: "sm-land-raider",
        name: "é™¸æˆ°å‚³å¥‡ Land Raider",
        points: 240,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/c/ce/LandRaiderMini10th.jpg/200px-LandRaiderMini10th.jpg",
        stats: { M: 10, T: 12, Sv: 2, W: 16, Ld: 6, OC: 5 },
        inv: null,
        keywords: ["Vehicle", "Transport"],
        weapons: {
          ranged: { name: "é›™è¯é‡å‹çˆ†çŸ¢æ§Ã—2", range: 36, A: 6, skill: 3, S: 5, AP: -1, D: 2, keywords: ["Twin-linked"] },
          melee: { name: "æ’æ“Š", A: 6, skill: 4, S: 8, AP: -1, D: 2 }
        },
        abilities: ["é‹è¼¸: 12æ­¥å…µ/6çµ‚çµè€…", "è‡´å‘½æœ«æ—¥D6", "çªæ“Šè¼‰å…·"]
      },
      {
        id: "sm-gladiator",
        name: "è§’é¬¥å£«å¦å…‹ Gladiator",
        points: 155,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/a/a0/GladiatorLancer10th.jpg/200px-GladiatorLancer10th.jpg",
        stats: { M: 10, T: 10, Sv: 3, W: 12, Ld: 6, OC: 3 },
        inv: null,
        keywords: ["Vehicle"],
        weapons: {
          ranged: { name: "é•·æ§é›·å°„ç ²", range: 72, A: 2, skill: 3, S: 14, AP: -3, D: "D6+2", keywords: ["Heavy"] },
          melee: { name: "æ’æ“Š", A: 4, skill: 4, S: 7, AP: 0, D: 1 }
        },
        abilities: ["è‡´å‘½æœ«æ—¥D3", "åè¼‰å…·"]
      }
    ]
  },
  "necrons": {
    name: "æ­»éˆ",
    color: "#22c55e",
    units: [
      { id: "nc-overlord", name: "éœ¸ä¸» Overlord", points: 85, img: "img/Necron/99070110006_OverlordTachyonArrow1.jpg", stats: { M: 5, T: 5, Sv: 2, W: 6, Ld: 6, OC: 1 }, inv: 4, keywords: ["Infantry", "Character"], weapons: { ranged: { name: "è¶…å…‰é€Ÿç®­", range: 72, A: 1, skill: 2, S: 16, AP: -5, D: "D6+2", oneUse: true }, melee: { name: "è™›ç©ºä¹‹åˆƒ", A: 4, skill: 2, S: 8, AP: -3, D: 2 } }, abilities: ["é ˜å°å…‰ç’°", "å¾©æ´»å”è­°"] },
      { id: "nc-silentking", name: "æ²‰é»˜ä¹‹ç‹ Silent King", points: 400, img: "img/Necron/99120110047_NECSzarekhSilentKingLead.jpg", stats: { M: 8, T: 10, Sv: 2, W: 16, Ld: 6, OC: 6 }, inv: 4, keywords: ["Monster", "Character", "Epic Hero"], weapons: { ranged: { name: "æ®²æ»…å…‰æŸ", range: 36, A: 6, skill: 2, S: 12, AP: -4, D: 3 }, melee: { name: "æ°¸æ†æ¬Šæ–", A: 6, skill: 2, S: 10, AP: -4, D: 3 } }, abilities: ["æˆ‘çš„æ„å¿—å³æ³•ä»¤", "å¾©æ´»å”è­°"] },
      { id: "nc-ctan-nightbringer", name: "å¤œé­˜æ˜Ÿç¥ Nightbringer", points: 315, img: "img/Necron/99120110088_NecronsCtanShardOfTheNightbringer01.jpg", stats: { M: 10, T: 11, Sv: 3, W: 16, Ld: 6, OC: 4 }, inv: 4, keywords: ["Monster", "C'tan"], weapons: { ranged: { name: "æ­»äº¡å‡è¦–", range: 18, A: "D3", skill: 2, S: 12, AP: -3, D: "D6+3" }, melee: { name: "æ”¶å‰²ä¹‹é®", A: 6, skill: 2, S: 14, AP: -4, D: "D6+2" } }, abilities: ["å¸å–ç”Ÿå‘½: è¿‘æˆ°å¾Œæ•µè»D3è‡´å‘½å‚·", "ä¸æ»…é‡‘å±¬: å‚·å®³-1", "å¾©æ´»å”è­°"] },
      { id: "nc-ctan-deceiver", name: "æ¬ºè©è€…æ˜Ÿç¥ Deceiver", points: 285, img: "img/Necron/99810110003_TheDeceiverNEW01.jpg", stats: { M: 8, T: 11, Sv: 3, W: 16, Ld: 6, OC: 4 }, inv: 4, keywords: ["Monster", "C'tan"], weapons: { ranged: { name: "å®‡å®™ç˜‹ç‹‚", range: 18, A: 3, skill: 2, S: 10, AP: -3, D: 3 }, melee: { name: "é‡‘è‰²çˆª", A: 6, skill: 2, S: 10, AP: -3, D: 3 } }, abilities: ["æ¬ºè©å¤§å¸«", "å¹»å½±", "ä¸æ»…é‡‘å±¬: å‚·å®³-1"] },
      { id: "nc-skorpekh-lord", name: "æ¯€æ»…è€…é ˜ä¸» Skorpekh Lord", points: 90, img: "img/Necron/99120110051_SkorpekhDestroyersLead.jpg", stats: { M: 8, T: 7, Sv: 3, W: 7, Ld: 6, OC: 2 }, inv: 4, keywords: ["Infantry", "Character", "Destroyer"], weapons: { ranged: null, melee: { name: "è¶…ç›¸ä½æ”¶å‰²å™¨", A: 6, skill: 2, S: 8, AP: -3, D: 2 } }, abilities: ["æ¯€æ»…ç‹‚ç†±", "å¾©æ´»å”è­°"] },
      { id: "nc-chronomancer", name: "æ™‚ç©ºè¡“å£« Chronomancer", points: 65, img: "img/Necron/99070110003_NECChronomancerLead.jpg", stats: { M: 5, T: 4, Sv: 4, W: 4, Ld: 6, OC: 1 }, inv: 4, keywords: ["Infantry", "Character", "Cryptek"], weapons: { ranged: null, melee: { name: "æ°¸æ†ä¹‹æ–", A: 3, skill: 3, S: 5, AP: -2, D: 2 } }, abilities: ["æ™‚é–“æ“æ§: 5+ç„¡è¦–å‚·å®³", "å¾©æ´»å”è­°"] },
      { id: "nc-technomancer", name: "æŠ€è¡“è¡“å£« Technomancer", points: 80, img: "img/Necron/99070110005_NECCryptekLead.jpg", stats: { M: 10, T: 4, Sv: 4, W: 4, Ld: 6, OC: 1 }, inv: null, keywords: ["Infantry", "Character", "Cryptek"], weapons: { ranged: { name: "å…‰æ–", range: 18, A: 2, skill: 3, S: 5, AP: -2, D: 1 }, melee: { name: "å…‰æ–", A: 2, skill: 3, S: 5, AP: -2, D: 1 } }, abilities: ["ä¿®å¾©å”è­°", "å¾©æ´»å”è­°"] },
      { id: "nc-immortals", name: "ä¸æœ½è€…Ã—5 Immortals", points: 70, img: "img/Necron/99120110057_NECImmortalsLead.jpg", stats: { M: 5, T: 5, Sv: 3, W: 5, Ld: 7, OC: 2 }, inv: null, keywords: ["Infantry", "Battleline"], weapons: { ranged: { name: "é«˜æ–¯çˆ†èƒ½æ§", range: 24, A: 2, skill: 3, S: 5, AP: -1, D: 1 }, melee: { name: "æ©Ÿæ¢°çˆª", A: 2, skill: 3, S: 4, AP: 0, D: 1 } }, abilities: ["è‡´å‘½å‘½ä¸­", "å¾©æ´»å”è­°"] },
      { id: "nc-warriors", name: "æˆ°å£«Ã—10 Warriors", points: 90, img: "img/Necron/99120110052_NecronWarriorsLead.jpg", stats: { M: 5, T: 4, Sv: 4, W: 10, Ld: 7, OC: 2 }, inv: null, keywords: ["Infantry", "Battleline"], weapons: { ranged: { name: "é«˜æ–¯é•·ç¬›", range: 24, A: 1, skill: 4, S: 4, AP: 0, D: 1 }, melee: { name: "æ©Ÿæ¢°çˆª", A: 1, skill: 4, S: 4, AP: 0, D: 1 } }, abilities: ["è‡´å‘½å‘½ä¸­", "å¾©æ´»å”è­°"] },
      { id: "nc-lychguard", name: "æš—è¡›Ã—5 Lychguard", points: 85, img: "img/Necron/99120110058_TriarchLychguardLead.jpg", stats: { M: 5, T: 5, Sv: 3, W: 10, Ld: 7, OC: 1 }, inv: 4, keywords: ["Infantry"], weapons: { ranged: null, melee: { name: "æˆ°é®", A: 2, skill: 3, S: 8, AP: -3, D: 2 } }, abilities: ["è­·è¡›å”è­°", "å¾©æ´»å”è­°"] },
      { id: "nc-skorpekh", name: "æ¯€æ»…è€…Ã—3 Skorpekh Destroyers", points: 90, img: "img/Necron/99120110051_SkorpekhDestroyersLead.jpg", stats: { M: 8, T: 6, Sv: 3, W: 9, Ld: 7, OC: 2 }, inv: null, keywords: ["Infantry", "Destroyer"], weapons: { ranged: null, melee: { name: "è¶…ç›¸ä½æ­¦å™¨", A: 4, skill: 3, S: 7, AP: -2, D: 2 } }, abilities: ["æ¯€æ»…ç‹‚ç†±", "å¾©æ´»å”è­°"] },
      { id: "nc-deathmarks", name: "æ­»äº¡æ¨™è¨˜Ã—5 Deathmarks", points: 60, img: "img/Necron/99120110057_NECImmortalsGroup2.jpg", stats: { M: 5, T: 5, Sv: 3, W: 5, Ld: 7, OC: 1 }, inv: null, keywords: ["Infantry"], weapons: { ranged: { name: "çªè§¸ç“¦è§£æ§", range: 36, A: 1, skill: 3, S: 5, AP: -2, D: 2 }, melee: { name: "æ©Ÿæ¢°çˆª", A: 1, skill: 4, S: 4, AP: 0, D: 1 } }, abilities: ["ç‹™æ“Š", "æ·±å…¥æ‰“æ“Š"] },
      { id: "nc-flayed", name: "å‰çš®è€…Ã—5 Flayed Ones", points: 60, img: "img/Necron/99120110056_NECFlayedOnesLead.jpg", stats: { M: 5, T: 4, Sv: 4, W: 5, Ld: 7, OC: 1 }, inv: null, keywords: ["Infantry"], weapons: { ranged: null, melee: { name: "å‰çš®çˆª", A: 4, skill: 3, S: 4, AP: -1, D: 1 } }, abilities: ["ææ‡¼", "æ·±å…¥æ‰“æ“Š"] },
      { id: "nc-triarch", name: "ä¸‰çš‡ç¦è¡›Ã—5 Triarch Praetorians", points: 90, img: "img/Necron/99120110058_NecronsTriarchPraetoriansLead.jpg", stats: { M: 10, T: 5, Sv: 3, W: 10, Ld: 7, OC: 1 }, inv: null, keywords: ["Infantry", "Fly"], weapons: { ranged: { name: "è–ç´„ä¹‹æ–", range: 12, A: 2, skill: 3, S: 5, AP: -2, D: 1 }, melee: { name: "è–ç´„ä¹‹æ–", A: 3, skill: 3, S: 5, AP: -2, D: 1 } }, abilities: ["é£›è¡Œ", "å¾©æ´»å”è­°"] },
      { id: "nc-ophydian", name: "è›‡å½¢æ¯€æ»…è€…Ã—3 Ophydian Destroyers", points: 80, img: "img/Necron/99120110053_NECOphydianDestroyersLead.jpg", stats: { M: 10, T: 5, Sv: 4, W: 9, Ld: 7, OC: 2 }, inv: null, keywords: ["Infantry", "Destroyer"], weapons: { ranged: null, melee: { name: "è¶…ç›¸ä½æ­¦å™¨", A: 5, skill: 3, S: 6, AP: -2, D: 2 } }, abilities: ["æ·±å…¥æ‰“æ“Š", "å¾©æ´»å”è­°"] },
      { id: "nc-wraiths", name: "å¹½éˆÃ—3 Canoptek Wraiths", points: 110, img: "img/Necron/99120110060_NECCanoptekWraithsLead.jpg", stats: { M: 10, T: 6, Sv: 3, W: 12, Ld: 8, OC: 2 }, inv: 4, keywords: ["Beast", "Fly", "Canoptek"], weapons: { ranged: null, melee: { name: "æƒ¡æ¯’çˆª", A: 4, skill: 3, S: 6, AP: -2, D: 2 } }, abilities: ["ç›¸ä½å½¢æ…‹: ç©¿ç‰†", "å¾©æ´»å”è­°"] },
      { id: "nc-scarabs", name: "ç”²èŸ²ç¾¤Ã—3 Scarab Swarms", points: 40, img: "img/Necron/99120110061_CanoptekSpyderLead.jpg", stats: { M: 10, T: 2, Sv: 6, W: 12, Ld: 8, OC: 0 }, inv: null, keywords: ["Swarm", "Fly", "Canoptek"], weapons: { ranged: null, melee: { name: "é¤µé£Ÿé¡", A: 6, skill: 5, S: 2, AP: 0, D: 1 } }, abilities: ["è‡ªçˆ†æ”»æ“Š"] },
      { id: "nc-doomstalker", name: "æœ«æ—¥è¡Œè€… Doomstalker", points: 140, img: "img/Necron/99120110045_CanoptekDoomstalkerLead.jpg", stats: { M: 8, T: 8, Sv: 3, W: 12, Ld: 8, OC: 4 }, inv: 4, keywords: ["Vehicle", "Canoptek"], weapons: { ranged: { name: "æœ«æ—¥çˆ†èƒ½ç ²", range: 48, A: "D6+1", skill: 4, S: 14, AP: -3, D: 3 }, melee: { name: "æ©Ÿæ¢°è‚¢", A: 3, skill: 4, S: 6, AP: 0, D: 1 } }, abilities: ["é‡ç«åŠ›æ¨¡å¼"] },
      { id: "nc-doomsdayark", name: "æœ«æ—¥æ–¹èˆŸ Doomsday Ark", points: 200, img: "img/Necron/99120110063_NECDoomsdayArkLead.jpg", stats: { M: 10, T: 9, Sv: 3, W: 14, Ld: 7, OC: 5 }, inv: 4, keywords: ["Vehicle"], weapons: { ranged: { name: "æœ«æ—¥ç ²", range: 48, A: "D6+2", skill: 4, S: 15, AP: -4, D: 4 }, melee: { name: "æ©Ÿæ¢°è‚¢", A: 3, skill: 4, S: 6, AP: 0, D: 1 } }, abilities: ["é‡ç«åŠ›å¹³å°"] },
      { id: "nc-annihilation", name: "æ®²æ»…é§èˆ¹ Annihilation Barge", points: 105, img: "img/Necron/99120110064_CatacombAnnihilationBargeLead.jpg", stats: { M: 10, T: 8, Sv: 3, W: 9, Ld: 7, OC: 3 }, inv: null, keywords: ["Vehicle"], weapons: { ranged: { name: "é›™è¯ç‰¹æ–¯æ‹‰æ¯€æ»…è€…", range: 24, A: 8, skill: 4, S: 8, AP: 0, D: 2 }, melee: { name: "æ©Ÿæ¢°è‚¢", A: 3, skill: 4, S: 6, AP: 0, D: 1 } }, abilities: ["æŒçºŒå‘½ä¸­2"] },
      { id: "nc-ghostark", name: "å¹½éˆæ–¹èˆŸ Ghost Ark", points: 115, img: "img/Necron/99120110063_NECGhostArkLead.jpg", stats: { M: 10, T: 9, Sv: 3, W: 14, Ld: 7, OC: 3 }, inv: null, keywords: ["Vehicle"], weapons: { ranged: { name: "é«˜æ–¯é•·ç¬›é™£åˆ—", range: 24, A: 20, skill: 4, S: 4, AP: 0, D: 1 }, melee: { name: "æ©Ÿæ¢°è‚¢", A: 3, skill: 4, S: 6, AP: 0, D: 1 } }, abilities: ["é‹è¼¸: 10æ¨¡å‹", "ä¿®å¾©å”è­°"] },
      { id: "nc-monolith", name: "é‡‘å­—å¡” Monolith", points: 400, img: "img/Necron/99120110043_NECMonolithLead.jpg", stats: { M: 8, T: 13, Sv: 2, W: 22, Ld: 7, OC: 8 }, inv: 4, keywords: ["Vehicle", "Titanic"], weapons: { ranged: { name: "ç²’å­é­", range: 24, A: 6, skill: 3, S: 12, AP: -3, D: 3 }, melee: { name: "å·¨å‹æ©Ÿæ¢°è‚¢", A: 6, skill: 4, S: 10, AP: -2, D: 2 } }, abilities: ["å‚³é€é–€", "ä¸å¯æ‘§æ¯€"] },
      { id: "nc-lokhust", name: "é‡å‹æ¯€æ»…è€… Lokhust Heavy Destroyers", points: 55, img: "img/Necron/99120110044_LokhustHeavyDestroyerLead.jpg", stats: { M: 8, T: 6, Sv: 3, W: 4, Ld: 7, OC: 2 }, inv: null, keywords: ["Destroyer", "Mounted"], weapons: { ranged: { name: "é«˜æ–¯æ¯€æ»…è€…", range: 36, A: 2, skill: 3, S: 10, AP: -3, D: 4 }, melee: { name: "æ©Ÿæ¢°çˆª", A: 2, skill: 4, S: 5, AP: 0, D: 1 } }, abilities: ["é‡ç«åŠ›", "å¾©æ´»å”è­°"] },
      { id: "nc-triarchstalker", name: "ä¸‰çš‡è¿½çµè€… Triarch Stalker", points: 110, img: "img/Necron/99120110058_NecronTriarchStalkerLead.jpg", stats: { M: 8, T: 8, Sv: 3, W: 12, Ld: 7, OC: 4 }, inv: null, keywords: ["Vehicle", "Walker"], weapons: { ranged: { name: "ç†±èƒ½å°„ç·š", range: 18, A: 2, skill: 3, S: 12, AP: -4, D: "D6" }, melee: { name: "å·¨çˆª", A: 4, skill: 4, S: 8, AP: -2, D: 2 } }, abilities: ["ç›®æ¨™é–å®š", "å¾©æ´»å”è­°"] },
      // ===== Faction Pack æ–°å–®ä½ =====
      { id: "nc-ctan-voiddragon", name: "è™›ç©ºé¾æ˜Ÿç¥ Void Dragon", points: 295, img: "img/Necron/99120110054_CTanShardoftheVoidDragonLead.jpg", stats: { M: 10, T: 11, Sv: 3, W: 16, Ld: 6, OC: 4 }, inv: 4, keywords: ["Monster", "C'tan"], weapons: { ranged: { name: "è™›ç©ºä¹‹çŸ›", range: 12, A: "D3", skill: 2, S: 8, AP: -3, D: "D6+2", keywords: ["Anti-Vehicle 2+"] }, melee: { name: "è™›ç©ºä¹‹çŸ›", A: 5, skill: 2, S: 12, AP: -4, D: "D6+2" } }, abilities: ["ç‰©è³ªå¸æ”¶", "ä¸æ»…é‡‘å±¬", "å¾©æ´»å”è­°"] },
      { id: "nc-ctan-transcendent", name: "è¶…è¶Šæ˜Ÿç¥ Transcendent C'tan", points: 270, img: "img/Necron/99120110026_NecronTesseract01.jpg", stats: { M: 8, T: 11, Sv: 3, W: 16, Ld: 6, OC: 4 }, inv: 4, keywords: ["Monster", "C'tan"], weapons: { ranged: { name: "åœ°éœ‡æ”»æ“Š", range: 12, A: 6, skill: 2, S: 8, AP: -2, D: 2 }, melee: { name: "è£‚ç¸«è§¸æ‰‹", A: 8, skill: 2, S: 10, AP: -3, D: "D6" } }, abilities: ["è·¨ç¶­å‚³é€", "ä¸æ»…é‡‘å±¬", "å¾©æ´»å”è­°"] },
      { id: "nc-macrocytes", name: "å·¨ç´°èƒç¾¤Ã—5 Canoptek Macrocytes", points: 60, img: "img/Necron/99120110061_CanoptekSpyderLead.jpg", stats: { M: 8, T: 3, Sv: 4, W: 5, Ld: 8, OC: 1 }, inv: null, keywords: ["Beast", "Fly", "Canoptek"], weapons: { ranged: { name: "é«˜æ–¯è§£å‰–åˆ€", range: 18, A: 1, skill: 4, S: 4, AP: -1, D: 1, keywords: ["Lethal Hits"] }, melee: { name: "çˆªç‰™", A: 2, skill: 4, S: 4, AP: -1, D: 1 } }, abilities: ["åµå¯Ÿ8\"", "é¨·æ“¾ç¾¤: 3\"å…§æ•µè»-1å‘½ä¸­", "å¾©æ´»å”è­°"] },
      { id: "nc-tombcrawlers", name: "å¢“ç©´çˆ¬è¡Œè€…Ã—2 Tomb Crawlers", points: 50, img: "img/Necron/99120110061_CanoptekSpyderLead.jpg", stats: { M: 5, T: 4, Sv: 3, W: 6, Ld: 8, OC: 1 }, inv: null, keywords: ["Beast", "Canoptek"], weapons: { ranged: { name: "é›™è¯é«˜æ–¯æ”¶å‰²è€…", range: 12, A: 2, skill: 4, S: 4, AP: -1, D: 1 }, melee: { name: "çˆªç‰™", A: 4, skill: 4, S: 6, AP: -1, D: 1 } }, abilities: ["æ­¦å™¨å“¨å…µ: 12\"å…§ç„¡è¦–ä¿®æ­£", "å¾©æ´»å”è­°"] },
      { id: "nc-geomancer", name: "åœ°è¡“å£« Geomancer", points: 70, img: "img/Necron/99070110005_NECCryptekLead.jpg", stats: { M: 8, T: 4, Sv: 4, W: 4, Ld: 6, OC: 1 }, inv: null, keywords: ["Infantry", "Character", "Cryptek"], weapons: { ranged: { name: "éœ‡é¡«æˆŸ-å°„ç·š", range: 18, A: 2, skill: 4, S: 8, AP: -2, D: 2, keywords: ["Melta 2"] }, melee: { name: "éœ‡é¡«æˆŸ", A: 2, skill: 4, S: 8, AP: -2, D: 2 } }, abilities: ["åœ°éœ‡æ³¢å‹•: æ•µè»-2ç§»å‹•å’Œè¡é‹’", "é ˜å°è€…", "å¾©æ´»å”è­°"] },
      { id: "nc-nekrosor", name: "æ­»äº¡é ˜ä¸» Nekrosor Ammentar", points: 150, img: "img/Necron/99120110089_NecronsNekrosorAmmentar01.jpg", stats: { M: 10, T: 8, Sv: 3, W: 9, Ld: 6, OC: 3 }, inv: 4, keywords: ["Infantry", "Character", "Epic Hero", "Destroyer"], weapons: { ranged: { name: "æ¯€æ»…ç“¦è§£å™¨", range: 18, A: 4, skill: 2, S: 6, AP: -2, D: 1, keywords: ["Pistol", "Ignores Cover", "Sustained Hits 2"] }, melee: { name: "æ¯€æ»…æ‰‹å¥—", A: 6, skill: 2, S: 10, AP: -3, D: 3 } }, abilities: ["æ¯€æ»…ç‹‚ç†±å…‰ç’°: 6\"å…§æŒçºŒå‘½ä¸­1", "æ·±å…¥æ‰“æ“Š", "å…ˆæ”»", "å¾©æ´»å”è­°"] },
      // ===== æ›´å¤šå–®ä½ =====
      { id: "nc-hexmark", name: "å…­æ¨™æ¯€æ»…è€… Hexmark Destroyer", points: 70, img: "img/Necron/99120110048_HexmarkDestroyerLead.jpg", stats: { M: 7, T: 5, Sv: 3, W: 4, Ld: 7, OC: 1 }, inv: null, keywords: ["Infantry", "Character", "Destroyer"], weapons: { ranged: { name: "ç£è»Œæ‰‹æ§Ã—6", range: 18, A: 6, skill: 2, S: 6, AP: -1, D: 1, keywords: ["Pistol", "Precision"] }, melee: { name: "æ©Ÿæ¢°çˆª", A: 3, skill: 3, S: 5, AP: 0, D: 1 } }, abilities: ["å¤šç›®æ¨™å”è­°: å¯å°„æ“Š6å€‹ä¸åŒç›®æ¨™", "æ·±å…¥æ‰“æ“Š", "å¾©æ´»å”è­°"] },
      { id: "nc-royalwarden", name: "çš‡å®¶ç›£å¯Ÿå®˜ Royal Warden", points: 40, img: "img/Necron/99070110007_RoyalWarden1.jpg", stats: { M: 5, T: 5, Sv: 3, W: 4, Ld: 6, OC: 1 }, inv: null, keywords: ["Infantry", "Character"], weapons: { ranged: { name: "é«˜æ–¯çˆ†èƒ½æ§", range: 24, A: 2, skill: 3, S: 5, AP: -1, D: 1 }, melee: { name: "æ©Ÿæ¢°çˆª", A: 3, skill: 3, S: 5, AP: 0, D: 1 } }, abilities: ["æ’¤é€€é–‹ç«", "é ˜å°è€…", "å¾©æ´»å”è­°"] },
      { id: "nc-psychomancer", name: "éˆèƒ½è¡“å£« Psychomancer", points: 50, img: "img/Necron/99120110073_NECPsychomancerLead.jpg", stats: { M: 5, T: 4, Sv: 4, W: 4, Ld: 6, OC: 1 }, inv: 4, keywords: ["Infantry", "Character", "Cryptek"], weapons: { ranged: { name: "å¹»ç›¸æŠ•å°„å™¨", range: 18, A: "D6", skill: 3, S: 4, AP: -1, D: 1, keywords: ["Torrent"] }, melee: { name: "å¹»å½±ä¹‹åˆƒ", A: 3, skill: 3, S: 5, AP: -2, D: 1 } }, abilities: ["ææ‡¼å…‰ç’°: æ•µè»-1é ˜å°", "é ˜å°è€…", "å¾©æ´»å”è­°"] },
      { id: "nc-tombblades", name: "å¢“ç©´åˆ€é‹’Ã—3 Tomb Blades", points: 75, img: "img/Necron/99120110059_NECTombBladesLead.jpg", stats: { M: 12, T: 5, Sv: 3, W: 6, Ld: 7, OC: 2 }, inv: null, keywords: ["Mounted", "Fly"], weapons: { ranged: { name: "é›™è¯é«˜æ–¯çˆ†èƒ½æ§", range: 24, A: 4, skill: 3, S: 5, AP: -1, D: 1, keywords: ["Twin-linked"] }, melee: { name: "æ©Ÿæ¢°è‚¢", A: 2, skill: 4, S: 4, AP: 0, D: 1 } }, abilities: ["åµå¯Ÿ12\"", "å¾©æ´»å”è­°"] },
      { id: "nc-doomscythe", name: "æœ«æ—¥é®åˆ€ Doom Scythe", points: 200, img: "img/Necron/99120110065_DoomScytheLead.jpg", stats: { M: 20, T: 9, Sv: 3, W: 12, Ld: 7, OC: 0 }, inv: 4, keywords: ["Vehicle", "Aircraft", "Fly"], weapons: { ranged: { name: "æ­»äº¡å°„ç·š", range: 36, A: 1, skill: 3, S: 16, AP: -4, D: "D6+2", keywords: ["Blast"] }, melee: null }, abilities: ["è‡´å‘½æœ«æ—¥D6", "æ‡¸åœ"] },
      { id: "nc-commandbarge", name: "æŒ‡æ®é§èˆ¹ Catacomb Command Barge", points: 130, img: "img/Necron/99120110064_CatacombCommandBargeLead.jpg", stats: { M: 9, T: 8, Sv: 3, W: 9, Ld: 6, OC: 3 }, inv: 4, keywords: ["Vehicle", "Character"], weapons: { ranged: { name: "ç‰¹æ–¯æ‹‰ç ²", range: 24, A: 4, skill: 3, S: 7, AP: 0, D: 2, keywords: ["Sustained Hits 2"] }, melee: { name: "è™›ç©ºä¹‹åˆƒ", A: 4, skill: 2, S: 8, AP: -3, D: 2 } }, abilities: ["æˆ‘çš„æ„å¿—å³æ³•ä»¤", "å¾©æ´»å”è­°"] },
      { id: "nc-spyder", name: "åè«¾åŒ¹å…‹èœ˜è›› Canoptek Spyder", points: 75, img: "img/Necron/99120110061_CanoptekSpyderLead.jpg", stats: { M: 8, T: 7, Sv: 3, W: 6, Ld: 8, OC: 2 }, inv: null, keywords: ["Monster", "Canoptek"], weapons: { ranged: { name: "ç²’å­æŠ•å°„å™¨", range: 12, A: "D6", skill: 4, S: 6, AP: 0, D: 1, keywords: ["Blast"] }, melee: { name: "è‡ªå‹•ä¿®å¾©çˆª", A: 4, skill: 4, S: 8, AP: -2, D: 2 } }, abilities: ["ä¿®å¾©å”è­°: æ¯å›åˆæ²»ç™‚D3", "è£½é€ ç”²èŸ²", "å¾©æ´»å”è­°"] },
      { id: "nc-lokhust-destroyers", name: "æ´›åº«æ–¯ç‰¹æ¯€æ»…è€…Ã—3 Lokhust Destroyers", points: 90, img: "img/Necron/99120110071_NecronDestroyerretoolGroup.jpg", stats: { M: 8, T: 6, Sv: 3, W: 9, Ld: 7, OC: 2 }, inv: null, keywords: ["Mounted", "Fly", "Destroyer"], weapons: { ranged: { name: "é«˜æ–¯åŠ è¾²ç ²", range: 24, A: 3, skill: 3, S: 6, AP: -1, D: 2 }, melee: { name: "æ©Ÿæ¢°çˆª", A: 2, skill: 4, S: 5, AP: 0, D: 1 } }, abilities: ["æ¯€æ»…ç‹‚ç†±", "å¾©æ´»å”è­°"] },
      // ===== å‚³å¥‡è‹±é›„ =====
      { id: "nc-imotekh", name: "ä¼Šè«æ³°å…‹é¢¨æš´é ˜ä¸» Imotekh", points: 100, img: "img/Necron/99120110078_NECImotekhTheStormlord01.jpg", stats: { M: 5, T: 5, Sv: 2, W: 6, Ld: 5, OC: 1 }, inv: 4, keywords: ["Infantry", "Character", "Epic Hero"], weapons: { ranged: { name: "é¢¨æš´å¬å–š", range: 24, A: 6, skill: 2, S: 6, AP: -2, D: 2, keywords: ["Devastating Wounds"] }, melee: { name: "æˆ°é®", A: 4, skill: 2, S: 8, AP: -3, D: 2 } }, abilities: ["é¢¨æš´é ˜ä¸»: å‹è»6\"å…§+1å‘½ä¸­", "æˆ‘çš„æ„å¿—å³æ³•ä»¤", "å¾©æ´»å”è­°"] },
      { id: "nc-trazyn", name: "ç‰¹æ‹‰æ´¥ç„¡ç›¡è€… Trazyn the Infinite", points: 75, img: "img/Necron/99800110009_TrazynTheInfiniteNEW01.jpg", stats: { M: 5, T: 5, Sv: 2, W: 6, Ld: 6, OC: 1 }, inv: 4, keywords: ["Infantry", "Character", "Epic Hero"], weapons: { ranged: null, melee: { name: "æ™‚é–“ä¹‹çŸ›", A: 4, skill: 2, S: 8, AP: -3, D: 3 } }, abilities: ["æ”¶è—å®¶: æ“Šæ®ºè§’è‰²ç²å¾—1VP", "æ›¿èº«: å¯å°‡å‚·å®³è½‰ç§»çµ¦å‹è»", "å¾©æ´»å”è­°"] },
      { id: "nc-orikan", name: "å¥§é‡Œåå åœè€… Orikan the Diviner", points: 80, img: "img/Necron/99120110081_OrikanDiviner1.jpg", stats: { M: 5, T: 4, Sv: 4, W: 4, Ld: 6, OC: 1 }, inv: 4, keywords: ["Infantry", "Character", "Epic Hero", "Cryptek"], weapons: { ranged: { name: "æ™‚é–“åˆº", range: 18, A: 3, skill: 2, S: 6, AP: -2, D: 2 }, melee: { name: "æ™‚é–“ä¹‹æ–", A: 3, skill: 3, S: 5, AP: -2, D: "D3" } }, abilities: ["é è¨€: å¯é‡æ“²ä»»ä½•1æ¬¡æ“²éª°", "æ˜Ÿç¥åŒ–èº«: å›åˆ3+å¯å‡ç´šæ•¸æ“š", "å¾©æ´»å”è­°"] },
      { id: "nc-szeras", name: "ä¼Šé­¯ç±³è«¾Â·å¡æ‹‰æ–¯ Illuminor Szeras", points: 105, img: "img/Necron/99120110049_IlluminorSzerasLead.jpg", stats: { M: 7, T: 6, Sv: 3, W: 7, Ld: 6, OC: 2 }, inv: 4, keywords: ["Monster", "Character", "Epic Hero", "Cryptek"], weapons: { ranged: { name: "éˆèƒ½æ‰“æ“Š", range: 18, A: 2, skill: 2, S: 9, AP: -3, D: 3 }, melee: { name: "æ”¹é€ çˆª", A: 5, skill: 3, S: 6, AP: -2, D: 2 } }, abilities: ["æ©Ÿæ¢°ç”Ÿç‰©å¢å¼·: æ¯å›åˆ+1å‹è»æ•¸æ“š", "é ˜å°è€…", "å¾©æ´»å”è­°"] }
    ]
  },
  "tyranids": {
    name: "æ³°å€«èŸ²æ—",
    color: "#a855f7",
    units: [
      { id: "ty-swarmlord", name: "èŸ²ç¾¤éœ¸ä¸» Swarmlord", points: 220, img: "img/Tyranids/99120106060_SwarmlordLead.jpg", stats: { M: 8, T: 10, Sv: 2, W: 10, Ld: 7, OC: 3 }, inv: 4, keywords: ["Monster", "Character", "Epic Hero", "Synapse"], weapons: { ranged: { name: "çªè§¸è„ˆè¡", range: 18, A: 3, skill: 2, S: 8, AP: -2, D: 3 }, melee: { name: "éª¨åŠ", A: 8, skill: 2, S: 9, AP: -2, D: 3 } }, abilities: ["èŸ²å·¢éœ¸ä¸»", "Synapse"] },
      { id: "ty-hivetyrant", name: "èŸ²å·¢æš´å› Hive Tyrant", points: 195, img: "img/Tyranids/99120106060_HiveTyrantLead.jpg", stats: { M: 8, T: 10, Sv: 2, W: 10, Ld: 7, OC: 3 }, inv: 4, keywords: ["Monster", "Character", "Synapse"], weapons: { ranged: { name: "é‡æ¯’æ¶²ç ²", range: 36, A: 3, skill: 2, S: 9, AP: -2, D: 3 }, melee: { name: "å·¨å‹éª¨åŠ", A: 6, skill: 2, S: 9, AP: -2, D: 3 } }, abilities: ["Synapse", "æš—å½±ç± ç½©"] },
      { id: "ty-flyrant", name: "é£›ç¿¼æš´å› Winged Hive Tyrant", points: 170, img: "img/Tyranids/99120106060_WingedHiveTyrantLead.jpg", stats: { M: 12, T: 9, Sv: 2, W: 10, Ld: 7, OC: 3 }, inv: 4, keywords: ["Monster", "Character", "Fly", "Synapse"], weapons: { ranged: { name: "é‡æ¯’æ¶²ç ²", range: 36, A: 3, skill: 2, S: 9, AP: -2, D: 3 }, melee: { name: "å·¨å‹éª¨åŠ", A: 6, skill: 2, S: 9, AP: -2, D: 3 } }, abilities: ["Synapse", "é£›è¡Œ"] },
      { id: "ty-broodlord", name: "è‚²æ¯èŸ² Broodlord", points: 80, img: "img/Tyranids/99120106059_BroodlordLead.jpg", stats: { M: 8, T: 5, Sv: 4, W: 6, Ld: 7, OC: 1 }, inv: 4, keywords: ["Infantry", "Character", "Synapse"], weapons: { ranged: null, melee: { name: "è‚²æ¯èŸ²çˆªç‰™", A: 6, skill: 2, S: 6, AP: -2, D: 2 } }, abilities: ["Synapse", "å‚¬çœ å‡è¦–"] },
      { id: "ty-neurotyrant", name: "ç¥ç¶“æš´å› Neurotyrant", points: 105, img: "img/Tyranids/99120106072_Neurolictor1.jpg", stats: { M: 6, T: 8, Sv: 4, W: 9, Ld: 7, OC: 3 }, inv: 4, keywords: ["Monster", "Character", "Synapse", "Fly"], weapons: { ranged: { name: "éˆèƒ½å°–å˜¯", range: 18, A: "D6", skill: 3, S: 5, AP: -1, D: 2 }, melee: { name: "å°¾åˆº", A: 3, skill: 4, S: 5, AP: 0, D: 1 } }, abilities: ["Synapse", "éˆèƒ½æ”¾å¤§"] },
      { id: "ty-tervigon", name: "ç¹æ®–ç¸ Tervigon", points: 160, img: "img/Tyranids/99120106066_Termagaunts2.jpg", stats: { M: 8, T: 11, Sv: 2, W: 16, Ld: 7, OC: 5 }, inv: null, keywords: ["Monster", "Character", "Synapse"], weapons: { ranged: { name: "åˆºé‡é½Šå°„", range: 24, A: 8, skill: 3, S: 5, AP: 0, D: 1 }, melee: { name: "å·¨çˆª", A: 4, skill: 4, S: 10, AP: -2, D: "D6" } }, abilities: ["å­µåŒ–ç™½èŸ»", "Synapse"] },
      { id: "ty-termagants", name: "ç™½èŸ»Ã—10 Termagants", points: 60, img: "img/Tyranids/99120106066_Termagaunts2.jpg", stats: { M: 6, T: 3, Sv: 5, W: 10, Ld: 8, OC: 2 }, inv: null, keywords: ["Infantry", "Battleline", "Endless Multitude"], weapons: { ranged: { name: "è‚‰èŸ²æ§", range: 18, A: 1, skill: 4, S: 5, AP: 0, D: 1 }, melee: { name: "ç”²æ®¼çˆªç‰™", A: 1, skill: 4, S: 3, AP: 0, D: 1 } }, abilities: ["æ½›è¡Œææ‡¼"] },
      { id: "ty-hormagaunts", name: "åˆºèŸ²Ã—10 Hormagaunts", points: 65, img: "img/Tyranids/99120106073_Hormagaunts2.jpg", stats: { M: 10, T: 3, Sv: 5, W: 10, Ld: 8, OC: 2 }, inv: null, keywords: ["Infantry", "Battleline", "Endless Multitude"], weapons: { ranged: null, melee: { name: "åˆºèŸ²çˆª", A: 3, skill: 4, S: 3, AP: -1, D: 1 } }, abilities: ["èœ‚æ¹§è·³èº: Advanceå¾Œå¯è¡é‹’"] },
      { id: "ty-gargoyles", name: "ç¿¼èŸ²Ã—10 Gargoyles", points: 85, img: "img/Tyranids/99120106052_TYRGargoylesLead.jpg", stats: { M: 12, T: 3, Sv: 6, W: 10, Ld: 8, OC: 2 }, inv: null, keywords: ["Infantry", "Fly", "Endless Multitude"], weapons: { ranged: { name: "è‚‰èŸ²æ§", range: 18, A: 1, skill: 4, S: 4, AP: 0, D: 1 }, melee: { name: "çˆªç‰™", A: 1, skill: 4, S: 3, AP: 0, D: 1 } }, abilities: ["é£›è¡Œ", "åµå¯Ÿ"] },
      { id: "ty-genestealers", name: "åŸºå› ç«Šå–è€…Ã—5 Genestealers", points: 75, img: "img/Tyranids/99120106068_Genestealers2.jpg", stats: { M: 8, T: 4, Sv: 5, W: 10, Ld: 7, OC: 1 }, inv: 5, keywords: ["Infantry"], weapons: { ranged: null, melee: { name: "åŸºå› ç«Šå–è€…çˆªç‰™", A: 4, skill: 2, S: 4, AP: -2, D: 1 } }, abilities: ["åµå¯Ÿ8\"", "å…ˆé‹’çµæ‰‹"] },
      { id: "ty-warriors", name: "èŸ²æ—æˆ°å£«Ã—3 Warriors", points: 65, img: "img/Tyranids/99120106058_TYRWarriorsLeadPrime.jpg", stats: { M: 6, T: 5, Sv: 4, W: 9, Ld: 7, OC: 2 }, inv: null, keywords: ["Infantry", "Synapse"], weapons: { ranged: { name: "æ­»äº¡å™´å°„", range: 18, A: 2, skill: 4, S: 5, AP: -1, D: 1 }, melee: { name: "æ¯’ç‰™åˆ©çˆª", A: 4, skill: 3, S: 5, AP: -2, D: 1 } }, abilities: ["Synapseç¯€é»"] },
      { id: "ty-zoanthropes", name: "éˆèƒ½ç¸Ã—3 Zoanthropes", points: 100, img: "img/Tyranids/99120106057_NeurothropesLead.jpg", stats: { M: 5, T: 5, Sv: 5, W: 9, Ld: 7, OC: 1 }, inv: 4, keywords: ["Infantry", "Fly", "Synapse"], weapons: { ranged: { name: "æ‰­æ›²çˆ†ç‚¸", range: 24, A: "D3", skill: 3, S: 10, AP: -3, D: "D3+1" }, melee: { name: "çˆªç‰™", A: 3, skill: 4, S: 4, AP: 0, D: 1 } }, abilities: ["Synapse", "éˆèƒ½è­·ç›¾"] },
      { id: "ty-venomthropes", name: "æ¯’æ°£ç¸Ã—3 Venomthropes", points: 70, img: "img/Tyranids/99120106057_VenomthropesLead.jpg", stats: { M: 6, T: 5, Sv: 4, W: 9, Ld: 8, OC: 1 }, inv: null, keywords: ["Infantry", "Fly"], weapons: { ranged: null, melee: { name: "æ¯’é­", A: 6, skill: 3, S: 4, AP: 0, D: 1 } }, abilities: ["æ¯’éœ§: 6\"å…§å‹è»-1è¢«å‘½ä¸­"] },
      { id: "ty-raveners", name: "æ å¥ªè€…Ã—5 Raveners", points: 125, img: "img/Tyranids/60010199057_LeviathanEXTRA15.jpg", stats: { M: 10, T: 5, Sv: 4, W: 15, Ld: 8, OC: 1 }, inv: null, keywords: ["Infantry", "Burrowers"], weapons: { ranged: null, melee: { name: "æ å¥ªè€…çˆªç‰™", A: 3, skill: 3, S: 5, AP: -2, D: 2, keywords: ["Twin-linked"] } }, abilities: ["æ·±å…¥æ‰“æ“Š", "åœ°åº•æ’¤é€€: å›åˆçµæŸå¯è¿”å›æˆ°ç•¥é å‚™éšŠ"] },
      { id: "ty-lictors", name: "ä¼æ“Šè€… Lictor", points: 60, img: "img/Tyranids/99120106069_Lictor1.jpg", stats: { M: 8, T: 6, Sv: 4, W: 6, Ld: 7, OC: 1 }, inv: null, keywords: ["Infantry"], weapons: { ranged: null, melee: { name: "ä¼æ“Šè€…çˆªç‰™", A: 6, skill: 2, S: 7, AP: -2, D: 2 } }, abilities: ["æ·±å…¥æ‰“æ“Š", "éš±åŒ¿çµæ‰‹"] },
      { id: "ty-carnifex", name: "å± æ®ºç¸ Carnifex", points: 90, img: "img/Tyranids/99120106031_CarnifexBrood01.jpg", stats: { M: 8, T: 9, Sv: 2, W: 8, Ld: 8, OC: 3 }, inv: null, keywords: ["Monster"], weapons: { ranged: { name: "ç”ŸåŒ–ç ²", range: 12, A: "D3", skill: 4, S: 8, AP: -3, D: 2 }, melee: { name: "ç ´ç¢çˆª", A: 4, skill: 4, S: 12, AP: -3, D: "D6+1" } }, abilities: ["ä¸å¯é˜»æ“‹: è¡é‹’æ™‚+1å‚·å®³"] },
      { id: "ty-screamer", name: "å°–å˜¯æ®ºæ‰‹ Screamer-Killer", points: 125, img: "img/Tyranids/99120106031_ScreamerKillerBrood01.jpg", stats: { M: 8, T: 9, Sv: 2, W: 10, Ld: 8, OC: 3 }, inv: null, keywords: ["Monster"], weapons: { ranged: { name: "ç”ŸåŒ–ç­‰é›¢å­å°–å˜¯", range: 18, A: "D6+3", skill: 4, S: 8, AP: -2, D: 2 }, melee: { name: "å°–å˜¯æ®ºæ‰‹çˆª", A: 6, skill: 4, S: 10, AP: -3, D: 3 } }, abilities: ["ææ‡¼å°–å˜¯"] },
      { id: "ty-exocrine", name: "å™´å°„ç¸ Exocrine", points: 140, img: "img/Tyranids/99120106056_ExocreneLead.jpg", stats: { M: 8, T: 10, Sv: 3, W: 14, Ld: 8, OC: 4 }, inv: null, keywords: ["Monster"], weapons: { ranged: { name: "ç”ŸåŒ–ç­‰é›¢å­ç ²", range: 36, A: 6, skill: 3, S: 10, AP: -3, D: 3 }, melee: { name: "å¼·åŠ›çˆª", A: 3, skill: 4, S: 8, AP: -2, D: 2 } }, abilities: ["é‡ç«åŠ›æ¨¡å¼"] },
      { id: "ty-haruspex", name: "åå™¬ç¸ Haruspex", points: 125, img: "img/Tyranids/99120106026_Haruspex01.jpg", stats: { M: 8, T: 11, Sv: 3, W: 14, Ld: 8, OC: 4 }, inv: null, keywords: ["Monster"], weapons: { ranged: null, melee: { name: "åå™¬ä¹‹é¡", A: 8, skill: 3, S: 12, AP: -3, D: 3 } }, abilities: ["åå™¬æ¢å¾©: é€ æˆå‚·å®³æ¢å¾©HP"] },
      { id: "ty-maleceptor", name: "æƒ¡æ„ç¸ Maleceptor", points: 170, img: "img/Tyranids/99120106033_Maleceptor01.jpg", stats: { M: 8, T: 11, Sv: 3, W: 14, Ld: 7, OC: 4 }, inv: 4, keywords: ["Monster", "Synapse"], weapons: { ranged: { name: "éˆèƒ½éè¼‰", range: 18, A: "D6", skill: 3, S: 9, AP: -2, D: 3 }, melee: { name: "å·¨çˆª", A: 4, skill: 4, S: 9, AP: -2, D: 3 } }, abilities: ["Synapse", "éˆèƒ½å£“åˆ¶"] },
      { id: "ty-trygon", name: "ç©¿åœ°ç¸ Trygon", points: 140, img: "img/Tyranids/99120106019_TrygonNEW01.jpg", stats: { M: 10, T: 10, Sv: 3, W: 14, Ld: 8, OC: 4 }, inv: null, keywords: ["Monster"], weapons: { ranged: { name: "ç”Ÿé›»è„ˆè¡", range: 12, A: 6, skill: 4, S: 5, AP: 0, D: 1 }, melee: { name: "ç©¿åœ°ç¸çˆª", A: 6, skill: 3, S: 10, AP: -2, D: 3 } }, abilities: ["æ·±å…¥æ‰“æ“Š", "åœ°åº•é€šé“"] },
      { id: "ty-mawloc", name: "å·¨å£ç¸ Mawloc", points: 135, img: "img/Tyranids/99120106019_MawlocNEW01.jpg", stats: { M: 10, T: 10, Sv: 3, W: 14, Ld: 8, OC: 4 }, inv: null, keywords: ["Monster"], weapons: { ranged: null, melee: { name: "å·¨å£ä¹‹é¡", A: 12, skill: 4, S: 6, AP: -1, D: 1 } }, abilities: ["ææ€–çªç¾: æ·±å…¥æ‰“æ“Šæ™‚é€ æˆè‡´å‘½å‚·å®³"] },
      { id: "ty-tyrannofex", name: "æš´å›ç¸ Tyrannofex", points: 200, img: "img/Tyranids/99120106054_TYRTyrannofexLead.jpg", stats: { M: 9, T: 12, Sv: 2, W: 16, Ld: 8, OC: 5 }, inv: null, keywords: ["Monster"], weapons: { ranged: { name: "ç ´è£‚ç ²", range: 48, A: 2, skill: 4, S: 18, AP: -4, D: "2D6" }, melee: { name: "å¼·åŠ›çˆª", A: 4, skill: 4, S: 10, AP: -2, D: 3 } }, abilities: ["é‡ç«åŠ›å¹³å°"] },
      { id: "ty-nornemissary", name: "å¤è€ä½¿è€… Norn Emissary", points: 260, img: "img/Tyranids/99120106064_NornEmissary1.jpg", stats: { M: 10, T: 11, Sv: 2, W: 16, Ld: 7, OC: 5 }, inv: 4, keywords: ["Monster", "Character", "Synapse"], weapons: { ranged: { name: "éˆèƒ½è§¸é¬š", range: 18, A: "D6+1", skill: 2, S: 8, AP: -2, D: 2 }, melee: { name: "å·¨çˆª", A: 6, skill: 2, S: 12, AP: -3, D: "D6+2" } }, abilities: ["Synapse", "å¤è€æ™ºæ…§"] },
      { id: "ty-hive-guard", name: "èŸ²å·¢å®ˆè¡›Ã—3 Hive Guard", points: 90, img: "img/Tyranids/99120106055_TYRHiveGuardLead.jpg", stats: { M: 6, T: 7, Sv: 3, W: 12, Ld: 8, OC: 1 }, inv: null, keywords: ["Infantry"], weapons: { ranged: { name: "ç©¿åˆºç ²", range: 36, A: 2, skill: 3, S: 9, AP: -2, D: 3 }, melee: { name: "çˆªç‰™", A: 3, skill: 4, S: 5, AP: 0, D: 1 } }, abilities: ["ç„¡éœ€è¦–ç·š"] },
      { id: "ty-tyrantguard", name: "æš´å›è­·è¡›Ã—3 Tyrant Guard", points: 80, img: "img/Tyranids/60010199057_LeviathanEXTRA16.jpg", stats: { M: 6, T: 8, Sv: 3, W: 12, Ld: 8, OC: 1 }, inv: null, keywords: ["Infantry"], weapons: { ranged: null, melee: { name: "è£‚çˆª", A: 4, skill: 3, S: 7, AP: -2, D: 2 } }, abilities: ["è­·è¡›: å¯ç‚ºæš´å›æ‰¿å—å‚·å®³"] },
      { id: "ty-harpy", name: "é³¥å¦– Harpy", points: 215, img: "img/Tyranids/99120106024_Harpies01.jpg", stats: { M: 20, T: 9, Sv: 3, W: 12, Ld: 8, OC: 0 }, inv: null, keywords: ["Monster", "Fly", "Aircraft"], weapons: { ranged: { name: "é›™è¯çµæ®ºç ²", range: 36, A: 8, skill: 4, S: 7, AP: -1, D: 2 }, melee: { name: "çˆªç‰™", A: 4, skill: 4, S: 6, AP: -1, D: 2 } }, abilities: ["é£›è¡Œå™¨", "æŠ•å½ˆ"] },
      // ===== Faction Pack æ–°å–®ä½ =====
      { id: "ty-hyperraveners", name: "è¶…é©æ‡‰æ å¥ªè€… Hyperadapted Raveners", points: 165, img: "img/Tyranids/60010199057_LeviathanEXTRA15.jpg", stats: { M: 10, T: 5, Sv: 4, W: 15, Ld: 7, OC: 1 }, inv: null, keywords: ["Infantry", "Burrowers", "Synapse", "Leader"], weapons: { ranged: { name: "æ¯’æ¶²å½ˆ", range: 12, A: "D6+3", skill: 0, S: 6, AP: -1, D: 1, keywords: ["Assault", "Ignores Cover", "Torrent"] }, melee: { name: "æ å¥ªè€…é‡çˆª", A: 6, skill: 3, S: 5, AP: -2, D: 2, keywords: ["Anti-Monster 5+", "Anti-Vehicle 5+", "Twin-linked"] } }, abilities: ["æ·±å…¥æ‰“æ“Š", "é ˜å°è€…", "æŒçºŒå‘½ä¸­1", "è¶…æ„Ÿå®˜"] },
      { id: "ty-harridan", name: "ç¿¼é­” Harridan", points: 550, img: "img/Tyranids/99120106024_Harpies01.jpg", stats: { M: 20, T: 10, Sv: 3, W: 30, Ld: 8, OC: 0 }, inv: null, keywords: ["Monster", "Titanic", "Fly", "Aircraft", "Transport"], weapons: { ranged: { name: "ææ€–ç”ŸåŒ–ç ²", range: 48, A: "D6+6", skill: 3, S: 10, AP: -3, D: 3, keywords: ["Blast"] }, melee: { name: "å·¨å‹é®çˆª", A: 6, skill: 3, S: 14, AP: -2, D: "D6" } }, abilities: ["è‡´å‘½æœ«æ—¥2D6", "æ‡¸åœ", "ç‹‚æš´ä»£è¬: +1è‡´å‚·ä½†å—D3å‚·å®³", "é‹è¼¸: 20ç¿¼èŸ²"] },
      { id: "ty-hierophant", name: "ç¥­å¸ç¸ Hierophant", points: 700, img: "img/Tyranids/99120106054_TYRTyrannofexLead.jpg", stats: { M: 12, T: 14, Sv: 2, W: 30, Ld: 8, OC: 12 }, inv: 5, keywords: ["Monster", "Titanic", "Towering", "Transport"], weapons: { ranged: { name: "ææ€–ç”ŸåŒ–ç ²Ã—2", range: 48, A: "2D6+12", skill: 3, S: 10, AP: -3, D: 3, keywords: ["Blast"] }, melee: { name: "å·¨å‹é®çˆª", A: 8, skill: 3, S: 20, AP: -2, D: "D6+1" } }, abilities: ["è‡´å‘½æœ«æ—¥2D6", "Synapse", "å·¨ç¸: +1å‘½ä¸­vsæˆ°æ…„å–®ä½", "è¸è¸å‰é€²: å¯è¶Šé4\"ä»¥ä¸‹æ¨¡å‹"] },
      // ===== é¡å¤–å¯ç”¨åœ–ç‰‡çš„å–®ä½ =====
      { id: "ty-deathleaper", name: "æ­»äº¡æ½›è¡Œè€… Deathleaper", points: 80, img: "img/Tyranids/99120106067_Deathleaper1.jpg", stats: { M: 8, T: 6, Sv: 4, W: 7, Ld: 7, OC: 1 }, inv: 4, keywords: ["Infantry", "Character", "Epic Hero"], weapons: { ranged: null, melee: { name: "æ­»ç¥çˆªç‰™", A: 6, skill: 2, S: 8, AP: -2, D: 3 } }, abilities: ["æ·±å…¥æ‰“æ“Š", "éš±åŒ¿å¤§å¸«", "ææ‡¼ä¹‹æº"] },
      { id: "ty-psychophage", name: "éˆå™¬ç¸ Psychophage", points: 125, img: "img/Tyranids/99120106074_Psychophage1.jpg", stats: { M: 8, T: 9, Sv: 3, W: 10, Ld: 8, OC: 3 }, inv: null, keywords: ["Monster"], weapons: { ranged: { name: "éˆèƒ½çˆ†ç™¼", range: 12, A: "D6", skill: 4, S: 6, AP: -1, D: 2 }, melee: { name: "å•ƒå™¬åˆ©çˆª", A: 5, skill: 3, S: 10, AP: -2, D: 3 } }, abilities: ["éˆå™¬: é€ æˆå‚·å®³æ¢å¾©HP"] },
      { id: "ty-biovore", name: "ç”ŸåŒ–æŠ•å°„ç¸ Biovore", points: 50, img: "img/Tyranids/99120106065_Biovore1.jpg", stats: { M: 5, T: 5, Sv: 4, W: 4, Ld: 8, OC: 1 }, inv: null, keywords: ["Infantry"], weapons: { ranged: { name: "å­¢å­åœ°é›·", range: 48, A: 1, skill: 4, S: 5, AP: -1, D: 2, keywords: ["Blast", "Indirect Fire"] }, melee: { name: "çˆªç‰™", A: 2, skill: 4, S: 4, AP: 0, D: 1 } }, abilities: ["é–“æ¥ç«åŠ›"] },
      { id: "ty-pyrovore", name: "ç†”å²©èŸ² Pyrovore", points: 35, img: "img/Tyranids/99120106065_Pyrovore1.jpg", stats: { M: 5, T: 6, Sv: 3, W: 5, Ld: 8, OC: 1 }, inv: null, keywords: ["Infantry"], weapons: { ranged: { name: "é…¸æ¶²å™´å°„", range: 12, A: "D6", skill: 0, S: 5, AP: -1, D: 1, keywords: ["Torrent", "Ignores Cover"] }, melee: { name: "çˆªç‰™", A: 3, skill: 4, S: 5, AP: 0, D: 1 } }, abilities: ["çˆ†ç‚¸æ­»äº¡"] },
      { id: "ty-prime", name: "èŸ²æ—æˆ°å£«é¦–é ˜ Tyranid Prime", points: 75, img: "img/Tyranids/99120106075_Prime1.jpg", stats: { M: 6, T: 5, Sv: 4, W: 6, Ld: 7, OC: 1 }, inv: null, keywords: ["Infantry", "Character", "Synapse"], weapons: { ranged: { name: "æ­»äº¡å™´å°„", range: 18, A: 3, skill: 3, S: 5, AP: -1, D: 1 }, melee: { name: "éª¨åŠé­çˆª", A: 5, skill: 2, S: 6, AP: -2, D: 2 } }, abilities: ["Synapse", "é ˜å°è€…", "æˆ°å£«ç¾¤åŠ æˆ"] },
      { id: "ty-parasite", name: "è«ç‰¹é›·æ–¯å¯„ç”ŸèŸ² Parasite of Mortrex", points: 90, img: "img/Tyranids/99120106050_TYRParasiteofMortrexLead.jpg", stats: { M: 12, T: 5, Sv: 4, W: 5, Ld: 7, OC: 1 }, inv: null, keywords: ["Infantry", "Character", "Fly", "Epic Hero"], weapons: { ranged: null, melee: { name: "å¯„ç”Ÿçˆªç‰™", A: 6, skill: 2, S: 5, AP: -1, D: 2 } }, abilities: ["é£›è¡Œ", "å¯„ç”Ÿç”¢åµ: æ“Šæ®ºæ•µäººç”ŸæˆèŸ²ç¾¤"] },
      { id: "ty-hivecrone", name: "èŸ²å·¢å¥³å¦– Hive Crone", points: 200, img: "img/Tyranids/99120106024_HiveCrone01.jpg", stats: { M: 20, T: 9, Sv: 3, W: 12, Ld: 8, OC: 0 }, inv: null, keywords: ["Monster", "Fly", "Aircraft"], weapons: { ranged: { name: "è§¸æ‰‹é­", range: 18, A: 4, skill: 3, S: 7, AP: -2, D: 2 }, melee: { name: "å·¨çˆª", A: 5, skill: 3, S: 8, AP: -2, D: 3 } }, abilities: ["é£›è¡Œå™¨", "é…¸æ¶²å™´å°„"] },
      { id: "ty-nornassimilator", name: "å¤è€åŒåŒ–è€… Norn Assimilator", points: 290, img: "img/Tyranids/99120106064_NornAssimilator1.jpg", stats: { M: 10, T: 11, Sv: 2, W: 18, Ld: 7, OC: 5 }, inv: 4, keywords: ["Monster", "Character", "Synapse"], weapons: { ranged: { name: "æ¯’ç´ å™´å°„", range: 12, A: "2D6", skill: 0, S: 7, AP: -2, D: 2, keywords: ["Torrent"] }, melee: { name: "åŒåŒ–å·¨çˆª", A: 8, skill: 2, S: 14, AP: -3, D: "D6+2" } }, abilities: ["Synapse", "åŒåŒ–æ¢å¾©"] }
    ]
  },
  "chaos": {
    name: "æ··æ²Œæˆ°å£«",
    color: "#dc2626",
    units: [
      {
        id: "ch-lord",
        name: "æ··æ²Œé ˜ä¸» Chaos Lord",
        points: 75,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/0/04/ChaosLord8th.jpg/180px-ChaosLord8th.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 5, Ld: 6, OC: 1 },
        inv: 4,
        keywords: ["Infantry", "Character", "Chaos"],
        weapons: {
          ranged: { name: "ç­‰é›¢å­æ§ Plasma Pistol", range: 12, A: 1, skill: 2, S: 7, AP: -2, D: 2 },
          melee: { name: "æƒ¡é­”ä¹‹åŠ Daemon Blade", A: 6, skill: 2, S: 6, AP: -2, D: 2 }
        },
        abilities: ["é»‘æš—å…‰ç’°: 6\"å…§é‡æ“²è‡´å‚·1", "Let the Galaxy Burn"]
      },
      {
        id: "ch-legionaries",
        name: "è»åœ˜æˆ°å£«Ã—5 Legionaries",
        points: 90,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/1/1c/ChaosLegionariesMini10th.jpg/250px-ChaosLegionariesMini10th.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 10, Ld: 6, OC: 2 },
        inv: null,
        keywords: ["Infantry", "Battleline", "Chaos"],
        weapons: {
          ranged: { name: "æ··æ²Œçˆ†çŸ¢æ§ Boltgun", range: 24, A: 2, skill: 3, S: 4, AP: 0, D: 1 },
          melee: { name: "æ··æ²Œè¿‘æˆ°æ­¦å™¨", A: 3, skill: 3, S: 4, AP: 0, D: 1 }
        },
        abilities: ["ä»‡æ¨èª“è¨€: +1å‘½ä¸­vs Imperium"]
      },
      {
        id: "ch-havocs",
        name: "æµ©åŠ«æˆ°å£«Ã—5 Havocs",
        points: 140,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/e/e9/Havocs8thED.jpg/200px-Havocs8thED.jpg",
        stats: { M: 5, T: 4, Sv: 3, W: 10, Ld: 6, OC: 1 },
        inv: null,
        keywords: ["Infantry", "Chaos"],
        weapons: {
          ranged: { name: "ç†”å²©æ§ Lascannon", range: 48, A: 1, skill: 3, S: 12, AP: -3, D: "D6+1" },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 2, skill: 3, S: 4, AP: 0, D: 1 }
        },
        abilities: ["å£“åˆ¶ç«åŠ›: ç›®æ¨™-2ç§»å‹•"]
      },
      {
        id: "ch-berzerkers",
        name: "ä¹è¡€ç‹‚æˆ°å£«Ã—5 Khorne Berzerkers",
        points: 90,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/5/5a/Berzerkers8thMini.jpg/220px-Berzerkers8thMini.jpg",
        stats: { M: 6, T: 4, Sv: 3, W: 10, Ld: 6, OC: 2 },
        inv: null,
        keywords: ["Infantry", "Chaos", "Khorne"],
        weapons: {
          ranged: { name: "çˆ†çŸ¢æ‰‹æ§", range: 12, A: 1, skill: 3, S: 4, AP: 0, D: 1 },
          melee: { name: "éˆæ–§ Chainaxe", A: 4, skill: 3, S: 5, AP: -1, D: 1 }
        },
        abilities: ["è¡€ä¹‹æ†¤æ€’: Fightéšæ®µå¯æ”»æ“Šå…©æ¬¡"]
      },
      {
        id: "ch-helbrute",
        name: "åœ°ç„è »å…µ Helbrute",
        points: 130,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/0/00/Hellbrute7th.jpg/200px-Hellbrute7th.jpg",
        stats: { M: 6, T: 9, Sv: 2, W: 8, Ld: 6, OC: 3 },
        inv: null,
        keywords: ["Vehicle", "Walker"],
        weapons: {
          ranged: { name: "å¤šç†”å²©ç ² Multi-melta", range: 18, A: 2, skill: 3, S: 9, AP: -4, D: "D6", keywords: ["Melta 2"] },
          melee: { name: "å‹•åŠ›é‰— Power Scourge", A: 5, skill: 3, S: 12, AP: -2, D: 3 }
        },
        abilities: ["ç‹‚æš´: å—å‚·å¾Œ+1æ”»æ“Š", "Helbrute Frenzy"]
      }
    ]
  },
  "orks": {
    name: "æ­å…‹è »äºº",
    color: "#84cc16",
    units: [
      {
        id: "or-warboss",
        name: "æˆ°çˆ­é ­é ­ Warboss",
        points: 70,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103105_WarbossinMegaArmourLead.jpg",
        stats: { M: 6, T: 5, Sv: 4, W: 7, Ld: 6, OC: 1 },
        inv: 5,
        keywords: ["Infantry", "Character", "Ork"],
        weapons: {
          ranged: { name: "å¤§çˆ†æ§ Kombi-weapon", range: 24, A: 1, skill: 5, S: 4, AP: 0, D: 1 },
          melee: { name: "å‹•åŠ›çˆª Power Klaw", A: 4, skill: 3, S: 10, AP: -2, D: 2 }
        },
        abilities: ["WAAAGH!: å…¨è»è¡é‹’+1", "Might is Right"]
      },
      {
        id: "or-boyz",
        name: "æ­å…‹ç”·å­©Ã—10 Boyz",
        points: 80,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103106_OrkBoyzLead.jpg",
        stats: { M: 6, T: 5, Sv: 5, W: 11, Ld: 7, OC: 2 },
        inv: null,
        keywords: ["Infantry", "Battleline", "Ork"],
        weapons: {
          ranged: { name: "ç²—ç³™æ§ Shoota", range: 18, A: 2, skill: 5, S: 4, AP: 0, D: 1 },
          melee: { name: "ç åˆ€ Choppa", A: 3, skill: 3, S: 4, AP: -1, D: 1 }
        },
        abilities: ["äººå¤šåŠ›é‡å¤§: 10+æ¨¡å‹æ™‚+1æ”»æ“Š"]
      },
      {
        id: "or-nobz",
        name: "é ­é ­Ã—5 Nobz",
        points: 100,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103055_Nobz01.jpg",
        stats: { M: 6, T: 5, Sv: 4, W: 10, Ld: 7, OC: 2 },
        inv: null,
        keywords: ["Infantry", "Ork"],
        weapons: {
          ranged: { name: "çˆ†æ§ Slugga", range: 12, A: 1, skill: 5, S: 4, AP: 0, D: 1 },
          melee: { name: "å¤§ç åˆ€ Big Choppa", A: 3, skill: 3, S: 7, AP: -1, D: 2 }
        },
        abilities: ["Da Boss is Watching"]
      },
      {
        id: "or-meganobz",
        name: "å·¨ç”²é ­é ­Ã—3 Meganobz",
        points: 100,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103089_OrkMeganobzAlt.jpg",
        stats: { M: 5, T: 6, Sv: 2, W: 9, Ld: 7, OC: 2 },
        inv: null,
        keywords: ["Infantry", "Ork", "Mega Armour"],
        weapons: {
          ranged: { name: "é›™é€£çˆ†æ§ Kombi-rokkit", range: 24, A: "D3", skill: 5, S: 9, AP: -2, D: 3 },
          melee: { name: "å‹•åŠ›çˆª Power Klaw", A: 3, skill: 3, S: 9, AP: -2, D: 2 }
        },
        abilities: ["Krumpin' Time"]
      },
      {
        id: "or-deffkoptas",
        name: "æ­»äº¡ç›´å‡æ©ŸÃ—3 Deffkoptas",
        points: 110,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103107_DeffkoptasLead.jpg",
        stats: { M: 14, T: 6, Sv: 4, W: 9, Ld: 7, OC: 2 },
        inv: null,
        keywords: ["Fly", "Vehicle", "Ork"],
        weapons: {
          ranged: { name: "ç«ç®­ Rokkits", range: 24, A: 3, skill: 5, S: 9, AP: -2, D: 3 },
          melee: { name: "æ—‹è½‰åˆ€ç‰‡ Spinnin' Blades", A: 6, skill: 3, S: 5, AP: -1, D: 1 }
        },
        abilities: ["Deep Strike"]
      },
      // ===== æ–°å¢ Orks å–®ä½ =====
      {
        id: "or-ghazghkull",
        name: "åŠ èŒ²å¤çˆ¾ Ghazghkull Thraka",
        points: 235,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103079_ThrakaLead.jpg",
        stats: { M: 5, T: 6, Sv: 2, W: 10, Ld: 6, OC: 4 },
        inv: 4,
        keywords: ["Infantry", "Character", "Epic Hero", "Ork"],
        weapons: {
          ranged: { name: "è«å…‹ä¹‹å¼ Mork's Roar", range: 36, A: 12, skill: 5, S: 5, AP: 0, D: 1, keywords: ["Rapid Fire 4"] },
          melee: { name: "æˆˆå…‹ä¹‹çˆª Gork's Klaw", A: 6, skill: 2, S: 14, AP: -3, D: 4 }
        },
        abilities: ["é è¨€å®¶: é ˜å°å–®ä½è¿‘æˆ°å‘½ä¸­/è‡´å‚·+1", "WAAAGHæ——å¹Ÿ: 12\"å…§å‹è»è¿‘æˆ°ç²å¾—è‡´å‘½å‘½ä¸­", "è‡³é«˜çµ±å¸¥"]
      },
      {
        id: "or-bigmek",
        name: "å¤§æ©Ÿå¸« Big Mek",
        points: 55,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103120_ORKBigMek01.jpg",
        stats: { M: 6, T: 5, Sv: 4, W: 5, Ld: 7, OC: 1 },
        inv: 5,
        keywords: ["Infantry", "Character", "Ork", "Mek"],
        weapons: {
          ranged: { name: "éœ‡ç›ªæ”»æ“Šæ§ Shokk Attack Gun", range: 60, A: "D6", skill: 5, S: 9, AP: -4, D: "D6", keywords: ["Blast", "Hazardous"] },
          melee: { name: "å‹•åŠ›çˆª Power Klaw", A: 3, skill: 4, S: 9, AP: -2, D: 2 }
        },
        abilities: ["é ˜è¢–", "ä¿®å¾©: æ¯å›åˆæ¢å¾©D3å‚·å£çµ¦è¼‰å…·"]
      },
      {
        id: "or-painboy",
        name: "ç–¼ç—›ç”·å­© Painboy",
        points: 70,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99070103003_Painboy01.jpg",
        stats: { M: 6, T: 5, Sv: 4, W: 4, Ld: 7, OC: 1 },
        inv: null,
        keywords: ["Infantry", "Character", "Ork"],
        weapons: {
          ranged: null,
          melee: { name: "æ‰‹è¡“å·¥å…· 'Urty Syringe", A: 4, skill: 4, S: 4, AP: -1, D: 2 }
        },
        abilities: ["é ˜è¢–: é ˜å°å–®ä½ç²å¾—5+ç„¡æ‡¼æ­»äº¡", "ç·Šæ€¥æ‰‹è¡“: æ¢å¾©D3æ¨¡å‹"]
      },
      {
        id: "or-weirdboy",
        name: "æ€ªç•°ç”·å­© Weirdboy",
        points: 55,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99800103004_WeirdboyNEW01.jpg",
        stats: { M: 6, T: 5, Sv: 5, W: 4, Ld: 7, OC: 1 },
        inv: null,
        keywords: ["Infantry", "Character", "Ork", "Psyker"],
        weapons: {
          ranged: { name: "WAAAGHèƒ½é‡ Da Jump", range: 24, A: "D6", skill: 4, S: 8, AP: -2, D: "D3", keywords: ["Hazardous"] },
          melee: { name: "æ€ªç•°ä¹‹æ– Weirdboy Staff", A: 3, skill: 4, S: 8, AP: -1, D: "D3" }
        },
        abilities: ["é ˜è¢–", "å‚³é€: å¯å‚³é€ä¸€å€‹å–®ä½9\"å¤–"]
      },
      {
        id: "or-kommandos",
        name: "çªæ“ŠéšŠÃ—10 Kommandos",
        points: 110,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/8/88/KommandosMini10th.jpg/200px-KommandosMini10th.jpg",
        stats: { M: 6, T: 5, Sv: 5, W: 11, Ld: 7, OC: 1 },
        inv: null,
        keywords: ["Infantry", "Ork"],
        weapons: {
          ranged: { name: "çˆ†æ§ Slugga", range: 12, A: 1, skill: 5, S: 4, AP: 0, D: 1 },
          melee: { name: "ç åˆ€ Choppa", A: 3, skill: 3, S: 4, AP: -1, D: 1 }
        },
        abilities: ["æ»²é€è€…: å¯åœ¨æ•µäºº9\"å¤–éƒ¨ç½²", "éš±åŒ¿"]
      },
      {
        id: "or-stormboyz",
        name: "é¢¨æš´ç”·å­©Ã—5 Stormboyz",
        points: 65,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103056_Stormboyz01.jpg",
        stats: { M: 12, T: 5, Sv: 5, W: 6, Ld: 7, OC: 1 },
        inv: null,
        keywords: ["Infantry", "Fly", "Jump Pack", "Ork"],
        weapons: {
          ranged: { name: "çˆ†æ§ Slugga", range: 12, A: 1, skill: 5, S: 4, AP: 0, D: 1 },
          melee: { name: "ç åˆ€ Choppa", A: 3, skill: 3, S: 4, AP: -1, D: 1 }
        },
        abilities: ["æ·±å…¥æ‰“æ“Š", "é£›è¡Œ"]
      },
      {
        id: "or-tankbustas",
        name: "å¦å…‹å‰‹æ˜ŸÃ—5 Tankbustas",
        points: 90,
        img: "https://wh40k.lexicanum.com/mediawiki/images/thumb/5/5f/TankBustas.jpg/200px-TankBustas.jpg",
        stats: { M: 6, T: 5, Sv: 5, W: 6, Ld: 7, OC: 1 },
        inv: null,
        keywords: ["Infantry", "Ork"],
        weapons: {
          ranged: { name: "ç«ç®­ç™¼å°„å™¨ Rokkit Launcha", range: 24, A: 1, skill: 5, S: 9, AP: -2, D: 3 },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 2, skill: 4, S: 4, AP: 0, D: 1 }
        },
        abilities: ["åè¼‰å…·: å°è¼‰å…·å‘½ä¸­+1"]
      },
      {
        id: "or-lootas",
        name: "æ¶åŠ«è€…Ã—5 Lootas",
        points: 70,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103054_OrkLootas01.jpg",
        stats: { M: 6, T: 5, Sv: 5, W: 6, Ld: 7, OC: 1 },
        inv: null,
        keywords: ["Infantry", "Ork"],
        weapons: {
          ranged: { name: "æ¯€æ»…æ§ Deffgun", range: 48, A: "D3", skill: 5, S: 7, AP: -1, D: 2, keywords: ["Heavy"] },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 2, skill: 4, S: 4, AP: 0, D: 1 }
        },
        abilities: ["é‡ç«åŠ›"]
      },
      {
        id: "or-warbikers",
        name: "æˆ°çˆ­æ‘©æ‰˜è»ŠÃ—3 Warbikers",
        points: 65,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103057_WarbikerMob01.jpg",
        stats: { M: 12, T: 6, Sv: 4, W: 9, Ld: 7, OC: 2 },
        inv: 6,
        keywords: ["Mounted", "Ork", "Speed Freeks"],
        weapons: {
          ranged: { name: "é›™é€£ç²—ç³™æ§ Dakkaguns", range: 18, A: 6, skill: 5, S: 5, AP: 0, D: 1, keywords: ["Rapid Fire 2", "Twin-linked"] },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 2, skill: 4, S: 5, AP: 0, D: 1 }
        },
        abilities: ["æ€¥è¡Œå°„æ“Š"]
      },
      {
        id: "or-battlewagon",
        name: "æˆ°çˆ­å¡è»Š Battlewagon",
        points: 160,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103084_BattlewagonLead.jpg",
        stats: { M: 10, T: 10, Sv: 3, W: 16, Ld: 7, OC: 5 },
        inv: 6,
        keywords: ["Vehicle", "Transport", "Ork"],
        weapons: {
          ranged: { name: "åŠ è¾²ç ² Kannon", range: 36, A: "D6+3", skill: 5, S: 6, AP: 0, D: 1 },
          melee: { name: "æ¯€æ»…æ»¾è¼ª Deff Rolla", A: 6, skill: 3, S: 9, AP: -1, D: 2 }
        },
        abilities: ["é‹è¼¸: 22æ­¥å…µ", "å°„æ“Šè‰™å£11", "è‡´å‘½æœ«æ—¥D6"]
      },
      {
        id: "or-trukk",
        name: "å¡è»Š Trukk",
        points: 70,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103012_TrukkNEW01.jpg",
        stats: { M: 12, T: 8, Sv: 4, W: 10, Ld: 7, OC: 2 },
        inv: 6,
        keywords: ["Vehicle", "Transport", "Dedicated Transport", "Ork"],
        weapons: {
          ranged: { name: "å¤§å°„æ‰‹ Big Shoota", range: 36, A: 3, skill: 5, S: 5, AP: 0, D: 1, keywords: ["Rapid Fire 2"] },
          melee: { name: "å°–åˆºè¼ª Spiked Wheels", A: 3, skill: 4, S: 6, AP: 0, D: 1 }
        },
        abilities: ["é‹è¼¸: 12æ­¥å…µ", "æ ¼é›·ç´ä¿®å¾©: æ¯å›åˆæ¢å¾©1å‚·å£", "å°„æ“Šè‰™å£12"]
      },
      {
        id: "or-gorkanaut",
        name: "æˆˆå…‹æ©Ÿç”² Gorkanaut",
        points: 265,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103034_Gorkanaut01.jpg",
        stats: { M: 8, T: 12, Sv: 3, W: 20, Ld: 7, OC: 8 },
        inv: 6,
        keywords: ["Vehicle", "Titanic", "Towering", "Walker", "Transport", "Ork"],
        weapons: {
          ranged: { name: "æ¯€æ»…å·¨ç‚® Deffstorm Mega-shoota", range: 36, A: 20, skill: 5, S: 6, AP: -1, D: 1, keywords: ["Rapid Fire 10"] },
          melee: { name: "æˆˆå…‹ä¹‹çˆª Klaw of Gork", A: 5, skill: 3, S: 18, AP: -3, D: 6 }
        },
        abilities: ["é‹è¼¸: 12æ­¥å…µ", "è‡´å‘½æœ«æ—¥D6", "å¤§è€Œå£¯: WAAAGHæ™‚è¿‘æˆ°å‘½ä¸­+1"]
      },
      {
        id: "or-morkanaut",
        name: "è«å…‹æ©Ÿç”² Morkanaut",
        points: 280,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103034_Morkanaut01.jpg",
        stats: { M: 8, T: 12, Sv: 3, W: 20, Ld: 7, OC: 8 },
        inv: 5,
        keywords: ["Vehicle", "Titanic", "Towering", "Walker", "Transport", "Ork"],
        weapons: {
          ranged: { name: "è¶…ç´šç†”æ¯€åŠ è¾²ç ² Kustom Mega-zappa", range: 36, A: "D6+3", skill: 5, S: 10, AP: -2, D: "D6", keywords: ["Blast", "Hazardous"] },
          melee: { name: "è«å…‹ä¹‹çˆª Klaw of Mork", A: 4, skill: 3, S: 18, AP: -3, D: 6 }
        },
        abilities: ["é‹è¼¸: 12æ­¥å…µ", "è‡´å‘½æœ«æ—¥D6", "å¤§è€Œå°„: WAAAGHæ™‚å°„æ“Šå‘½ä¸­+1"]
      },
      {
        id: "or-deffdread",
        name: "æ¯€æ»…ç„¡ç•æ©Ÿç”² Deff Dread",
        points: 85,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103023_DeffDreadNEW01.jpg",
        stats: { M: 8, T: 9, Sv: 3, W: 8, Ld: 7, OC: 3 },
        inv: null,
        keywords: ["Vehicle", "Walker", "Ork"],
        weapons: {
          ranged: { name: "å¤§å°„æ‰‹Ã—2 Big Shootas", range: 36, A: 6, skill: 5, S: 5, AP: 0, D: 1, keywords: ["Rapid Fire 2"] },
          melee: { name: "æ¯€æ»…ä¹‹çˆª Dread Klaw", A: 4, skill: 3, S: 10, AP: -2, D: 3 }
        },
        abilities: ["è‡´å‘½æœ«æ—¥D3"]
      },
      {
        id: "or-killakans",
        name: "æ®ºæˆ®ç½é ­Ã—3 Killa Kans",
        points: 120,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103024_KillaKansNEW01.jpg",
        stats: { M: 6, T: 7, Sv: 4, W: 15, Ld: 8, OC: 4 },
        inv: null,
        keywords: ["Vehicle", "Walker", "Ork", "Gretchin"],
        weapons: {
          ranged: { name: "ç«ç®­ç™¼å°„å™¨ Rokkit Launcha", range: 24, A: 3, skill: 4, S: 9, AP: -2, D: 3 },
          melee: { name: "æ®ºæˆ®é‹¸ Kan Klaw", A: 3, skill: 4, S: 8, AP: -2, D: 2 }
        },
        abilities: ["è‡´å‘½æœ«æ—¥D3"]
      },
      {
        id: "or-beastsnagga-boyz",
        name: "ç¸è¥²ç”·å­©Ã—10 Beast Snagga Boyz",
        points: 105,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103073_ORKSnaggaBoyzLead.jpg",
        stats: { M: 6, T: 5, Sv: 5, W: 11, Ld: 7, OC: 2 },
        inv: 6,
        keywords: ["Infantry", "Battleline", "Ork", "Beast Snagga"],
        weapons: {
          ranged: { name: "ç²—ç³™æ§ Shoota", range: 18, A: 2, skill: 5, S: 4, AP: 0, D: 1 },
          melee: { name: "ç åˆ€ Choppa", A: 3, skill: 3, S: 5, AP: -1, D: 1 }
        },
        abilities: ["ç¸è¥²: å°æ€ªç¸/è¼‰å…·è‡´å‚·+1"]
      },
      {
        id: "or-gretchin",
        name: "æ ¼é›·ç´Ã—10 Gretchin",
        points: 40,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/99120103053_OrkGretchin01.jpg",
        stats: { M: 5, T: 2, Sv: 7, W: 10, Ld: 8, OC: 1 },
        inv: null,
        keywords: ["Infantry", "Ork", "Gretchin"],
        weapons: {
          ranged: { name: "æ ¼é›·ç´çˆ†æ§ Grot Blasta", range: 12, A: 1, skill: 5, S: 3, AP: 0, D: 1 },
          melee: { name: "è¿‘æˆ°æ­¦å™¨", A: 1, skill: 5, S: 2, AP: 0, D: 1 }
        },
        abilities: ["OCè¨ˆç‚º0ï¼ˆåœ¨æ­å…‹æ—é‚Šæ™‚é™¤å¤–ï¼‰"]
      },
      {
        id: "or-squighog",
        name: "æ¾é¼ è±¬é¨å£«Ã—3 Squighog Boyz",
        points: 110,
        img: "https://www.warhammer.com/app/resources/catalog/product/920x950/60010103001_BeastsnaggaHogzGroup2.jpg",
        stats: { M: 10, T: 7, Sv: 4, W: 12, Ld: 7, OC: 2 },
        inv: null,
        keywords: ["Mounted", "Ork", "Beast Snagga"],
        weapons: {
          ranged: { name: "ç²—ç³™æ§ Shoota", range: 18, A: 2, skill: 5, S: 4, AP: 0, D: 1 },
          melee: { name: "ç‹©çµçŸ› Stikka", A: 4, skill: 3, S: 7, AP: -1, D: 2, keywords: ["Lance"] }
        },
        abilities: ["ç¸è¥²: å°æ€ªç¸/è¼‰å…·è‡´å‚·+1", "è¡é‹’å‚·å®³+1"]
      }
    ]
  }
};

// ========== åœ°å½¢å®šç¾© ==========
const TERRAIN_TYPES = {
  ruins: { name: "å»¢å¢Ÿ", color: "#4a5568", coverBonus: true, blockLOS: true },
  woods: { name: "æ¨¹æ—", color: "#2d5a27", coverBonus: true, blockLOS: false },
  barricade: { name: "éšœç¤™ç‰©", color: "#78716c", coverBonus: true, blockLOS: false },
  crater: { name: "å½ˆå‘", color: "#854d0e", coverBonus: true, blockLOS: false },
  building: { name: "å»ºç¯‰ç‰©", color: "#1e40af", coverBonus: true, blockLOS: true }
};

// ========== éŠæˆ²ç‹€æ…‹ ==========
let gameState = {
  phase: "setup", // setup, deployment, command, movement, shooting, charge, fight
  round: 1,
  currentPlayer: 1,
  vp: { 1: 0, 2: 0 },
  cp: { 1: 0, 2: 0 },
  deploy: {
    deployingPlayer: 1,
    p1Deployed: false,
    p2Deployed: false
  },
  units: [],
  terrain: [],
  objectives: [],
  selectedUnit: null,
  targetUnit: null,
  currentAction: null,
  movedUnits: [],
  shotUnits: [],
  chargedUnits: [],
  foughtUnits: [],
  pendingReroll: null,  // ç”¨æ–¼æŒ‡æ®é‡æ“²
  selectedUnitForDeploy: null,  // é¸æ“‡è¦éƒ¨ç½²çš„å–®ä½
  selectedWeapon: null,  // é¸æ“‡çš„æ­¦å™¨
  draggingUnit: null,  // æ‹–æ›³ä¸­çš„å–®ä½
  draggingFromPanel: false,  // å¾å·¦å´é¢æ¿æ‹–æ›³
  // ===== ä»»å‹™ç³»çµ± =====
  primaryMission: null,   // ä¸»è¦ä»»å‹™
  secondaryMissions: { 1: [], 2: [] },  // æ¬¡è¦ä»»å‹™ï¼ˆæ¯å€‹ç©å®¶æœ€å¤š3å€‹ï¼‰
  missionProgress: { 1: {}, 2: {} },    // ä»»å‹™é€²åº¦è¿½è¹¤
  maxRounds: 5  // éŠæˆ²æœ€å¤§å›åˆæ•¸
};

// ===== ä¸»è¦ä»»å‹™å®šç¾© (Primary Missions) =====
const PRIMARY_MISSIONS = {
  "take-and-hold": {
    name: "å¥ªå–ä¸¦å›ºå®ˆ Take and Hold",
    description: "æ§åˆ¶ç›®æ¨™é»ç²å¾—VPã€‚æ§åˆ¶1å€‹ç›®æ¨™=5VPï¼Œæ§åˆ¶æ›´å¤š=10VPï¼Œæ§åˆ¶å¤šæ•¸=15VP",
    scoring: (player) => {
      const controlled = gameState.objectives.filter(o => o.control === player).length;
      const total = gameState.objectives.length;
      if (controlled === 0) return 0;
      if (controlled >= Math.ceil(total / 2) + 1) return 15;  // å¤šæ•¸
      if (controlled >= 2) return 10;
      return 5;
    }
  },
  "supply-drop": {
    name: "ç‰©è³‡æŠ•æ”¾ Supply Drop",
    description: "ç¬¬2ã€3ã€4å›åˆå„æœ‰ä¸€å€‹éš¨æ©Ÿç›®æ¨™é»åƒ¹å€¼ç¿»å€",
    scoring: (player) => {
      const controlled = gameState.objectives.filter(o => o.control === player).length;
      const priorityObj = gameState.objectives.find(o => o.priority && o.control === player);
      let score = controlled * 4;
      if (priorityObj) score += 5;  // å„ªå…ˆç›®æ¨™é¡å¤–+5
      return Math.min(15, score);
    }
  },
  "purge-the-foe": {
    name: "æ®²æ»…æ•µè» Purge the Foe",
    description: "æ‘§æ¯€æ•µæ–¹å–®ä½ç²å¾—VPã€‚æ¯æ‘§æ¯€ä¸€å€‹å–®ä½+2VPï¼Œæ¯å›åˆæœ€å¤š+5VP",
    scoring: (player) => {
      const killedThisRound = gameState.missionProgress[player]?.killedThisRound || 0;
      return Math.min(5, killedThisRound * 2);
    }
  }
};

// ===== æ¬¡è¦ä»»å‹™å®šç¾© (Secondary Missions / Tactical Objectives) =====
const SECONDARY_MISSIONS = {
  // ===== ç„¡ç•é¡ =====
  "assassination": {
    name: "åˆºæ®º Assassination",
    category: "ç„¡ç•",
    maxVP: 12,
    description: "æ‘§æ¯€æ•µæ–¹è§’è‰²å–®ä½ï¼šæ¯å€‹+4VP",
    checkCondition: (player, context) => {
      if (context.type === "kill" && context.killedUnit?.keywords?.includes("Character")) {
        return { scored: true, vp: 4, message: `åˆºæ®ºæˆåŠŸï¼æ“Šæ®º ${context.killedUnit.name}` };
      }
      return { scored: false };
    }
  },
  "bring-it-down": {
    name: "æ“Šè½å·¨ç¸ Bring It Down",
    category: "ç„¡ç•",
    maxVP: 12,
    description: "æ‘§æ¯€æ•µæ–¹æ€ªç¸/è¼‰å…·ï¼šå‚·å£10+å¾—3VPï¼Œ9-å¾—2VP",
    checkCondition: (player, context) => {
      if (context.type === "kill") {
        const target = context.killedUnit;
        const isMonsterOrVehicle = target?.keywords?.includes("Monster") ||
                                   target?.keywords?.includes("Vehicle");
        if (isMonsterOrVehicle) {
          const wounds = target.maxHP || 0;
          const vp = wounds >= 10 ? 3 : 2;
          return { scored: true, vp: vp, message: `æ“Šè½å·¨ç¸ï¼${target.name} (+${vp}VP)` };
        }
      }
      return { scored: false };
    }
  },
  "no-prisoners": {
    name: "æ ¼æ®ºå‹¿è«– No Prisoners",
    category: "ç„¡ç•",
    maxVP: 10,
    description: "ç´¯è¨ˆæ¶ˆæ»…æ•µæ–¹æ¨¡å‹ç²å¾—VPï¼šæ¯10å€‹æ¨¡å‹+2VP",
    checkCondition: (player, context) => {
      if (context.type === "kill") {
        const modelsKilled = context.killedUnit?.modelCount || 1;
        const prev = gameState.missionProgress[player]?.modelsKilledForPrisoners || 0;
        gameState.missionProgress[player].modelsKilledForPrisoners = prev + modelsKilled;
        const total = gameState.missionProgress[player].modelsKilledForPrisoners;
        // æ¯é”åˆ°10çš„å€æ•¸æ™‚å¾—åˆ†
        if (Math.floor(total / 10) > Math.floor(prev / 10)) {
          return { scored: true, vp: 2, message: `æ ¼æ®ºå‹¿è«–ï¼ç´¯è¨ˆæ¶ˆæ»… ${total} æ¨¡å‹` };
        }
      }
      return { scored: false };
    }
  },

  // ===== æˆ°å ´éœ¸æ¬Šé¡ =====
  "behind-enemy-lines": {
    name: "æ·±å…¥æ•µé™£ Behind Enemy Lines",
    category: "æˆ°å ´éœ¸æ¬Š",
    maxVP: 15,
    description: "å›åˆçµæŸæ™‚ï¼Œåœ¨æ•µæ–¹éƒ¨ç½²å€æœ‰å–®ä½ï¼š1å€‹+4VPï¼Œ2å€‹+8VP",
    checkCondition: (player, context) => {
      if (context.type === "endRound") {
        const enemyZone = player === 1 ? "right" : "left";
        const w = gameState.canvasWidth || 600;
        const deployZone = gameState.deployZone || inchToPixels(12);

        const unitsInEnemyZone = gameState.units.filter(u => {
          if (!u.alive || u.player !== player) return false;
          if (enemyZone === "right") return u.x > w - deployZone;
          return u.x < deployZone;
        });

        if (unitsInEnemyZone.length >= 2) {
          return { scored: true, vp: 8, message: "æ·±å…¥æ•µé™£ï¼2å€‹å–®ä½åœ¨æ•µæ–¹éƒ¨ç½²å€" };
        } else if (unitsInEnemyZone.length === 1) {
          return { scored: true, vp: 4, message: "æ·±å…¥æ•µé™£ï¼1å€‹å–®ä½åœ¨æ•µæ–¹éƒ¨ç½²å€" };
        }
      }
      return { scored: false };
    }
  },
  "engage-on-all-fronts": {
    name: "å…¨é¢æ¥æˆ° Engage on All Fronts",
    category: "æˆ°å ´éœ¸æ¬Š",
    maxVP: 15,
    description: "å›åˆçµæŸæ™‚ï¼Œåœ¨3å€‹ä»¥ä¸Šæˆ°å ´è±¡é™æœ‰å–®ä½+3VPï¼Œ4å€‹è±¡é™+6VP",
    checkCondition: (player, context) => {
      if (context.type === "endRound") {
        const w = gameState.canvasWidth || 600;
        const h = gameState.canvasHeight || 440;
        const midX = w / 2, midY = h / 2;

        let quadrants = { q1: false, q2: false, q3: false, q4: false };
        for (const unit of gameState.units) {
          if (!unit.alive || unit.player !== player) continue;
          if (unit.x < midX && unit.y < midY) quadrants.q1 = true;
          else if (unit.x >= midX && unit.y < midY) quadrants.q2 = true;
          else if (unit.x < midX && unit.y >= midY) quadrants.q3 = true;
          else quadrants.q4 = true;
        }

        const count = Object.values(quadrants).filter(v => v).length;
        if (count >= 4) return { scored: true, vp: 6, message: "å…¨é¢æ¥æˆ°ï¼è¦†è“‹4å€‹è±¡é™" };
        if (count >= 3) return { scored: true, vp: 3, message: "å…¨é¢æ¥æˆ°ï¼è¦†è“‹3å€‹è±¡é™" };
      }
      return { scored: false };
    }
  },
  "hold-the-line": {
    name: "å …å®ˆé˜²ç·š Hold the Line",
    category: "æˆ°å ´éœ¸æ¬Š",
    maxVP: 12,
    description: "å›åˆçµæŸæ™‚ï¼Œå·±æ–¹éƒ¨ç½²å€å¤–æœ‰3å€‹ä»¥ä¸Šå–®ä½+4VP",
    checkCondition: (player, context) => {
      if (context.type === "endRound") {
        const w = gameState.canvasWidth || 600;
        const deployZone = gameState.deployZone || inchToPixels(12);

        const unitsOutside = gameState.units.filter(u => {
          if (!u.alive || u.player !== player) return false;
          if (player === 1) return u.x > deployZone;
          return u.x < w - deployZone;
        });

        if (unitsOutside.length >= 3) {
          return { scored: true, vp: 4, message: "å …å®ˆé˜²ç·šï¼3å€‹ä»¥ä¸Šå–®ä½åœ¨éƒ¨ç½²å€å¤–" };
        }
      }
      return { scored: false };
    }
  },

  // ===== ç´”ç²¹æˆ°è¡“é¡ =====
  "storm-hostile": {
    name: "çªè¥²æ•µé™£ Storm Hostile Objective",
    category: "ç´”ç²¹æˆ°è¡“",
    maxVP: 12,
    description: "æœ¬å›åˆä½”é ˜åŸæœ¬ç”±æ•µæ–¹æ§åˆ¶çš„ç›®æ¨™+4VP",
    checkCondition: (player, context) => {
      if (context.type === "objectiveCaptured" && context.previousControl !== player && context.previousControl !== null) {
        return { scored: true, vp: 4, message: `çªè¥²æ•µé™£ï¼å¥ªå–ç›®æ¨™ ${context.objective?.id || ""}` };
      }
      return { scored: false };
    }
  },
  "defend-stronghold": {
    name: "å®ˆè¡›æ“šé» Defend Stronghold",
    category: "ç´”ç²¹æˆ°è¡“",
    maxVP: 12,
    description: "é€£çºŒ2å›åˆæ§åˆ¶åŒä¸€å€‹ç›®æ¨™+4VP",
    checkCondition: (player, context) => {
      if (context.type === "endRound") {
        for (const obj of gameState.objectives) {
          if (obj.control === player) {
            obj.controlDuration = (obj.controlDuration || 0) + 1;
            if (obj.controlDuration >= 2 && !obj.defendScored) {
              obj.defendScored = true;
              return { scored: true, vp: 4, message: `å®ˆè¡›æ“šé»ï¼æŒçºŒæ§åˆ¶ç›®æ¨™ ${obj.id}` };
            }
          } else {
            obj.controlDuration = 0;
            obj.defendScored = false;
          }
        }
      }
      return { scored: false };
    }
  }
};

// åˆå§‹åŒ–ä»»å‹™ç³»çµ±
function initMissionSystem() {
  // éš¨æ©Ÿé¸æ“‡ä¸»è¦ä»»å‹™
  const missionKeys = Object.keys(PRIMARY_MISSIONS);
  const randomMission = missionKeys[Math.floor(Math.random() * missionKeys.length)];
  gameState.primaryMission = randomMission;

  // åˆå§‹åŒ–ä»»å‹™é€²åº¦
  gameState.missionProgress = {
    1: { killedThisRound: 0, modelsKilled: 0, modelsKilledForPrisoners: 0 },
    2: { killedThisRound: 0, modelsKilled: 0, modelsKilledForPrisoners: 0 }
  };

  // åˆå§‹åŒ–æ¬¡è¦ä»»å‹™é¸æ“‡
  if (!gameState.secondaryMissions) {
    gameState.secondaryMissions = { 1: [], 2: [] };
  }

  log(`ğŸ“‹ ä¸»è¦ä»»å‹™: ${PRIMARY_MISSIONS[randomMission].name}`, "phase");
  log(`ğŸ“ ${PRIMARY_MISSIONS[randomMission].description}`, "info");

  // æ›´æ–°ä»»å‹™UI
  updateMissionUI();
}

// æª¢æŸ¥æ¬¡è¦ä»»å‹™
function checkSecondaryMissions(player, context) {
  const missions = gameState.secondaryMissions[player] || [];
  for (const missionId of missions) {
    const mission = SECONDARY_MISSIONS[missionId];
    if (!mission) continue;

    const result = mission.checkCondition(player, context);
    if (result.scored) {
      gameState.vp[player] += result.vp;
      log(`ğŸ¯ [æ¬¡è¦ä»»å‹™] ${result.message}`, "phase");
      updateVPDisplay();
    }
  }
}

// é¸æ“‡æ¬¡è¦ä»»å‹™
function selectSecondaryMission(player, missionId) {
  if (!SECONDARY_MISSIONS[missionId]) return false;
  if (gameState.secondaryMissions[player].length >= 3) {
    log("å·²é¸æ“‡3å€‹æ¬¡è¦ä»»å‹™ï¼Œç„¡æ³•å†æ·»åŠ ", "info");
    return false;
  }
  if (gameState.secondaryMissions[player].includes(missionId)) {
    log("è©²ä»»å‹™å·²è¢«é¸æ“‡", "info");
    return false;
  }
  gameState.secondaryMissions[player].push(missionId);
  log(`âœ… ç©å®¶${player}é¸æ“‡æ¬¡è¦ä»»å‹™: ${SECONDARY_MISSIONS[missionId].name}`, "info");
  return true;
}

// ===== Transportï¼ˆé‹è¼¸è¼‰å…·ï¼‰ç³»çµ± - å®˜æ–¹10ç‰ˆè¦å‰‡ =====
// é‹è¼¸è¼‰å…·å¯ä»¥æ­è¼‰æ­¥å…µå–®ä½ï¼Œæ­è¼‰/ä¸‹è»Šæœ‰ç‰¹å®šè¦å‰‡

// ç²å–é‹è¼¸è¼‰å…·çš„å®¹é‡
function getTransportCapacity(unit) {
  if (!unit || !unit.abilities) return 0;
  for (const ability of unit.abilities) {
    // åŒ¹é… "é‹è¼¸: Xæ¨¡å‹" æˆ– "Transport: X"
    const match = ability.match(/é‹è¼¸[:\s]*(\d+)|Transport[:\s]*(\d+)/i);
    if (match) {
      return parseInt(match[1] || match[2]);
    }
  }
  return 0;
}

// æª¢æŸ¥å–®ä½æ˜¯å¦å¯ä»¥æ­è¼‰åˆ°é‹è¼¸è¼‰å…·
function canEmbark(unit, transport) {
  if (!unit || !transport) return false;
  if (unit.player !== transport.player) return false;
  if (!unit.alive || !transport.alive) return false;
  if (unit.embarkedIn) return false;  // å·²ç¶“åœ¨å…¶ä»–è¼‰å…·ä¸­

  // åªæœ‰æ­¥å…µå¯ä»¥æ­è¼‰
  if (!unit.keywords?.includes("Infantry")) return false;

  // æª¢æŸ¥è¼‰å…·å®¹é‡
  const capacity = getTransportCapacity(transport);
  if (capacity <= 0) return false;

  // è¨ˆç®—å·²æ­è¼‰çš„æ¨¡å‹æ•¸
  const embarkedModels = (transport.embarkedUnits || []).reduce((sum, id) => {
    const embarked = gameState.units.find(u => u.id === id);
    return sum + (embarked?.modelCount || 1);
  }, 0);

  const unitModels = unit.modelCount || 1;
  if (embarkedModels + unitModels > capacity) return false;

  // æª¢æŸ¥è·é›¢ï¼šå¿…é ˆåœ¨3"ä»¥å…§
  const dist = Math.hypot(unit.x - transport.x, unit.y - transport.y);
  if (dist > inchToPixels(3)) return false;

  return true;
}

// æ­è¼‰å–®ä½åˆ°é‹è¼¸è¼‰å…·
function embarkUnit(unit, transport) {
  if (!canEmbark(unit, transport)) {
    log(`âŒ ${unit.name} ç„¡æ³•æ­è¼‰åˆ° ${transport.name}`, "info");
    return false;
  }

  // åˆå§‹åŒ–æ­è¼‰åˆ—è¡¨
  if (!transport.embarkedUnits) transport.embarkedUnits = [];

  transport.embarkedUnits.push(unit.id);
  unit.embarkedIn = transport.id;
  unit.visible = false;  // éš±è—å·²æ­è¼‰çš„å–®ä½
  unit.hasMoved = true;  // æ­è¼‰ç®—ä½œç§»å‹•

  log(`ğŸš ${unit.name} æ­è¼‰åˆ° ${transport.name}`, "info");
  playSound('move');

  updateUnitLists();
  render();

  // ç·šä¸ŠåŒæ­¥
  if (isOnlineMode) {
    syncGameStateToFirebase();
  }

  return true;
}

// ä¸‹è»Šï¼šå–®ä½å¾é‹è¼¸è¼‰å…·ä¸­å‡ºä¾†
function disembarkUnit(unit, transport, isEmergency = false) {
  if (!unit || !transport) return false;
  if (unit.embarkedIn !== transport.id) return false;

  // æ‰¾åˆ°ä¸‹è»Šä½ç½®ï¼ˆè¼‰å…·å‘¨åœ3"å…§ï¼‰
  const disembarkRange = inchToPixels(3);
  const baseSize = getUnitBaseSize(unit);
  let validPosition = null;

  // å˜—è©¦åœ¨è¼‰å…·å‘¨åœæ‰¾åˆ°æœ‰æ•ˆä½ç½®
  for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
    for (let dist = baseSize + 10; dist <= disembarkRange; dist += 20) {
      const testX = transport.x + Math.cos(angle) * dist;
      const testY = transport.y + Math.sin(angle) * dist;

      // æª¢æŸ¥ä½ç½®æ˜¯å¦æœ‰æ•ˆï¼ˆä¸èˆ‡å…¶ä»–å–®ä½é‡ç–Šï¼Œåœ¨æˆ°å ´å…§ï¼‰
      if (isValidPosition(testX, testY, unit)) {
        validPosition = { x: testX, y: testY };
        break;
      }
    }
    if (validPosition) break;
  }

  if (!validPosition) {
    log(`âŒ ${unit.name} ç„¡æ³•ä¸‹è»Šï¼šæ²’æœ‰æœ‰æ•ˆä½ç½®`, "info");
    return false;
  }

  // å¾è¼‰å…·ç§»é™¤
  transport.embarkedUnits = transport.embarkedUnits.filter(id => id !== unit.id);
  unit.embarkedIn = null;
  unit.visible = true;
  unit.x = validPosition.x;
  unit.y = validPosition.y;
  unit.deployed = true;

  // æ­£å¸¸ä¸‹è»Šï¼šå–®ä½å·²ç§»å‹•ï¼Œåªèƒ½å°„æ“ŠAssaultæ­¦å™¨
  // ç·Šæ€¥ä¸‹è»Šï¼šå¿…é ˆæ“²D6ï¼Œ1å‰‡å—D6è‡´å‘½å‚·
  if (isEmergency) {
    unit.hasMoved = true;
    unit.hasAdvanced = true;  // ç·Šæ€¥ä¸‹è»Šè¦–ç‚ºæ€¥è¡Œ
    const roll = rollD6();
    if (roll === 1) {
      const mortalWounds = rollD6();
      unit.currentHP -= mortalWounds;
      log(`ğŸ’¥ ${unit.name} ç·Šæ€¥ä¸‹è»Šå¤±æ•—ï¼å—åˆ° ${mortalWounds} è‡´å‘½å‚·`, "damage");
      if (unit.currentHP <= 0) {
        unit.currentHP = 0;
        unit.alive = false;
        log(`ğŸ’€ ${unit.name} åœ¨ç·Šæ€¥ä¸‹è»Šä¸­è¢«æ¶ˆæ»…ï¼`, "damage");
      }
    } else {
      log(`ğŸš ${unit.name} ç·Šæ€¥ä¸‹è»ŠæˆåŠŸ (æ“² ${roll})`, "info");
    }
  } else {
    unit.hasMoved = true;
    log(`ğŸš ${unit.name} å¾ ${transport.name} ä¸‹è»Š`, "info");
  }

  playSound('move');
  updateUnitLists();
  render();

  if (isOnlineMode) {
    syncGameStateToFirebase();
  }

  return true;
}

// æª¢æŸ¥ä½ç½®æ˜¯å¦æœ‰æ•ˆ
function isValidPosition(x, y, unit) {
  const w = gameState.canvasWidth || 600;
  const h = gameState.canvasHeight || 440;
  const baseSize = getUnitBaseSize(unit);

  // æª¢æŸ¥æ˜¯å¦åœ¨æˆ°å ´å…§
  if (x < baseSize || x > w - baseSize || y < baseSize || y > h - baseSize) {
    return false;
  }

  // æª¢æŸ¥æ˜¯å¦èˆ‡å…¶ä»–å–®ä½é‡ç–Š
  for (const other of gameState.units) {
    if (!other.alive || other.id === unit.id || other.embarkedIn) continue;
    const otherSize = getUnitBaseSize(other);
    const dist = Math.hypot(x - other.x, y - other.y);
    if (dist < baseSize + otherSize) {
      return false;
    }
  }

  return true;
}

// é‹è¼¸è¼‰å…·è¢«æ‘§æ¯€æ™‚è™•ç†æ­è¼‰å–®ä½
function handleTransportDestroyed(transport) {
  if (!transport.embarkedUnits || transport.embarkedUnits.length === 0) return;

  log(`ğŸ’¥ ${transport.name} è¢«æ‘§æ¯€ï¼æ­è¼‰çš„å–®ä½å¿…é ˆç·Šæ€¥ä¸‹è»Š`, "phase");

  for (const unitId of [...transport.embarkedUnits]) {
    const unit = gameState.units.find(u => u.id === unitId);
    if (unit && unit.alive) {
      // ç·Šæ€¥ä¸‹è»Š
      const success = disembarkUnit(unit, transport, true);
      if (!success) {
        // ç„¡æ³•ä¸‹è»Šçš„å–®ä½è¢«æ¶ˆæ»…
        unit.alive = false;
        unit.embarkedIn = null;
        unit.visible = true;
        log(`ğŸ’€ ${unit.name} ç„¡æ³•é€ƒé›¢è¢«æ‘§æ¯€çš„è¼‰å…·ï¼`, "damage");
      }
    }
  }
  transport.embarkedUnits = [];
}

// ===== Aircraftï¼ˆé£›è¡Œå™¨ï¼‰ç³»çµ± - å®˜æ–¹10ç‰ˆè¦å‰‡ =====
// é£›è¡Œå™¨æœ‰ç‰¹æ®Šç§»å‹•è¦å‰‡ï¼šå¿…é ˆç§»å‹•æœ€å°‘20"ï¼ˆæˆ–é›¢é–‹æˆ°å ´é€²å…¥æˆ°ç•¥é å‚™éšŠï¼‰

// æª¢æŸ¥å–®ä½æ˜¯å¦æ˜¯é£›è¡Œå™¨
function isAircraft(unit) {
  return unit?.keywords?.includes("Aircraft");
}

// æª¢æŸ¥é£›è¡Œå™¨æ˜¯å¦å¯ä»¥æ‡¸åœ
function canHover(unit) {
  if (!isAircraft(unit)) return false;
  return unit.abilities?.some(a => a.includes("æ‡¸åœ") || a.includes("Hover"));
}

// é£›è¡Œå™¨ç§»å‹•ï¼ˆç‰¹æ®Šè¦å‰‡ï¼‰
function moveAircraft(unit, targetX, targetY) {
  if (!isAircraft(unit)) return false;

  const minMove = inchToPixels(20);  // æœ€å°ç§»å‹•è·é›¢
  const maxMove = inchToPixels(unit.stats.M || 20);
  const dist = Math.hypot(targetX - unit.x, targetY - unit.y);

  // å¦‚æœé¸æ“‡æ‡¸åœï¼Œå¯ä»¥åƒæ™®é€šå–®ä½ä¸€æ¨£ç§»å‹•
  if (canHover(unit) && unit.isHovering) {
    // æ‡¸åœæ¨¡å¼ï¼šæ­£å¸¸ç§»å‹•ï¼Œä½†OCè®Šç‚º0
    if (dist <= maxMove) {
      unit.x = targetX;
      unit.y = targetY;
      unit.hasMoved = true;
      log(`ğŸš ${unit.name} æ‡¸åœç§»å‹•`, "info");
      return true;
    }
    return false;
  }

  // æ­£å¸¸é£›è¡Œæ¨¡å¼ï¼šå¿…é ˆç§»å‹•è‡³å°‘20"
  if (dist < minMove) {
    log(`âœˆï¸ ${unit.name} æ˜¯é£›è¡Œå™¨ï¼Œå¿…é ˆç§»å‹•è‡³å°‘ 20"`, "info");
    return false;
  }

  if (dist > maxMove) {
    log(`âœˆï¸ ${unit.name} ç§»å‹•è·é›¢è¶…éæœ€å¤§å€¼ ${unit.stats.M}"`, "info");
    return false;
  }

  unit.x = targetX;
  unit.y = targetY;
  unit.hasMoved = true;
  log(`âœˆï¸ ${unit.name} é£›è¡Œç§»å‹•`, "info");
  return true;
}

// é£›è¡Œå™¨é€²å…¥æˆ°ç•¥é å‚™éšŠï¼ˆé›¢é–‹æˆ°å ´ï¼‰
function aircraftEnterReserves(unit) {
  if (!isAircraft(unit)) return false;

  unit.inReserves = true;
  unit.visible = false;
  unit.reserveRound = gameState.round;
  log(`âœˆï¸ ${unit.name} é›¢é–‹æˆ°å ´é€²å…¥æˆ°ç•¥é å‚™éšŠ`, "phase");

  updateUnitLists();
  render();
  return true;
}

// é£›è¡Œå™¨å¾æˆ°ç•¥é å‚™éšŠè¿”å›
function aircraftReturnFromReserves(unit, x, y) {
  if (!isAircraft(unit)) return false;
  if (!unit.inReserves) return false;

  // å¿…é ˆå¾è‡ªå·±çš„æˆ°å ´é‚Šç·£é€²å…¥
  const w = gameState.canvasWidth || 600;
  const edgeBuffer = inchToPixels(1);

  const isValidEntry = (unit.player === 1 && x <= edgeBuffer) ||
                       (unit.player === 2 && x >= w - edgeBuffer);

  if (!isValidEntry) {
    log(`âœˆï¸ ${unit.name} å¿…é ˆå¾å·±æ–¹æˆ°å ´é‚Šç·£é€²å…¥`, "info");
    return false;
  }

  unit.inReserves = false;
  unit.visible = true;
  unit.x = x;
  unit.y = y;
  unit.hasMoved = true;
  log(`âœˆï¸ ${unit.name} å¾æˆ°ç•¥é å‚™éšŠè¿”å›æˆ°å ´`, "phase");

  updateUnitLists();
  render();
  return true;
}

// åˆ‡æ›é£›è¡Œå™¨æ‡¸åœæ¨¡å¼
function toggleHoverMode(unit) {
  if (!canHover(unit)) return false;

  unit.isHovering = !unit.isHovering;
  if (unit.isHovering) {
    log(`ğŸš ${unit.name} é€²å…¥æ‡¸åœæ¨¡å¼ (OCè®Šç‚º0)`, "info");
  } else {
    log(`âœˆï¸ ${unit.name} é€€å‡ºæ‡¸åœæ¨¡å¼`, "info");
  }
  return true;
}

let armyRosters = { 1: [], 2: [] };
let canvas, ctx;
let ai1Enabled = false;  // ç©å®¶ä¸€AI
let ai2Enabled = true;   // ç©å®¶äºŒAI
let aiDifficulty = "normal";

// ========== è¦–åœ–ç¸®æ”¾ç³»çµ± ==========
let viewZoom = 1.0;        // ç•¶å‰ç¸®æ”¾æ¯”ä¾‹
let viewOffsetX = 0;       // è¦–åœ–åç§»X
let viewOffsetY = 0;       // è¦–åœ–åç§»Y
let isDragging = false;    // æ˜¯å¦æ­£åœ¨æ‹–æ›³
let dragStartX = 0;
let dragStartY = 0;
const MIN_ZOOM = 0.3;
const MAX_ZOOM = 4.0;
const ZOOM_STEP = 0.1;

// ========== å–®ä½åœ–åƒç·©å­˜ ==========
const unitImageCache = {};
const imageLoadAttempted = {}; // è¿½è¹¤å·²å˜—è©¦è¼‰å…¥çš„åœ–ç‰‡

function loadUnitImage(unit) {
  if (!unit.img) return null;
  if (unitImageCache[unit.img]) return unitImageCache[unit.img];
  if (imageLoadAttempted[unit.img]) return null; // å·²å˜—è©¦éï¼Œä¸å†é‡è¤‡

  imageLoadAttempted[unit.img] = true;
  const img = new Image();
  img.src = unit.img;
  img.onload = () => { unitImageCache[unit.img] = img; };
  img.onerror = () => { unitImageCache[unit.img] = null; };
  unitImageCache[unit.img] = img;
  return img;
}

// ========== å–®ä½åº•æ¿å¤§å°è¨ˆç®— ==========
// æ ¹æ“š WH40K å®˜æ–¹åº•æ¿å°ºå¯¸è¦ç¯„
// åº•æ¿å°ºå¯¸æ›ç®—: 25mm â‰ˆ 1", 32mm â‰ˆ 1.25", 40mm â‰ˆ 1.6", 50mm â‰ˆ 2",
// ===== å°éšŠæ¨¡å‹è‡ªå‹•è·Ÿéš¨ =====
// ç•¶å–®ä½ç§»å‹•æ™‚ï¼Œæ›´æ–°æ‰€æœ‰å°éšŠæ¨¡å‹çš„ä½ç½®
function updateSquadModelPositions(unit) {
  if (!unit.isSquad || !unit.models) return;

  // æ¨¡å‹é–“è·ï¼šæ ¹æ“šæ¨¡å‹æ•¸é‡èª¿æ•´ï¼Œç¢ºä¿ä¸é‡ç–Š
  const baseModelSize = Math.max(12, getUnitBaseSize(unit) * 0.5);
  const spacing = Math.max(inchToPixels(0.8), baseModelSize * 2.2);
  const cols = Math.ceil(Math.sqrt(unit.modelCount));
  const rows = Math.ceil(unit.modelCount / cols);

  unit.models.forEach((model, i) => {
    const row = Math.floor(i / cols);
    const col = i % cols;
    model.x = unit.x + (col - (cols - 1) / 2) * spacing;
    model.y = unit.y + (row - (rows - 1) / 2) * spacing;
  });
}

// è¨ˆç®—å°éšŠçš„ç¸½å±•é–‹åŠå¾‘ï¼ˆç”¨æ–¼ç¢°æ’æª¢æ¸¬ï¼‰
function getSquadSpreadRadius(unit) {
  if (!unit.isSquad || !unit.models || unit.modelCount <= 1) {
    return getUnitBaseSize(unit);
  }
  const baseModelSize = Math.max(12, getUnitBaseSize(unit) * 0.5);
  const spacing = Math.max(inchToPixels(0.8), baseModelSize * 2.2);
  const cols = Math.ceil(Math.sqrt(unit.modelCount));
  const rows = Math.ceil(unit.modelCount / cols);
  // è¨ˆç®—å¾ä¸­å¿ƒåˆ°æœ€é æ¨¡å‹çš„è·é›¢
  const maxColOffset = (cols - 1) / 2 * spacing;
  const maxRowOffset = (rows - 1) / 2 * spacing;
  return Math.hypot(maxColOffset, maxRowOffset) + baseModelSize;
}

//              60mm â‰ˆ 2.4", 80mm â‰ˆ 3.15", 100mm â‰ˆ 4", 130mm â‰ˆ 5"
// å›å‚³å€¼ç‚ºåŠå¾‘(åƒç´ )ï¼Œä»¥ç¶²æ ¼ç‚ºåŸºæº–å–®ä½ï¼Œæ¯”ä¾‹å°æ‡‰å®˜æ–¹åº•æ¿
function getUnitBaseSize(unit) {
  // å¦‚æœå–®ä½æœ‰è‡ªå®šç¾©åº•æ¿å¤§å°ï¼Œä½¿ç”¨å®ƒ
  if (unit.baseSize) return unit.baseSize;

  const keywords = unit.keywords || [];
  const name = unit.name || "";
  const stats = unit.stats || {};
  const gridSize = getGridSize();

  // æ ¹æ“šé—œéµå­—åˆ¤æ–·å–®ä½å¤§å°ï¼ˆä»¥ç¶²æ ¼ç‚ºå–®ä½ï¼‰
  let sizeInGrids = UNIT_SIZE_IN_GRIDS.default;  // é è¨­ 32mm

  // æ³°å¦ç´š 130mm+ (5x)
  if (keywords.includes("Titanic") || name.includes("é‡‘å­—å¡”") || name.includes("Monolith") ||
      name.includes("æ²‰é»˜ä¹‹ç‹") || name.includes("Silent King") ||
      name.includes("Hierophant") || name.includes("ç¥­å¸ç¸")) {
    sizeInGrids = UNIT_SIZE_IN_GRIDS.titanic;
  }
  // å¤§å‹æ€ªç¸ 100mm (4x) - C'tanã€å¤§å‹æ€ªç¸
  else if (keywords.includes("C'tan") ||
      (keywords.includes("Monster") && stats.W >= 14) ||
      name.includes("æ˜Ÿç¥") || name.includes("Norn") || name.includes("å¤è€") ||
      name.includes("æš´å›ç¸") || name.includes("Tyrannofex") ||
      name.includes("ç©¿åœ°ç¸") || name.includes("Trygon") ||
      name.includes("å·¨å£ç¸") || name.includes("Mawloc")) {
    sizeInGrids = UNIT_SIZE_IN_GRIDS.large_monster;
  }
  // ä¸­å‹æ€ªç¸/è¼‰å…· 60-80mm (3x)
  else if ((keywords.includes("Monster") && stats.W >= 8) ||
      keywords.includes("Vehicle") ||
      name.includes("å± æ®ºç¸") || name.includes("Carnifex") ||
      name.includes("å™´å°„ç¸") || name.includes("Exocrine") ||
      name.includes("åå™¬ç¸") || name.includes("Haruspex") ||
      name.includes("æƒ¡æ„ç¸") || name.includes("Maleceptor") ||
      name.includes("æœ«æ—¥") || name.includes("Doomsday") || name.includes("Doomstalker") ||
      name.includes("æ–¹èˆŸ") || name.includes("Ark") ||
      name.includes("ç„¡ç•") || name.includes("Dreadnought") ||
      name.includes("èŸ²å·¢æš´å›") || name.includes("Hive Tyrant") ||
      name.includes("èŸ²ç¾¤éœ¸ä¸»") || name.includes("Swarmlord") ||
      name.includes("ç¹æ®–ç¸") || name.includes("Tervigon")) {
    sizeInGrids = UNIT_SIZE_IN_GRIDS.vehicle;
  }
  // å°å‹æ€ªç¸ 50mm (2x)
  else if ((keywords.includes("Monster") && stats.W >= 5) ||
      name.includes("æ¯€æ»…è€…") || name.includes("Destroyer") ||
      name.includes("å¹½éˆ") || name.includes("Wraith") ||
      name.includes("éˆèƒ½ç¸") || name.includes("Zoanthrope") ||
      name.includes("ä¼æ“Šè€…") || name.includes("Lictor") ||
      name.includes("è‚²æ¯èŸ²") || name.includes("Broodlord")) {
    sizeInGrids = UNIT_SIZE_IN_GRIDS.small_monster;
  }
  // èè‹±/è§’è‰² 40mm (1.6x)
  else if (keywords.includes("Character") ||
      name.includes("éœ¸ä¸»") || name.includes("Overlord") ||
      name.includes("é ˜ä¸»") || name.includes("Lord") ||
      name.includes("è¡“å£«") || name.includes("mancer") ||
      name.includes("æš—è¡›") || name.includes("Lychguard") ||
      name.includes("èŸ²æ—æˆ°å£«") || name.includes("Tyranid Warriors")) {
    sizeInGrids = UNIT_SIZE_IN_GRIDS.elite;
  }
  // åŸºç¤æ­¥å…µ 25mm (1x)
  else if (name.includes("Ã—10") || name.includes("Ã—5") ||
      name.includes("ç™½èŸ»") || name.includes("Termagant") ||
      name.includes("åˆºèŸ²") || name.includes("Hormagaunt") ||
      name.includes("ç¿¼èŸ²") || name.includes("Gargoyle") ||
      name.includes("ç”²èŸ²") || name.includes("Scarab")) {
    sizeInGrids = UNIT_SIZE_IN_GRIDS.infantry;
  }

  // è¿”å›åŠå¾‘ï¼ˆç¶²æ ¼æ•¸ * ç¶²æ ¼å¤§å° / 2ï¼‰
  return Math.round(sizeInGrids * gridSize / 2);
}

// ========== æ™ºèƒ½éƒ¨ç½²ç³»çµ± ==========
// æª¢æŸ¥ä½ç½®æ˜¯å¦èˆ‡å·²éƒ¨ç½²å–®ä½é‡ç–Šï¼ˆè€ƒæ…®å°éšŠå±•é–‹ç¯„åœï¼‰
function isPositionValid(x, y, baseSize, deployedUnits, minGap = 10, checkingUnit = null) {
  // è¨ˆç®—æª¢æŸ¥å–®ä½çš„å¯¦éš›ä½”ç”¨ç¯„åœï¼ˆå°éšŠéœ€è¦æ›´å¤§ç¯„åœï¼‰
  let effectiveSize = baseSize;
  if (checkingUnit && checkingUnit.isSquad) {
    effectiveSize = getSquadSpreadRadius(checkingUnit);
  }

  for (const other of deployedUnits) {
    if (!other.alive) continue; // è·³éå·²æ­»äº¡å–®ä½

    // è¨ˆç®—å…¶ä»–å–®ä½çš„å¯¦éš›ä½”ç”¨ç¯„åœ
    let otherEffectiveSize = getUnitBaseSize(other);
    if (other.isSquad) {
      otherEffectiveSize = getSquadSpreadRadius(other);
    }

    const minDist = effectiveSize + otherEffectiveSize + minGap;
    const dist = Math.hypot(x - other.x, y - other.y);
    if (dist < minDist) return false;
  }
  return true;
}

// æ™ºèƒ½éƒ¨ç½²å–®ä½ï¼Œé¿å…é‡ç–Š
function smartDeployUnits(units, player, deployZoneWidth, canvasWidth, canvasHeight) {
  // æŒ‰åº•æ¿å¤§å°æ’åºï¼ˆå¤§çš„å…ˆéƒ¨ç½²ï¼Œæ–¹ä¾¿å®‰æ’ç©ºé–“ï¼‰
  const sortedUnits = [...units].sort((a, b) => getUnitBaseSize(b) - getUnitBaseSize(a));
  const deployedInThisCall = [];

  const margin = 15; // é‚Šç•Œå®‰å…¨è·é›¢
  const maxAttempts = 50; // æœ€å¤§å˜—è©¦æ¬¡æ•¸

  for (const unit of sortedUnits) {
    const baseSize = getUnitBaseSize(unit);
    let placed = false;

    // è¨ˆç®—éƒ¨ç½²å€åŸŸç¯„åœï¼ˆç¢ºä¿æœ‰æ•ˆç¯„åœï¼‰
    let xMin, xMax;
    if (player === 1) {
      xMin = margin + baseSize;
      xMax = Math.max(xMin + baseSize, deployZoneWidth - baseSize - margin);
    } else {
      xMin = canvasWidth - deployZoneWidth + margin + baseSize;
      xMax = Math.max(xMin + baseSize, canvasWidth - margin - baseSize);
    }

    const yMin = margin + baseSize;
    const yMax = Math.max(yMin + baseSize, canvasHeight - margin - baseSize);

    // å·²éƒ¨ç½²å–®ä½ï¼ˆåŒ…æ‹¬å…¶ä»–ç©å®¶çš„å’Œæœ¬æ¬¡éƒ¨ç½²çš„ï¼‰
    const allDeployed = [...deployedInThisCall, ...units.filter(u => u !== unit && u.deployed)];

    // æ–¹æ³•1ï¼šç¶²æ ¼æƒææ‰¾åˆ°åˆé©ä½ç½®
    const gridStep = baseSize * 1.5; // ç¶²æ ¼é–“è·
    for (let y = yMin; y <= yMax && !placed; y += gridStep) {
      for (let x = xMin; x <= xMax && !placed; x += gridStep) {
        if (isPositionValid(x, y, baseSize, allDeployed)) {
          unit.x = x;
          unit.y = y;
          placed = true;
        }
      }
    }

    // æ–¹æ³•2ï¼šå¦‚æœç¶²æ ¼æ²’æ‰¾åˆ°ï¼Œéš¨æ©Ÿå˜—è©¦
    if (!placed) {
      for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
        const x = xMin + Math.random() * (xMax - xMin);
        const y = yMin + Math.random() * (yMax - yMin);
        if (isPositionValid(x, y, baseSize, allDeployed, 2)) { // æ¸›å°‘é–“éš™è¦æ±‚
          unit.x = x;
          unit.y = y;
          placed = true;
        }
      }
    }

    // æ–¹æ³•3ï¼šå¼·åˆ¶æ”¾ç½®ï¼ˆæœ€å¾Œæ‰‹æ®µï¼Œå…è¨±å¾®å°é‡ç–Šï¼‰
    if (!placed) {
      // æ‰¾åˆ°é‡ç–Šæœ€å°‘çš„ä½ç½®
      let bestX = xMin, bestY = yMin, minOverlap = Infinity;
      for (let y = yMin; y <= yMax; y += gridStep / 2) {
        for (let x = xMin; x <= xMax; x += gridStep / 2) {
          let totalOverlap = 0;
          for (const other of allDeployed) {
            const otherSize = getUnitBaseSize(other);
            const minDist = baseSize + otherSize;
            const dist = Math.hypot(x - other.x, y - other.y);
            if (dist < minDist) {
              totalOverlap += (minDist - dist);
            }
          }
          if (totalOverlap < minOverlap) {
            minOverlap = totalOverlap;
            bestX = x;
            bestY = y;
          }
        }
      }
      unit.x = bestX;
      unit.y = bestY;
    }

    unit.deployed = true;
    unit.visible = true;
    deployedInThisCall.push(unit);
  }
}

// ========== æˆ°å ´è¦–è¦ºç‰¹æ•ˆç³»çµ± ==========
const visualEffects = {
  floatingTexts: [],    // æµ®å‹•æ–‡å­—ï¼ˆæŠ€èƒ½åç¨±ã€å‚·å®³æ•¸å­—ï¼‰
  attackLines: [],      // æ”»æ“Šå°„ç·š
  explosions: []        // çˆ†ç‚¸æ•ˆæœ
};

// è¦–è¦ºç‰¹æ•ˆä¸Šé™ï¼ˆé˜²æ­¢è¨˜æ†¶é«”æ´©æ¼ï¼‰
const MAX_VISUAL_EFFECTS = {
  floatingTexts: 20,
  attackLines: 10,
  explosions: 10
};

// å®šæœŸæ¸…ç†è¨˜æ†¶é«”ï¼ˆæ¯30ç§’åŸ·è¡Œä¸€æ¬¡ï¼‰
let lastCleanupTime = 0;
function periodicCleanup() {
  const now = Date.now();
  if (now - lastCleanupTime < 30000) return;
  lastCleanupTime = now;

  // æ¸…ç†éæœŸçš„ç‰¹æ•ˆ
  clearAllVisualEffects();

  // å¼·åˆ¶åƒåœ¾å›æ”¶æç¤ºï¼ˆç€è¦½å™¨å¯èƒ½ä¸æœƒç«‹å³åŸ·è¡Œï¼‰
  if (window.gc) window.gc();
}

// æ¸…ç†éé‡çš„è¦–è¦ºç‰¹æ•ˆ
function trimVisualEffects() {
  if (visualEffects.floatingTexts.length > MAX_VISUAL_EFFECTS.floatingTexts) {
    visualEffects.floatingTexts = visualEffects.floatingTexts.slice(-MAX_VISUAL_EFFECTS.floatingTexts);
  }
  if (visualEffects.attackLines.length > MAX_VISUAL_EFFECTS.attackLines) {
    visualEffects.attackLines = visualEffects.attackLines.slice(-MAX_VISUAL_EFFECTS.attackLines);
  }
  if (visualEffects.explosions.length > MAX_VISUAL_EFFECTS.explosions) {
    visualEffects.explosions = visualEffects.explosions.slice(-MAX_VISUAL_EFFECTS.explosions);
  }
}

// å®Œå…¨æ¸…é™¤æ‰€æœ‰è¦–è¦ºç‰¹æ•ˆ
function clearAllVisualEffects() {
  visualEffects.floatingTexts = [];
  visualEffects.attackLines = [];
  visualEffects.explosions = [];
}

// éš±è—éª°å­ä»‹é¢
function hideDiceOverlay() {
  // å¦‚æœéª°å­æ­£åœ¨é€²è¡Œä¸­ï¼Œä¸è¦é—œé–‰
  if (diceRollInProgress) return;

  const overlay = document.getElementById("diceOverlay");
  if (overlay) {
    overlay.classList.remove("active");
    const container = document.getElementById("diceContainer");
    const resultEl = document.getElementById("diceResult");
    if (container) container.innerHTML = "";
    if (resultEl) resultEl.innerHTML = "";
  }
}

// æ¸…é™¤æ‰€æœ‰UIç‰¹æ•ˆï¼ˆéšæ®µåˆ‡æ›æ™‚èª¿ç”¨ï¼‰
function clearAllUIEffects() {
  clearAllVisualEffects();
  hideDiceOverlay();

  // é—œé–‰æˆ°ç•¥å½ˆçª—ï¼ˆå¦‚æœé–‹è‘—ï¼‰
  const stratagemPopup = document.getElementById("stratagemPopup");
  if (stratagemPopup && stratagemPopup.style.display !== "none") {
    stratagemPopup.style.display = "none";
    if (stratagemPopupCallback) {
      stratagemPopupCallback();
      stratagemPopupCallback = null;
    }
  }
}

// åœ¨å–®ä½é ­ä¸Šé¡¯ç¤ºæµ®å‹•æ–‡å­—
function showFloatingText(x, y, text, options = {}, sync = true) {
  const effect = {
    x: x,
    y: y - 40,
    text: text,
    color: options.color || "#fbbf24",
    fontSize: options.fontSize || 14,
    outline: options.outline || "#000",
    startTime: performance.now(),
    duration: options.duration || 800, // ç¸®çŸ­é¡¯ç¤ºæ™‚é–“
    offsetY: 0,
    opacity: 1,
    scale: options.scale || 1,
    type: options.type || "skill"
  };
  visualEffects.floatingTexts.push(effect);

  // ç·šä¸ŠåŒæ­¥è¦–è¦ºæ•ˆæœ
  if (sync && isOnlineMode && roomRef && isMyTurn()) {
    syncVisualEffect({ type: 'floatingText', x, y, text, options });
  }
}

// é¡¯ç¤ºå‚·å®³æ•¸å­—ï¼ˆç‰¹æ®Šæ¨£å¼ï¼‰
function showDamageNumber(x, y, damage, isCrit = false, sync = true) {
  const effect = {
    x: x + (Math.random() - 0.5) * 20,
    y: y - 30,
    text: `-${damage}`,
    color: isCrit ? "#ff0000" : "#ef4444",
    fontSize: isCrit ? 24 : 18,
    outline: "#000",
    startTime: performance.now(),
    duration: 600, // ç¸®çŸ­é¡¯ç¤ºæ™‚é–“
    offsetY: 0,
    opacity: 1,
    scale: isCrit ? 1.3 : 1,
    type: "damage",
    bounce: true
  };
  visualEffects.floatingTexts.push(effect);

  // ç·šä¸ŠåŒæ­¥å‚·å®³æ•¸å­—
  if (sync && isOnlineMode && roomRef && isMyTurn()) {
    syncVisualEffect({ type: 'damageNumber', x, y, damage, isCrit });
  }
}

// é¡¯ç¤ºæ”»æ“Šç·š/å°„ç·š
function showAttackLine(fromX, fromY, toX, toY, options = {}) {
  const effect = {
    fromX: fromX,
    fromY: fromY,
    toX: toX,
    toY: toY,
    color: options.color || "#ffaa00",
    width: options.width || 3,
    startTime: performance.now(),
    duration: options.duration || 400,
    progress: 0,
    type: options.type || "beam" // "beam", "bullet", "melee"
  };

  visualEffects.attackLines.push(effect);
}

// é¡¯ç¤ºçˆ†ç‚¸/å‘½ä¸­æ•ˆæœï¼ˆç°¡åŒ–ç‰ˆï¼‰
function showExplosion(x, y, options = {}) {
  const effect = {
    x: x,
    y: y,
    radius: options.radius || 20,
    color: options.color || "#ff6600",
    startTime: performance.now(),
    duration: options.duration || 250
  };

  visualEffects.explosions.push(effect);
}

// æ›´æ–°ä¸¦æ¸²æŸ“æ‰€æœ‰è¦–è¦ºç‰¹æ•ˆ
function renderVisualEffects() {
  const now = performance.now();

  // æ¸…ç†éé‡ç‰¹æ•ˆ
  trimVisualEffects();

  // æ¸²æŸ“æ”»æ“Šå°„ç·š
  visualEffects.attackLines = visualEffects.attackLines.filter(line => {
    const elapsed = now - line.startTime;
    if (elapsed >= line.duration) return false;

    const progress = elapsed / line.duration;
    const easeProgress = 1 - Math.pow(1 - progress, 3); // easeOutCubic

    ctx.save();

    if (line.type === "beam") {
      // å…‰æŸæ•ˆæœï¼ˆç°¡åŒ–ç‰ˆï¼Œç§»é™¤æ¼¸å±¤å’Œé™°å½±ä»¥æå‡æ€§èƒ½ï¼‰
      const currentX = line.fromX + (line.toX - line.fromX) * easeProgress;
      const currentY = line.fromY + (line.toY - line.fromY) * easeProgress;

      // ä¸»å°„ç·š
      ctx.beginPath();
      ctx.moveTo(line.fromX, line.fromY);
      ctx.lineTo(currentX, currentY);
      ctx.strokeStyle = line.color;
      ctx.lineWidth = line.width;
      ctx.lineCap = "round";
      ctx.stroke();

      // ç°¡åŒ–çš„ç™¼å…‰æ•ˆæœï¼ˆç”¨è¼ƒç²—çš„åŠé€æ˜ç·šä»£æ›¿é™°å½±ï¼‰
      ctx.beginPath();
      ctx.moveTo(line.fromX, line.fromY);
      ctx.lineTo(currentX, currentY);
      ctx.strokeStyle = `rgba(255, 200, 100, ${0.3 * (1 - progress)})`;
      ctx.lineWidth = line.width * 2;
      ctx.stroke();

    } else if (line.type === "melee") {
      // è¿‘æˆ°æ–¬æ“Šæ•ˆæœï¼ˆç°¡åŒ–ç‰ˆï¼‰
      ctx.beginPath();
      ctx.moveTo(line.fromX, line.fromY);
      ctx.lineTo(line.toX, line.toY);
      ctx.strokeStyle = `rgba(255, 100, 100, ${1 - progress})`;
      ctx.lineWidth = 3;
      ctx.lineCap = "round";
      ctx.stroke();
    }

    ctx.restore();
    return true;
  });

  // æ¸²æŸ“çˆ†ç‚¸æ•ˆæœï¼ˆç°¡åŒ–ç‰ˆï¼‰
  visualEffects.explosions = visualEffects.explosions.filter(exp => {
    const elapsed = now - exp.startTime;
    if (elapsed >= exp.duration) return false;

    const progress = elapsed / exp.duration;
    const alpha = 1 - progress;
    const currentRadius = exp.radius * (0.5 + progress * 0.5);

    // å–®åœˆæ“´æ•£æ•ˆæœ
    ctx.beginPath();
    ctx.arc(exp.x, exp.y, currentRadius, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 150, 50, ${alpha})`;
    ctx.lineWidth = 3 * (1 - progress);
    ctx.stroke();

    // ä¸­å¿ƒé–ƒå…‰
    if (progress < 0.3) {
      ctx.beginPath();
      ctx.arc(exp.x, exp.y, exp.radius * 0.2 * (1 - progress * 3), 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 200, ${1 - progress * 3})`;
      ctx.fill();
    }

    return true;
  });

  // æ¸²æŸ“æµ®å‹•æ–‡å­—
  visualEffects.floatingTexts = visualEffects.floatingTexts.filter(ft => {
    const elapsed = now - ft.startTime;
    if (elapsed >= ft.duration) return false;

    const progress = elapsed / ft.duration;

    // è¨ˆç®—å‹•ç•«
    if (ft.type === "damage") {
      // å‚·å®³æ•¸å­—ï¼šå‘ä¸Šè·³å‹•ç„¶å¾Œä¸‹è½
      if (ft.bounce) {
        const bounceProgress = Math.min(1, progress * 3);
        ft.offsetY = -40 * Math.sin(bounceProgress * Math.PI);
      } else {
        ft.offsetY = -30 * progress;
      }
      ft.opacity = progress < 0.7 ? 1 : 1 - (progress - 0.7) / 0.3;
      ft.scale = 1 + Math.sin(progress * Math.PI) * 0.3;
    } else {
      // æŠ€èƒ½æ–‡å­—ï¼šç·©æ…¢ä¸Šå‡ä¸¦æ·¡å‡º
      ft.offsetY = -50 * progress;
      ft.opacity = progress < 0.6 ? 1 : 1 - (progress - 0.6) / 0.4;
      ft.scale = 1 + (1 - progress) * 0.2;
    }

    ctx.save();
    ctx.globalAlpha = ft.opacity;
    ctx.font = `bold ${ft.fontSize * ft.scale}px "Microsoft JhengHei", sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    const drawX = ft.x;
    const drawY = ft.y + ft.offsetY;

    // æé‚Š
    ctx.strokeStyle = ft.outline;
    ctx.lineWidth = 3;
    ctx.strokeText(ft.text, drawX, drawY);

    // å¡«å……
    ctx.fillStyle = ft.color;
    ctx.fillText(ft.text, drawX, drawY);

    ctx.restore();
    return true;
  });
}

// ========== éª°å­è¦–è¦ºåŒ–ç³»çµ± ==========
let diceAnimationQueue = [];
let isDiceAnimating = false;
let diceRollInProgress = false;  // é˜²æ­¢éª°å­è¦–çª—è¢«æå‰é—œé–‰

async function showDiceRoll(title, rolls, targetNumber, options = {}) {
  const overlay = document.getElementById("diceOverlay");
  const titleEl = document.getElementById("diceTitle");
  const container = document.getElementById("diceContainer");
  const resultEl = document.getElementById("diceResult");
  const rollBtn = document.getElementById("diceRollBtn");

  titleEl.textContent = title;
  container.innerHTML = "";
  resultEl.innerHTML = `<span style="color: var(--muted);">é»æ“Šã€Œæ“²éª°ã€é–‹å§‹</span>`;

  // å‰µå»ºéª°å­å…ƒç´ ï¼ˆé¡¯ç¤º?ï¼‰
  rolls.forEach((_, i) => {
    const die = document.createElement("div");
    die.className = "dice";
    die.id = `die-${i}`;
    die.textContent = "?";
    die.style.opacity = "0.5";
    container.appendChild(die);
  });

  overlay.classList.add("active");
  diceRollInProgress = true;  // æ¨™è¨˜éª°å­é€²è¡Œä¸­

  // åˆ¤æ–·æ˜¯å¦éœ€è¦ç©å®¶äº’å‹•
  // options.rollingPlayer: æŒ‡å®šèª°æ“²éª°ï¼ˆ1æˆ–2ï¼‰ï¼Œç”¨æ–¼è±å…éª°è®“é˜²å®ˆæ–¹æ“²
  let rollingPlayer = options.rollingPlayer || gameState.currentPlayer;
  const isRollerAI = (rollingPlayer === 1 && ai1Enabled) || (rollingPlayer === 2 && ai2Enabled);

  // ç·šä¸Šæ¨¡å¼ï¼šåªæœ‰æ“²éª°çš„ç©å®¶æ‰éœ€è¦é»æ“ŠæŒ‰éˆ•
  const isOnlineRoller = isOnlineMode && onlinePlayerId === rollingPlayer;
  const needsInteraction = !isRollerAI && !options.autoRoll && (!isOnlineMode || isOnlineRoller);

  if (needsInteraction) {
    // ç©å®¶æ¨¡å¼ï¼šé¡¯ç¤ºæ“²éª°æŒ‰éˆ•ï¼Œç­‰å¾…é»æ“Š
    rollBtn.style.display = "inline-block";
    rollBtn.textContent = options.rollingPlayer ? `ğŸ² ${rollingPlayer === 1 ? "ç©å®¶ä¸€" : "ç©å®¶äºŒ"}æ“²éª°` : "ğŸ² æ“²éª°";

    await new Promise(resolve => {
      rollBtn.onclick = () => {
        rollBtn.style.display = "none";
        resolve();
      };
    });
  }

  // é–‹å§‹æ“²éª°å‹•ç•«
  rolls.forEach((_, i) => {
    const die = document.getElementById(`die-${i}`);
    die.className = "dice rolling";
    die.style.opacity = "1";
  });

  // éŸ³æ•ˆï¼šéª°å­
  playSound('dice');

  // éª°å­å‹•ç•«
  await delay(300);

  let successCount = 0;
  let critCount = 0;

  for (let i = 0; i < rolls.length; i++) {
    const die = document.getElementById(`die-${i}`);
    die.classList.remove("rolling");
    die.textContent = rolls[i];

    if (rolls[i] >= targetNumber) {
      successCount++;
      if (rolls[i] === 6) {
        die.className = "dice critical";
        critCount++;
      } else {
        die.className = "dice success";
      }
    } else {
      die.className = "dice fail";
    }

    await delay(50);
  }

  // é¡¯ç¤ºçµæœ
  const failCount = rolls.length - successCount;
  resultEl.innerHTML = `éœ€è¦ ${targetNumber}+ | <span class="success-count">${successCount} æˆåŠŸ</span>${critCount > 0 ? ` (${critCount}æš´æ“Š)` : ""} / <span class="fail-count">${failCount} å¤±æ•—</span>`;

  // ç·šä¸Šæ¨¡å¼åŒæ­¥éª°å­çµæœ
  if (isOnlineMode && roomRef && isMyTurn()) {
    const diceResults = rolls.map((r, i) => ({
      value: r,
      success: r >= targetNumber
    }));
    syncDiceRoll(title, diceResults, successCount, failCount);
  }

  // ç­‰å¾…å¾Œè‡ªå‹•é—œé–‰ï¼ˆå¢åŠ é¡¯ç¤ºæ™‚é–“è®“ç©å®¶çœ‹æ¸…æ¥šï¼‰
  await delay(options.duration || 2000);
  diceRollInProgress = false;  // æ¨™è¨˜éª°å­å®Œæˆ
  overlay.classList.remove("active");
  rollBtn.style.display = "none";
  rollBtn.textContent = "ğŸ² æ“²éª°";  // é‡ç½®æŒ‰éˆ•æ–‡å­—

  return { successes: successCount, criticals: critCount, rolls };
}

async function showChargeRoll(roll1, roll2, needed) {
  const overlay = document.getElementById("diceOverlay");
  const titleEl = document.getElementById("diceTitle");
  const container = document.getElementById("diceContainer");
  const resultEl = document.getElementById("diceResult");
  const rollBtn = document.getElementById("diceRollBtn");

  titleEl.textContent = "è¡é‹’æ“²éª° 2D6";
  container.innerHTML = "";
  resultEl.innerHTML = `<span style="color: var(--muted);">éœ€è¦ ${needed.toFixed(1)}" - é»æ“Šã€Œæ“²éª°ã€é–‹å§‹</span>`;

  const die1 = document.createElement("div");
  die1.className = "dice";
  die1.textContent = "?";
  die1.style.opacity = "0.5";
  container.appendChild(die1);

  const die2 = document.createElement("div");
  die2.className = "dice";
  die2.textContent = "?";
  die2.style.opacity = "0.5";
  container.appendChild(die2);

  overlay.classList.add("active");

  // åˆ¤æ–·æ˜¯å¦éœ€è¦ç©å®¶äº’å‹•
  const isAI = (gameState.currentPlayer === 1 && ai1Enabled) || (gameState.currentPlayer === 2 && ai2Enabled);

  if (!isAI) {
    // ç©å®¶æ¨¡å¼ï¼šç­‰å¾…é»æ“Šæ“²éª°
    rollBtn.style.display = "inline-block";
    await new Promise(resolve => {
      rollBtn.onclick = () => {
        rollBtn.style.display = "none";
        resolve();
      };
    });
  }

  // é–‹å§‹æ“²éª°å‹•ç•«
  die1.className = "dice rolling";
  die1.style.opacity = "1";
  die2.className = "dice rolling";
  die2.style.opacity = "1";

  playSound('dice');

  await delay(400);

  die1.classList.remove("rolling");
  die1.textContent = roll1;
  die1.className = "dice success";

  await delay(200);

  die2.classList.remove("rolling");
  die2.textContent = roll2;
  die2.className = "dice success";

  const total = roll1 + roll2;
  const success = total >= needed;

  resultEl.innerHTML = `${roll1} + ${roll2} = <b>${total}"</b> (éœ€è¦ ${needed.toFixed(1)}") â†’ <span class="${success ? 'success-count' : 'fail-count'}">${success ? 'æˆåŠŸ!' : 'å¤±æ•—'}</span>`;

  // ç·šä¸Šæ¨¡å¼åŒæ­¥è¡é‹’éª°
  if (isOnlineMode && roomRef && isMyTurn()) {
    syncDiceRoll(`è¡é‹’æ“²éª° 2D6 (éœ€${needed.toFixed(1)}")`, [
      { value: roll1, success: true },
      { value: roll2, success: true }
    ], success ? 1 : 0, success ? 0 : 1);
  }

  await delay(1000);
  overlay.classList.remove("active");
  rollBtn.style.display = "none";

  return success;
}

// ========== AI ç³»çµ± ==========
let ai1Difficulty = "normal";  // ç©å®¶ä¸€AIé›£åº¦

function toggleAI1Mode() {
  ai1Enabled = document.getElementById("ai1ModeToggle")?.checked ?? false;
  document.getElementById("p1ModeLabel").textContent = ai1Enabled ? "AI-1" : "ç©å®¶ä¸€";

  // é¡¯ç¤º/éš±è—é›£åº¦é¸æ“‡
  const diffWrapper = document.getElementById("ai1DifficultyWrapper");
  if (diffWrapper) {
    diffWrapper.style.display = ai1Enabled ? "block" : "none";
  }

  checkAutoBattle();
}

function toggleAIMode() {
  ai2Enabled = document.getElementById("aiModeToggle")?.checked ?? true;
  document.getElementById("p2ModeLabel").textContent = ai2Enabled ? "AIå°æ‰‹" : "ç©å®¶äºŒ";
  checkAutoBattle();
}

// ç²å–ç•¶å‰ç©å®¶çš„AIé›£åº¦
function getAIDifficulty() {
  if (gameState.currentPlayer === 1) {
    return document.getElementById("ai1Difficulty")?.value || ai1Difficulty;
  } else {
    return document.getElementById("aiDifficulty")?.value || aiDifficulty;
  }
}

function checkAutoBattle() {
  const autoBattleHint = document.getElementById("autoBattleHint");
  if (ai1Enabled && ai2Enabled) {
    if (!autoBattleHint) {
      const hint = document.createElement("div");
      hint.id = "autoBattleHint";
      hint.style.cssText = "text-align: center; margin-top: 10px; padding: 10px; background: linear-gradient(135deg, var(--blue), var(--red)); border-radius: 8px; color: #fff; font-weight: bold;";
      hint.innerHTML = "ğŸ¤– VS ğŸ¤– AIè‡ªå‹•å°æˆ°æ¨¡å¼";
      document.querySelector(".setup-actions")?.prepend(hint);
    }
  } else {
    document.getElementById("autoBattleHint")?.remove();
  }
}

// AIä¸»æ§åˆ¶å‡½æ•¸
async function runAITurn() {
  const isAI = (gameState.currentPlayer === 1 && ai1Enabled) || (gameState.currentPlayer === 2 && ai2Enabled);
  if (!isAI) return;

  console.warn('[runAITurn] é–‹å§‹ AI å›åˆ:', { currentPlayer: gameState.currentPlayer, isOnlineMode });

  // æ¸…é™¤ä¹‹å‰çš„ç‰¹æ•ˆ
  clearAllVisualEffects();
  hideDiceOverlay();

  const aiPlayer = gameState.currentPlayer;
  aiDifficulty = getAIDifficulty();
  log(`ğŸ¤– AI-${aiPlayer} æ­£åœ¨æ€è€ƒ... (é›£åº¦: ${aiDifficulty})`, "info");

  await delay(500);

  // ä¾ç…§éšæ®µåŸ·è¡ŒAIè¡Œå‹•
  const phases = ["command", "movement", "shooting", "charge", "fight"];

  for (const phase of phases) {
    try {
      if (gameState.phase !== phase) {
        gameState.phase = phase;
        updatePhaseDisplay();
        log(`ğŸ¤– AIé€²å…¥ã€${getPhaseNameChinese(phase)}ã€‘`, "phase");

        // ç·šä¸Šæ¨¡å¼ï¼šåŒæ­¥éšæ®µè®Šæ›´
        if (isOnlineMode) {
          syncGameStateToFirebase();
        }

        await delay(300);
      }

      switch (phase) {
        case "command":
          await aiCommandPhase();
          break;
        case "movement":
          await aiMovementPhase();
          break;
        case "shooting":
          await aiShootingPhase();
          break;
        case "charge":
          await aiChargePhase();
          break;
        case "fight":
          await aiFightPhase();
          break;
      }

      // ç·šä¸Šæ¨¡å¼ï¼šæ¯å€‹éšæ®µçµæŸå¾ŒåŒæ­¥ç‹€æ…‹
      if (isOnlineMode) {
        syncGameStateToFirebase();
        render();
      }

      await delay(200);
    } catch (error) {
      console.error(`AI ${phase} phase error:`, error);
      log(`âš ï¸ AI ${phase} éšæ®µç™¼ç”ŸéŒ¯èª¤ï¼Œè·³é`, "miss");
    }
  }

  log("ğŸ¤– AIå›åˆçµæŸ", "info");
  console.warn('[runAITurn] AI å›åˆçµæŸ');
  await delay(500);
  endTurn();
}

// AIæŒ‡æ®éšæ®µï¼šè™•ç†æ‰€æœ‰æŒ‡æ®éšæ®µé‚è¼¯
async function aiCommandPhase() {
  const aiPlayer = gameState.currentPlayer;

  // æŒ‡æ®éšæ®µé–‹å§‹ï¼Œé›™æ–¹å„+1 CP
  gainCPAtCommandStart();

  // æ‡‰ç”¨å›åˆé–‹å§‹çš„å†ç”Ÿèƒ½åŠ›ï¼ˆæ´»é‡‘å±¬ç­‰ï¼‰
  applyRegenerationAbilities();

  // è¨ˆç®—ç›®æ¨™æ§åˆ¶å’ŒVP
  computeObjectiveControl();
  const gain = scorePrimary(aiPlayer);
  const prevVP = gameState.vp[aiPlayer];
  gameState.vp[aiPlayer] += gain;
  updateVPDisplay();

  const controlCount = gameState.objectives.filter(o => o.control === aiPlayer).length;
  if (gain > 0) {
    log(`ğŸ† AI-${aiPlayer}æ§åˆ¶ ${controlCount} å€‹ç›®æ¨™ â†’ +${gain} VP (ç¸½è¨ˆ: ${prevVP} â†’ ${gameState.vp[aiPlayer]})`, "phase");
  } else {
    log(`âš ï¸ AI-${aiPlayer}æœªæ§åˆ¶ä»»ä½•ç›®æ¨™ï¼Œæœ¬å›åˆ+0 VP`, "info");
  }

  // æˆ°æ…„æ¸¬è©¦
  const currentUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive);
  for (const unit of currentUnits) {
    if (unit.currentHP <= unit.maxHP / 2) {
      const roll = rollD6() + rollD6();
      if (roll >= unit.stats.Ld) {
        unit.battleShocked = false;
      } else {
        unit.battleShocked = true;
        log(`${unit.name} æˆ°æ…„ï¼OCè®Šç‚º0`, "miss");
      }
    }
  }

  // ä½¿ç”¨æ–°çš„æ™ºæ…§æˆ°ç•¥ç³»çµ±
  await aiConsiderStratagem("command", {});

  updateCPDisplay();
}

// ========== AI æ™ºæ…§æˆ°ç•¥ä½¿ç”¨ç³»çµ± ==========
// ç²å–ç•¶å‰ç©å®¶å¯ç”¨çš„æˆ°ç•¥åˆ—è¡¨
function getAvailableStratagems(player) {
  const faction = armyRosters[player]?.[0]?.faction;
  const detachment = playerDetachments[player]?.detachmentId;

  if (!faction || !detachment || !DETACHMENT_RULES[faction]?.[detachment]) {
    return [];
  }

  return DETACHMENT_RULES[faction][detachment].stratagems || [];
}

// AI è©•ä¼°ä¸¦ä½¿ç”¨æˆ°ç•¥ï¼ˆå„éšæ®µé€šç”¨ï¼‰
async function aiConsiderStratagem(phase, context = {}) {
  const aiPlayer = gameState.currentPlayer;
  const currentCP = gameState.cp[aiPlayer];

  // ç°¡å–®é›£åº¦ï¼šåªæœ‰ 20% æ©Ÿç‡è€ƒæ…®ä½¿ç”¨æˆ°ç•¥
  // æ™®é€šé›£åº¦ï¼š50% æ©Ÿç‡
  // å›°é›£é›£åº¦ï¼š80% æ©Ÿç‡
  const useChance = aiDifficulty === "easy" ? 0.2 : (aiDifficulty === "hard" ? 0.8 : 0.5);
  if (Math.random() > useChance) return null;

  if (currentCP < 1) return null;

  const stratagems = getAvailableStratagems(aiPlayer);
  if (stratagems.length === 0) return null;

  const gameEval = evaluateGameState(aiPlayer);
  const myUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive);
  const enemyUnits = gameState.units.filter(u => u.player !== aiPlayer && u.alive);

  // æ ¹æ“šéšæ®µå’Œæƒ…æ³è©•ä¼°æ¯å€‹æˆ°ç•¥çš„åƒ¹å€¼
  let bestStratagem = null;
  let bestScore = 0;

  for (const strat of stratagems) {
    if (strat.cp > currentCP) continue;

    let score = 0;
    const desc = strat.desc.toLowerCase();

    // === æŒ‡æ®éšæ®µæˆ°ç•¥ ===
    if (phase === "command") {
      // å¾©æ´»/æ¢å¾©é¡æˆ°ç•¥
      if (desc.includes("å¾©æ´»") || desc.includes("æ¢å¾©") || desc.includes("å›å¾©")) {
        const lowHPUnits = myUnits.filter(u => u.currentHP < u.maxHP * 0.5);
        const deadCharacters = gameState.units.filter(u => u.player === aiPlayer && !u.alive && u.keywords?.includes("Character"));
        if (lowHPUnits.length > 0) score = 60 + lowHPUnits.length * 10;
        if (deadCharacters.length > 0 && desc.includes("è§’è‰²")) score = 80;
      }
    }

    // === ç§»å‹•éšæ®µæˆ°ç•¥ ===
    if (phase === "movement") {
      // ç§»å‹•å¢å¼·é¡
      if (desc.includes("ç§»å‹•") || desc.includes("æ¨é€²") || desc.includes("è¡åˆº")) {
        // å¦‚æœéœ€è¦æ¶ç›®æ¨™ï¼Œç§»å‹•å¢å¼·å¾ˆæœ‰åƒ¹å€¼
        if (gameEval.strategy === "objective_rush") score = 70;
        else score = 40;
      }
      // æ·±å…¥æ‰“æ“Š/å‚³é€é¡
      if (desc.includes("éƒ¨ç½²") || desc.includes("å‚³é€") || desc.includes("ä½ç§»")) {
        score = 50;
      }
    }

    // === å°„æ“Šéšæ®µæˆ°ç•¥ ===
    if (phase === "shooting") {
      const attacker = context.attacker;
      const target = context.target;

      // å‘½ä¸­/è‡´å‚·åŠ æˆ
      if (desc.includes("+1") || desc.includes("å‘½ä¸­") || desc.includes("è‡´å‚·")) {
        score = 50;
        // å¦‚æœç›®æ¨™æ˜¯é‡è¦å–®ä½ï¼Œæ›´å€¼å¾—ä½¿ç”¨
        if (target?.keywords?.includes("Character")) score += 20;
        if (target?.currentHP > 6) score += 15;
      }
      // é‡æ“²é¡
      if (desc.includes("é‡æ“²") || desc.includes("reroll")) {
        score = 45;
      }
      // æ¯€æ»…æ€§å‚·å£
      if (desc.includes("æ¯€æ»…æ€§") || desc.includes("è‡´å‘½å‚·")) {
        score = 65;
        if (target?.stats?.Sv <= 3) score += 20; // å°é«˜è­·ç”²æ›´æœ‰æ•ˆ
      }
      // ç„¡è¦–æ©è­·
      if (desc.includes("ç„¡è¦–æ©è­·") || desc.includes("æ©è­·")) {
        if (target?.inCover) score = 60;
        else score = 20;
      }
      // å‚·å®³åŠ æˆ
      if (desc.includes("å‚·å®³+") || desc.includes("damage")) {
        score = 55;
      }
      // é›†ä¸­ç«åŠ›ï¼ˆå¤šå–®ä½å°„æ“ŠåŒç›®æ¨™ï¼‰
      if (desc.includes("é›†ä¸­ç«åŠ›")) {
        score = 50;
      }
    }

    // === è¡é‹’éšæ®µæˆ°ç•¥ ===
    if (phase === "charge") {
      const charger = context.charger;
      const target = context.target;

      // è¡é‹’åŠ æˆ
      if (desc.includes("è¡é‹’") || desc.includes("charge")) {
        score = 55;
        // æ·±å…¥æ‰“æ“Šå¾Œè¡é‹’ç‰¹åˆ¥æœ‰åƒ¹å€¼
        if (desc.includes("æ·±å…¥") || desc.includes("æ‰“æ“Šå¾Œ")) score = 70;
      }
      // é‡æ“²è¡é‹’éª°
      if (desc.includes("é‡æ“²")) {
        score = 50;
      }
    }

    // === æˆ°é¬¥éšæ®µæˆ°ç•¥ ===
    if (phase === "fight") {
      const attacker = context.attacker;
      const target = context.target;

      // è¿‘æˆ°åŠ æˆ
      if (desc.includes("è¿‘æˆ°") || desc.includes("æ”»æ“Š") || desc.includes("fight")) {
        score = 50;
      }
      // S+1/åŠ›é‡åŠ æˆ
      if (desc.includes("s+") || desc.includes("åŠ›é‡")) {
        score = 55;
        if (target && attacker && attacker.weapons?.melee?.S <= target.stats?.T) score += 20;
      }
      // é¡å¤–æ”»æ“Š
      if (desc.includes("é¡å¤–æ”»æ“Š") || desc.includes("æ”»æ“Šæ¬¡æ•¸")) {
        score = 60;
      }
      // è‡´å‘½æ‰“æ“Š
      if (desc.includes("è‡´å‘½æ‰“æ“Š") || desc.includes("lethal")) {
        score = 55;
      }
    }

    // === é˜²ç¦¦æ€§æˆ°ç•¥ï¼ˆä»»ä½•éšæ®µéƒ½å¯èƒ½æœ‰ç”¨ï¼‰===
    if (desc.includes("å‘½ä¸­-1") || desc.includes("æ•µæ–¹å‘½ä¸­")) {
      // å¦‚æœæœ‰é‡è¦å–®ä½å¯èƒ½è¢«æ”»æ“Š
      const valuableUnits = myUnits.filter(u => u.keywords?.includes("Character") || u.currentHP > 8);
      if (valuableUnits.length > 0) score = Math.max(score, 45);
    }
    if (desc.includes("ç„¡æ‡¼æ­»äº¡") || desc.includes("fnp") || desc.includes("6+")) {
      const lowHPUnits = myUnits.filter(u => u.currentHP < u.maxHP * 0.6);
      if (lowHPUnits.length > 0) score = Math.max(score, 50);
    }

    // === æ ¹æ“šå±€å‹¢èª¿æ•´ ===
    // è½å¾Œæ™‚æ›´ç©æ¥µä½¿ç”¨é€²æ”»æˆ°ç•¥
    if (gameEval.vpDiff < -5) {
      if (desc.includes("å‚·å®³") || desc.includes("æ”»æ“Š") || desc.includes("+1")) {
        score += 15;
      }
    }
    // é ˜å…ˆæ™‚æ›´æ³¨é‡é˜²ç¦¦æˆ°ç•¥
    if (gameEval.vpDiff > 5) {
      if (desc.includes("é˜²è­·") || desc.includes("-1") || desc.includes("æ¢å¾©")) {
        score += 15;
      }
    }

    // CPæ•ˆç‡ï¼šä¾¿å®œçš„æˆ°ç•¥ç¨å¾®åŠ åˆ†
    if (strat.cp === 1) score += 5;

    // å›°é›£æ¨¡å¼ï¼šæ›´ç²¾ç¢ºçš„è©•ä¼°
    if (aiDifficulty === "hard") {
      score *= 1.2;
    }

    if (score > bestScore) {
      bestScore = score;
      bestStratagem = strat;
    }
  }

  // æ±ºå®šæ˜¯å¦ä½¿ç”¨ï¼ˆåˆ†æ•¸éœ€è¦å¤ é«˜ï¼‰
  const threshold = aiDifficulty === "easy" ? 60 : (aiDifficulty === "hard" ? 35 : 45);

  if (bestStratagem && bestScore >= threshold) {
    if (spendCP(aiPlayer, bestStratagem.cp)) {
      playSound('click');
      log(`ğŸ´ AIä½¿ç”¨ã€${bestStratagem.name}ã€‘(${bestStratagem.cp}CP)`, "phase");
      log(`   â†’ ${bestStratagem.desc}`, "info");

      // åœ¨æˆ°å ´ä¸­å¤®é¡¯ç¤ºæˆ°ç•¥åç¨±
      const centerX = (gameState.canvasWidth || 600) / 2;
      const centerY = (gameState.canvasHeight || 440) / 2;
      showFloatingText(centerX, centerY, bestStratagem.name, {
        color: "#fbbf24",
        fontSize: 18,
        duration: 1500
      });

      updateCPDisplay();
      await delay(500);

      // è¿”å›æˆ°ç•¥è³‡è¨Šä¾›èª¿ç”¨è€…æ‡‰ç”¨æ•ˆæœ
      return bestStratagem;
    }
  }

  return null;
}

// æ‡‰ç”¨æˆ°ç•¥æ•ˆæœåˆ°æ”»æ“Š
function applyStratagemEffect(stratagem, attacker, target, attackContext) {
  if (!stratagem) return {};

  const desc = stratagem.desc.toLowerCase();
  const effects = {};

  // å‘½ä¸­åŠ æˆ
  if (desc.includes("å‘½ä¸­+1") || desc.includes("+1") && desc.includes("å‘½ä¸­")) {
    effects.hitBonus = 1;
  }
  // è‡´å‚·åŠ æˆ
  if (desc.includes("è‡´å‚·+1") || desc.includes("+1") && desc.includes("è‡´å‚·")) {
    effects.woundBonus = 1;
  }
  // é‡æ“²å‘½ä¸­
  if (desc.includes("é‡æ“²å‘½ä¸­") || desc.includes("å…¨é‡æ“²")) {
    effects.rerollHits = true;
  }
  // é‡æ“²è‡´å‚·
  if (desc.includes("é‡æ“²è‡´å‚·") || desc.includes("é‡æ“²æ‰€æœ‰è‡´å‚·")) {
    effects.rerollWounds = true;
  }
  // æ¯€æ»…æ€§å‚·å£
  if (desc.includes("æ¯€æ»…æ€§å‚·å£") || desc.includes("devastating")) {
    effects.devastatingWounds = true;
  }
  // è‡´å‘½æ‰“æ“Š
  if (desc.includes("è‡´å‘½æ‰“æ“Š") || desc.includes("lethal")) {
    effects.lethalHits = true;
  }
  // ç„¡è¦–æ©è­·
  if (desc.includes("ç„¡è¦–æ©è­·")) {
    effects.ignoreCover = true;
  }
  // å‚·å®³åŠ æˆ
  if (desc.includes("å‚·å®³+1")) {
    effects.damageBonus = 1;
  }
  // åŠ›é‡åŠ æˆ
  if (desc.includes("s+1") || desc.includes("åŠ›é‡+1")) {
    effects.strengthBonus = 1;
  }
  if (desc.includes("s+2") || desc.includes("åŠ›é‡+2")) {
    effects.strengthBonus = 2;
  }
  // APåŠ æˆ
  if (desc.includes("ap+1") || desc.includes("apæ”¹é€²")) {
    effects.apBonus = 1;
  }

  return effects;
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// AIç§»å‹•éšæ®µ
async function aiMovementPhase() {
  const aiPlayer = gameState.currentPlayer;
  const enemyPlayer = aiPlayer === 1 ? 2 : 1;
  const myUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive && !u.hasMoved);

  for (const unit of myUnits) {
    await delay(200);
    const target = aiSelectMoveTarget(unit);
    if (target) {
      const maxDist = inchToPixels(unit.stats.M);
      const dx = target.x - unit.x;
      const dy = target.y - unit.y;
      const dist = Math.hypot(dx, dy);

      if (dist > 0) {
        const moveDist = Math.min(dist, maxDist);
        const ratio = moveDist / dist;
        let newX = unit.x + dx * ratio;
        let newY = unit.y + dy * ratio;

        // æª¢æŸ¥ç¢°æ’ä¸¦èª¿æ•´ä½ç½®
        const baseSize = getUnitBaseSize(unit);
        const otherUnits = gameState.units.filter(u => u !== unit && u.alive);
        if (!isPositionValid(newX, newY, baseSize, otherUnits)) {
          // å˜—è©¦æ‰¾åˆ°ä¸é‡ç–Šçš„æ›¿ä»£ä½ç½®
          let found = false;
          for (let angle = 0; angle < Math.PI * 2 && !found; angle += Math.PI / 8) {
            for (let distRatio = 0.8; distRatio >= 0.2 && !found; distRatio -= 0.2) {
              const altX = unit.x + dx * ratio * distRatio + Math.cos(angle) * baseSize;
              const altY = unit.y + dy * ratio * distRatio + Math.sin(angle) * baseSize;
              if (isPositionValid(altX, altY, baseSize, otherUnits)) {
                newX = altX;
                newY = altY;
                found = true;
              }
            }
          }
          // å¦‚æœé‚„æ˜¯æ‰¾ä¸åˆ°ï¼Œå°±ä¸ç§»å‹•
          if (!found) {
            newX = unit.x;
            newY = unit.y;
          }
        }

        if (newX !== unit.x || newY !== unit.y) {
          unit.x = newX;
          unit.y = newY;
          checkCover(unit);
          log(`ğŸ¤– ${unit.name} ç§»å‹•`, "info");

          // ç·šä¸Šæ¨¡å¼ï¼šåŒæ­¥ç§»å‹•
          if (isOnlineMode) {
            sendAction({ type: 'move', unitId: unit.id, x: newX, y: newY });
          }
        }
      }
    }
    unit.hasMoved = true;
    updateUnitLists();
    render();
  }
}

// ========== AIæˆ°ç•¥è©•ä¼°ç³»çµ± ==========
// è©•ä¼°ç•¶å‰éŠæˆ²å±€å‹¢ï¼ˆVPã€æ§åˆ¶çš„ç›®æ¨™ã€å…µåŠ›å°æ¯”ï¼‰
function evaluateGameState(aiPlayer) {
  const enemyPlayer = aiPlayer === 1 ? 2 : 1;
  const myVP = gameState.vp[aiPlayer];
  const enemyVP = gameState.vp[enemyPlayer];
  const vpDiff = myVP - enemyVP;

  const myUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive);
  const enemyUnits = gameState.units.filter(u => u.player === enemyPlayer && u.alive);

  // è¨ˆç®—ç¸½OC
  const myTotalOC = myUnits.reduce((sum, u) => sum + u.stats.OC, 0);
  const enemyTotalOC = enemyUnits.reduce((sum, u) => sum + u.stats.OC, 0);

  // è¨ˆç®—æ§åˆ¶çš„ç›®æ¨™æ•¸
  const myObjectives = gameState.objectives.filter(o => o.control === aiPlayer).length;
  const enemyObjectives = gameState.objectives.filter(o => o.control === enemyPlayer).length;

  // è¨ˆç®—æˆ°é¬¥åŠ›ï¼ˆç°¡åŒ–ï¼šHPç¸½å’Œï¼‰
  const myPower = myUnits.reduce((sum, u) => sum + u.currentHP, 0);
  const enemyPower = enemyUnits.reduce((sum, u) => sum + u.currentHP, 0);

  // æ±ºå®šæˆ°ç•¥æ…‹å‹¢
  let strategy = "balanced";

  if (vpDiff >= 10 || (myObjectives >= 3 && vpDiff > 0)) {
    strategy = "defensive"; // é ˜å…ˆæ™‚é˜²å®ˆ
  } else if (vpDiff <= -10 || enemyObjectives >= 3) {
    strategy = "aggressive"; // è½å¾Œæ™‚é€²æ”»
  } else if (gameState.round >= 4) {
    strategy = "objective_rush"; // å¾ŒæœŸæ¶åˆ†
  }

  // å¦‚æœå…µåŠ›æ‡¸æ®Šï¼Œèª¿æ•´ç­–ç•¥
  if (myPower < enemyPower * 0.5) {
    strategy = "objective_rush"; // å…µåŠ›åŠ£å‹¢æ™‚å°ˆæ³¨æ¶åˆ†
  } else if (myPower > enemyPower * 1.5) {
    strategy = "aggressive"; // å…µåŠ›å„ªå‹¢æ™‚é€²æ”»
  }

  return {
    vpDiff,
    myVP,
    enemyVP,
    myObjectives,
    enemyObjectives,
    myTotalOC,
    enemyTotalOC,
    myPower,
    enemyPower,
    strategy,
    round: gameState.round,
    maxRounds: 5
  };
}

// è¨ˆç®—ç›®æ¨™çš„æˆ°ç•¥åƒ¹å€¼ï¼ˆè€ƒæ…®ç•¶å‰å±€å‹¢ï¼‰
function getObjectiveValue(obj, unit, gameEval, aiPlayer) {
  let value = 100; // åŸºç¤åƒ¹å€¼

  const dist = pixelsToInch(Math.hypot(unit.x - obj.x, unit.y - obj.y));
  const canReach = dist <= unit.stats.M + 3; // 3" æ˜¯ç›®æ¨™ç¯„åœ

  // è·é›¢æ‡²ç½°
  value -= dist * 3;

  // æ§åˆ¶ç‹€æ…‹åŠ æˆ
  if (obj.control === null) {
    value += 40; // ä¸­ç«‹ç›®æ¨™
  } else if (obj.control !== aiPlayer) {
    value += 60; // æ•µæ–¹ç›®æ¨™ï¼ˆæ¶å¥ªï¼‰
  } else {
    value -= 20; // å·±æ–¹å·²æ§åˆ¶
  }

  // ä¸­å¤®ç›®æ¨™æ›´é‡è¦
  if (obj.id === 1) value += 25;

  // æ ¹æ“šæˆ°ç•¥èª¿æ•´
  if (gameEval.strategy === "objective_rush") {
    value *= 1.5; // æ¶åˆ†ç­–ç•¥æ™‚ç›®æ¨™æ›´é‡è¦
  } else if (gameEval.strategy === "defensive" && obj.control === aiPlayer) {
    value += 30; // é˜²å®ˆæ™‚ä¿ä½å·²æœ‰ç›®æ¨™
  }

  // å¾ŒæœŸç›®æ¨™æ›´é‡è¦
  if (gameEval.round >= 3) {
    value *= 1.2;
  }
  if (gameEval.round >= 4) {
    value *= 1.3;
  }

  // é«˜OCå–®ä½ä½”é»åƒ¹å€¼æ›´é«˜
  value += unit.stats.OC * 15;

  return { obj, value, dist, canReach };
}

// AIé¸æ“‡ç§»å‹•ç›®æ¨™ - ç­–ç•¥æ€§AIï¼ˆä»¥å¾—åˆ†ç‚ºå„ªå…ˆï¼‰
function aiSelectMoveTarget(unit) {
  const aiPlayer = unit.player;
  const enemyPlayer = aiPlayer === 1 ? 2 : 1;
  const enemies = gameState.units.filter(u => u.player === enemyPlayer && u.alive);
  const myUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive);
  const objectives = gameState.objectives;

  // è©•ä¼°ç•¶å‰å±€å‹¢
  const gameEval = evaluateGameState(aiPlayer);

  if (aiDifficulty === "easy") {
    // ç°¡å–®ï¼šéš¨æ©Ÿç§»å‹•
    return { x: unit.x + (Math.random() - 0.5) * inchToPixels(unit.stats.M), y: unit.y + (Math.random() - 0.5) * inchToPixels(unit.stats.M) };
  }

  // ===== ç­–ç•¥æ€§AIï¼ˆæ™®é€š/å›°é›£ï¼‰=====
  // æ ¸å¿ƒåŸå‰‡ï¼šä»¥å¾—åˆ†(VP)ç‚ºæœ€é«˜å„ªå…ˆï¼

  // 1. è¨ˆç®—å–®ä½çš„æˆ°ç•¥è§’è‰²
  const isHighOC = unit.stats.OC >= 2;           // é«˜ç›®æ¨™æ§åˆ¶å€¼
  const isMeleeOnly = !unit.weapons.ranged && unit.weapons.melee;
  const isRanged = unit.weapons.ranged;
  const isCharacter = unit.keywords?.includes("Character");
  const isLowHP = unit.currentHP / unit.maxHP < 0.4;

  // é¡¯ç¤ºç•¶å‰æˆ°ç•¥
  if (myUnits.indexOf(unit) === 0) {
    log(`ğŸ“Š AIæˆ°ç•¥: ${gameEval.strategy} (VP: ${gameEval.myVP} vs ${gameEval.enemyVP})`, "info");
  }

  // 2. ä½¿ç”¨æ–°çš„ç›®æ¨™è©•ä¼°ç³»çµ±
  const objectiveScores = objectives.map(obj => getObjectiveValue(obj, unit, gameEval, aiPlayer));

  // æª¢æŸ¥ç›®æ¨™é™„è¿‘çš„æ•µè»OC
  objectiveScores.forEach(os => {
    const enemyOCNearby = enemies
      .filter(e => pixelsToInch(Math.hypot(e.x - os.obj.x, e.y - os.obj.y)) <= 3)
      .reduce((sum, e) => sum + e.stats.OC, 0);

    const myOCNearby = myUnits
      .filter(u => u.id !== unit.id && pixelsToInch(Math.hypot(u.x - os.obj.x, u.y - os.obj.y)) <= 3)
      .reduce((sum, u) => sum + u.stats.OC, 0);

    // éœ€è¦æ›´å¤šOCä¾†çˆ­å¥ªçš„ç›®æ¨™
    if (myOCNearby < enemyOCNearby && isHighOC) os.value += 50;

    // å›°é›£æ¨¡å¼ï¼šè€ƒæ…®OCç©©å›ºåº¦
    if (aiDifficulty === "hard") {
      if (os.obj.control === aiPlayer && myOCNearby <= enemyOCNearby + unit.stats.OC) {
        os.value += 25; // éœ€è¦å¢æ´çš„å·±æ–¹ç›®æ¨™
      }
    }
  });

  objectiveScores.sort((a, b) => b.value - a.value);

  // 3. æ±ºå®šç§»å‹•ç›®æ¨™ - ç›®æ¨™å„ªå…ˆï¼
  let targetPosition = null;

  // æ‰€æœ‰å–®ä½éƒ½æ‡‰è©²è€ƒæ…®ä½”é»ï¼ˆä¸åªæ˜¯é«˜OCï¼‰
  // ä½†é«˜OCå–®ä½æœ‰æ›´é«˜çš„å„ªå…ˆç´š
  const objectivePriority = isHighOC ? 0.9 : (gameEval.strategy === "objective_rush" ? 0.8 : 0.6);

  if (Math.random() < objectivePriority && objectiveScores.length > 0 && objectiveScores[0].value > 30) {
    const bestObj = objectiveScores[0].obj;
    if (objectiveScores[0].canReach || objectiveScores[0].dist <= unit.stats.M * 2) {
      targetPosition = { x: bestObj.x, y: bestObj.y };
      const action = bestObj.control === aiPlayer ? "é˜²å®ˆ" : (bestObj.control === null ? "ä½”é ˜" : "æ¶å¥ª");
      log(`ğŸ¯ ${unit.name} ç­–ç•¥ï¼š${action}ç›®æ¨™é»${bestObj.id}`, "info");
    }
  }

  // è¿‘æˆ°å–®ä½ç­–ç•¥ï¼ˆä½”é»å„ªå…ˆï¼Œä½†ä¹Ÿè¦æ¸…é™¤å¨è„…ï¼‰
  if (!targetPosition && isMeleeOnly) {
    // å„ªå…ˆæ”»æ“Šåœ¨ç›®æ¨™é™„è¿‘çš„æ•µäººï¼ˆæ¸…é™¤ä½”é»å¨è„…ï¼‰
    const enemiesNearObjectives = enemies.filter(e =>
      objectives.some(o => pixelsToInch(Math.hypot(e.x - o.x, e.y - o.y)) <= 4)
    );

    if (enemiesNearObjectives.length > 0) {
      const nearestThreat = findNearest(unit, enemiesNearObjectives);
      if (nearestThreat) {
        targetPosition = nearestThreat;
        log(`ğŸ§  ${unit.name} ç­–ç•¥ï¼šæ¸…é™¤ç›®æ¨™é™„è¿‘æ•µäºº`, "info");
      }
    } else {
      const nearestEnemy = findNearest(unit, enemies);
      if (nearestEnemy) targetPosition = nearestEnemy;
    }
  }

  // é ç¨‹å–®ä½ç­–ç•¥ - æ ¹æ“šæˆ°ç•¥æ±ºå®šæ˜¯å¦ç§»å‹•
  if (!targetPosition && isRanged) {
    const weapon = unit.weapons.ranged;
    const inRangeEnemies = enemies.filter(e => {
      const dist = pixelsToInch(Math.hypot(e.x - unit.x, e.y - unit.y));
      return dist <= weapon.range;
    });

    if (inRangeEnemies.length > 0) {
      // å·²æœ‰ç›®æ¨™åœ¨å°„ç¨‹å…§
      if (aiDifficulty === "hard" || gameEval.strategy === "defensive") {
        // å›°é›£æ¨¡å¼æˆ–é˜²å®ˆç­–ç•¥ï¼šå°‹æ‰¾æ©è­·
        if (!unit.inCover) {
          const coverSpot = findNearestCover(unit);
          if (coverSpot) {
            const coverDist = Math.hypot(coverSpot.x - unit.x, coverSpot.y - unit.y);
            if (coverDist <= inchToPixels(unit.stats.M)) {
              targetPosition = coverSpot;
              log(`ğŸ›¡ï¸ ${unit.name} ç­–ç•¥ï¼šç§»å‹•åˆ°æ©è­·ä½ç½®`, "info");
            }
          }
        }
      }

      // æ¶åˆ†ç­–ç•¥ï¼šå³ä½¿æœ‰å°„ç¨‹ç›®æ¨™ï¼Œä¹Ÿå¯èƒ½éœ€è¦ç§»å‹•å»ä½”é»
      if (!targetPosition && gameEval.strategy === "objective_rush" && unit.stats.OC > 0) {
        const urgentObjective = objectiveScores.find(o => o.canReach && o.obj.control !== aiPlayer);
        if (urgentObjective && urgentObjective.value > 80) {
          targetPosition = urgentObjective.obj;
          log(`ğŸ¯ ${unit.name} ç­–ç•¥ï¼šæ”¾æ£„å°„æ“Šå»æ¶é»`, "info");
        }
      }

      if (!targetPosition) {
        return null; // ä¸ç§»å‹•ï¼Œå°ˆæ³¨å°„æ“Š
      }
    } else {
      // æ²’æœ‰ç›®æ¨™åœ¨å°„ç¨‹å…§
      // å„ªå…ˆè€ƒæ…®ç§»å‹•åˆ°ç›®æ¨™é»ï¼ˆå¦‚æœæœ‰åƒ¹å€¼ï¼‰
      const goodObjective = objectiveScores.find(o => o.value > 50 && o.dist <= unit.stats.M * 2);
      if (goodObjective) {
        targetPosition = goodObjective.obj;
        log(`ğŸ¯ ${unit.name} ç­–ç•¥ï¼šç§»å‹•å»ä½”é»`, "info");
      } else {
        // å¦å‰‡å‘æ•µäººé è¿‘
        const nearestEnemy = findNearest(unit, enemies);
        if (nearestEnemy) {
          targetPosition = nearestEnemy;
          log(`ğŸ”« ${unit.name} ç­–ç•¥ï¼šæ¥è¿‘å°„ç¨‹`, "info");
        }
      }
    }
  }

  // ä½HPå–®ä½è€ƒæ…®æ’¤é€€ï¼ˆä½†åœ¨æ¶åˆ†ç­–ç•¥ä¸‹å¯èƒ½å …å®ˆï¼‰
  if (isLowHP && !unit.inCover) {
    if (gameEval.strategy !== "objective_rush" || gameEval.vpDiff > -5) {
      if (aiDifficulty === "hard") {
        const coverSpot = findNearestCover(unit);
        if (coverSpot) {
          targetPosition = coverSpot;
          log(`ğŸ›¡ï¸ ${unit.name} ç­–ç•¥ï¼šæ’¤é€€åˆ°æ©è­·ï¼ˆHPä½ï¼‰`, "info");
        }
      }
    } else {
      log(`ğŸ’€ ${unit.name} ç­–ç•¥ï¼šå …å®ˆé™£åœ°ï¼ˆæ¶åˆ†å„ªå…ˆï¼‰`, "info");
    }
  }

  // æœ€å¾Œä¿åº•ï¼šå¦‚æœæ²’æœ‰ç›®æ¨™ï¼Œä¸€å®šè¦å»ä½”é»
  if (!targetPosition && objectiveScores.length > 0) {
    // å„ªå…ˆæ¶å¥ªæ•µæ–¹ç›®æ¨™ï¼Œå…¶æ¬¡ä¸­ç«‹ï¼Œæœ€å¾Œå¢æ´å·±æ–¹
    const priority = objectiveScores.find(o => o.obj.control !== aiPlayer && o.obj.control !== null) ||
                     objectiveScores.find(o => o.obj.control === null) ||
                     objectiveScores.find(o => o.obj.control === aiPlayer);
    if (priority) {
      targetPosition = priority.obj;
      log(`ğŸ¯ ${unit.name} ç­–ç•¥ï¼šå‰å¾€ç›®æ¨™é»${priority.obj.id}`, "info");
    }
  }

  return targetPosition;
}

// AIå°„æ“Šéšæ®µ
async function aiShootingPhase() {
  const aiPlayer = gameState.currentPlayer;
  const myUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive && !u.hasShot && u.weapons.ranged);

  // å°„æ“Šéšæ®µé–‹å§‹æ™‚è€ƒæ…®ä½¿ç”¨æˆ°ç•¥
  let phaseStratagem = null;
  if (myUnits.length > 0) {
    const firstTarget = aiSelectShootTarget(myUnits[0]);
    phaseStratagem = await aiConsiderStratagem("shooting", { attacker: myUnits[0], target: firstTarget });
  }

  for (const unit of myUnits) {
    await delay(300);
    const target = aiSelectShootTarget(unit);

    if (target) {
      let weapon = unit.weapons.ranged;

      // æª¢æŸ¥ä¸€æ¬¡æ€§æ­¦å™¨æ˜¯å¦å·²ä½¿ç”¨
      if (weapon.oneUse) {
        if (!unit.usedOneUseWeapons) unit.usedOneUseWeapons = {};
        if (unit.usedOneUseWeapons[weapon.name]) {
          log(`${unit.name} çš„ ${weapon.name} å·²ä½¿ç”¨éï¼ˆä¸€æ¬¡æ€§ï¼‰`, "info");
          unit.hasShot = true;
          continue;
        }
      }
      const distance = pixelsToInch(Math.hypot(unit.x - target.x, unit.y - target.y));

      if (distance <= weapon.range) {
        gameState.selectedUnit = unit;
        gameState.targetUnit = target;

        // å°é‡è¦ç›®æ¨™è€ƒæ…®ä½¿ç”¨é¡å¤–æˆ°ç•¥
        if (!phaseStratagem && target.keywords?.includes("Character") && gameState.cp[aiPlayer] >= 1) {
          phaseStratagem = await aiConsiderStratagem("shooting", { attacker: unit, target: target });
        }

        log(`ğŸ¤– ${unit.name} å°„æ“Š ${target.name}`, "phase");

        // æ‡‰ç”¨æˆ°ç•¥æ•ˆæœ
        const stratagemEffects = applyStratagemEffect(phaseStratagem, unit, target, { phase: "shooting" });
        gameState.activeStratagemEffects = stratagemEffects;

        await performAttack(unit, target, weapon, "ranged");
        unit.hasShot = true;

        // æ¨™è¨˜ä¸€æ¬¡æ€§æ­¦å™¨å·²ä½¿ç”¨
        if (weapon.oneUse) {
          if (!unit.usedOneUseWeapons) unit.usedOneUseWeapons = {};
          unit.usedOneUseWeapons[weapon.name] = true;
          log(`âš¡ ${weapon.name} å·²ä½¿ç”¨ï¼ˆä¸€æ¬¡æ€§æ­¦å™¨ï¼‰`, "info");
        }

        updateUnitLists();
        render();
      }
    }
    unit.hasShot = true;
  }

  // æ¸…é™¤æˆ°ç•¥æ•ˆæœ
  gameState.activeStratagemEffects = null;
}

// AIé¸æ“‡å°„æ“Šç›®æ¨™ - ç­–ç•¥æ€§AI
function aiSelectShootTarget(unit) {
  const aiPlayer = unit.player;
  const enemyPlayer = aiPlayer === 1 ? 2 : 1;
  const enemies = gameState.units.filter(u => u.player === enemyPlayer && u.alive);
  if (enemies.length === 0) return null;

  const weapon = unit.weapons.ranged;
  const inRange = enemies.filter(e => {
    const dist = pixelsToInch(Math.hypot(e.x - unit.x, e.y - unit.y));
    return dist <= weapon.range;
  });

  if (inRange.length === 0) return null;

  if (aiDifficulty === "easy") {
    return inRange[Math.floor(Math.random() * inRange.length)];
  }

  // ===== ç­–ç•¥æ€§ç›®æ¨™é¸æ“‡ï¼ˆæ™®é€š/å›°é›£ï¼‰=====
  const objectives = gameState.objectives;
  const gameEval = evaluateGameState(unit.player);

  const scored = inRange.map(enemy => {
    let score = 0;

    // 1. å¯æ“Šæ®ºç›®æ¨™ï¼ˆé«˜å„ªå…ˆï¼‰
    const potentialDamage = estimateDamage(weapon, enemy);
    if (potentialDamage >= enemy.currentHP) {
      score += 80; // å¯ä»¥æ“Šæ®ºçš„ç›®æ¨™æœ€å„ªå…ˆ
    }

    // 2. ä½HPç›®æ¨™
    const hpRatio = enemy.currentHP / enemy.maxHP;
    score += (1 - hpRatio) * 40;

    // 3. ç›®æ¨™é™„è¿‘çš„æ•µäººï¼ˆæˆ°ç•¥åƒ¹å€¼é«˜ï¼‰- æ ¹æ“šæˆ°ç•¥åŠ æ¬Š
    const objNear = objectives.find(o =>
      pixelsToInch(Math.hypot(enemy.x - o.x, enemy.y - o.y)) <= 3
    );
    if (objNear) {
      let objBonus = 35;
      // å¦‚æœæ•µäººä½”è‘—æˆ‘å€‘éœ€è¦çš„ç›®æ¨™ï¼Œå„ªå…ˆæ¸…é™¤
      if (objNear.control !== unit.player) {
        objBonus += 30;
      }
      // æ¶åˆ†ç­–ç•¥æ™‚ç›®æ¨™æ›´é‡è¦
      if (gameEval.strategy === "objective_rush") {
        objBonus *= 1.5;
      }
      score += objBonus;
      // é«˜OCæ•µäººåœ¨ç›®æ¨™é™„è¿‘æ›´å±éšª
      score += enemy.stats.OC * 15;
    }

    // 4. é«˜å¨è„…ç›®æ¨™ï¼ˆè§’è‰²ã€å¼·åŠ›æ­¦å™¨ï¼‰
    const threat = calculateThreat(enemy);
    score += threat * 25;

    // 5. é ˜å°å–®ä½ï¼ˆæ¶ˆæ»…å¯èƒ½é€ æˆæˆ°æ…„ï¼‰
    if (enemy.keywords?.includes("Character")) score += 25;

    // 6. ç„¡æ©è­·ç›®æ¨™ï¼ˆæ›´å®¹æ˜“é€ æˆå‚·å®³ï¼‰
    if (!enemy.inCover) score += 15;

    // 7. å›°é›£æ¨¡å¼ï¼šæ›´ç²¾ç´°çš„æ•ˆç‡è¨ˆç®—
    if (aiDifficulty === "hard") {
      const woundRoll = getWoundRoll(weapon.S, enemy.stats.T);
      score += (7 - woundRoll) * 8; // è¶Šå®¹æ˜“è‡´å‚·è¶Šå¥½

      // è€ƒæ…®è­·ç”²ç©¿é€æ•ˆç‡
      const effectiveSave = Math.max(2, enemy.stats.Sv - (weapon.AP || 0));
      score += (7 - effectiveSave) * 5; // è¶Šé›£è±å…è¶Šå¥½

      // å¦‚æœæ•µäººæœ‰ç„¡æ•µè±å…ï¼Œé™ä½å„ªå…ˆç´š
      if (enemy.inv) score -= 10;

      // å„ªå…ˆæ”»æ“Šæ²’æœ‰æ©è­·çš„é«˜åƒ¹å€¼ç›®æ¨™
      if (!enemy.inCover && enemy.points > 100) score += 20;

      // é˜²å®ˆç­–ç•¥æ™‚å„ªå…ˆæ¸…é™¤å¨è„…æˆ‘æ–¹ç›®æ¨™çš„æ•µäºº
      if (gameEval.strategy === "defensive" && objNear && objNear.control === unit.player) {
        score += 40;
      }
    }

    return { enemy, score };
  });

  scored.sort((a, b) => b.score - a.score);

  // è¨˜éŒ„AIæ€è€ƒéç¨‹
  if (aiDifficulty === "hard" && scored.length > 0) {
    log(`ğŸ§  ç›®æ¨™åˆ†æï¼š${scored[0].enemy.name}(${scored[0].score.toFixed(0)}åˆ†)`, "info");
  }

  return scored[0].enemy;
}

// AIè¡é‹’éšæ®µ
async function aiChargePhase() {
  const aiPlayer = gameState.currentPlayer;
  const enemyPlayer = aiPlayer === 1 ? 2 : 1;
  // å®˜æ–¹è¦å‰‡ï¼šæˆ°æ…„ä¸­çš„å–®ä½ä¸èƒ½è¡é‹’
  const myUnits = gameState.units.filter(u => u.player === aiPlayer && u.alive && !u.hasCharged && !u.battleShocked && u.weapons.melee);

  // è¡é‹’éšæ®µé–‹å§‹æ™‚è€ƒæ…®ä½¿ç”¨æˆ°ç•¥
  let chargeStratagem = null;
  if (myUnits.length > 0) {
    chargeStratagem = await aiConsiderStratagem("charge", { charger: myUnits[0] });
  }

  for (const unit of myUnits) {
    const enemies = gameState.units.filter(u => u.player === enemyPlayer && u.alive);
    const nearbyEnemies = enemies.filter(e => {
      const dist = pixelsToInch(Math.hypot(e.x - unit.x, e.y - unit.y));
      return dist <= 12 && dist > 1.5;
    });

    if (nearbyEnemies.length > 0 && shouldCharge(unit, nearbyEnemies)) {
      await delay(300);

      // ç­–ç•¥æ€§è¡é‹’ç›®æ¨™é¸æ“‡
      const target = aiSelectChargeTarget(unit, nearbyEnemies);

      let roll1 = rollD6();
      let roll2 = rollD6();
      let chargeRoll = roll1 + roll2;
      const dist = pixelsToInch(Math.hypot(target.x - unit.x, target.y - unit.y));

      // å¦‚æœè¡é‹’å¤±æ•—ä¸”æœ‰æˆ°ç•¥å¯é‡æ“²ï¼Œè€ƒæ…®ä½¿ç”¨
      if (chargeRoll < dist && !chargeStratagem && gameState.cp[aiPlayer] >= 1) {
        const rerollStrat = await aiConsiderStratagem("charge", { charger: unit, target: target, needReroll: true });
        if (rerollStrat && rerollStrat.desc.includes("é‡æ“²")) {
          log(`ğŸ² AIä½¿ç”¨æˆ°ç•¥é‡æ“²è¡é‹’éª°`, "info");
          roll1 = rollD6();
          roll2 = rollD6();
          chargeRoll = roll1 + roll2;
        }
      }

      // è¡é‹’éª°å­å‹•ç•«
      if (enableDiceAnimation) {
        await showChargeRoll(roll1, roll2, dist);
      }

      log(`ğŸ¤– ${unit.name} è¡é‹’æ“²éª°: ${roll1}+${roll2}=${chargeRoll}" (éœ€è¦${dist.toFixed(1)}")`, "info");

      if (chargeRoll >= dist) {
        // ç§»å‹•åˆ°ç›®æ¨™æ—é‚Š
        const angle = Math.atan2(target.y - unit.y, target.x - unit.x);
        let newX = target.x - Math.cos(angle) * inchToPixels(1.2);
        let newY = target.y - Math.sin(angle) * inchToPixels(1.2);

        // æª¢æŸ¥æ˜¯å¦èˆ‡å‹è»é‡ç–Šï¼Œå¦‚æœæ˜¯å‰‡å˜—è©¦æ‰¾å…¶ä»–ä½ç½®
        const baseSize = getUnitBaseSize(unit);
        const friendlyUnits = gameState.units.filter(u => u !== unit && u.alive && u.player === unit.player);
        if (!isPositionValid(newX, newY, baseSize, friendlyUnits)) {
          // å˜—è©¦åœç¹ç›®æ¨™æ‰¾åˆ°ä¸é‡ç–Šçš„ä½ç½®
          for (let angleOffset = Math.PI / 4; angleOffset <= Math.PI * 2; angleOffset += Math.PI / 4) {
            const testAngle = angle + angleOffset;
            const testX = target.x - Math.cos(testAngle) * inchToPixels(1.5);
            const testY = target.y - Math.sin(testAngle) * inchToPixels(1.5);
            if (isPositionValid(testX, testY, baseSize, friendlyUnits)) {
              newX = testX;
              newY = testY;
              break;
            }
          }
        }

        unit.x = newX;
        unit.y = newY;
        unit.isInEngagement = true;
        target.isInEngagement = true;
        unit.chargeTarget = target.id;
        playSound('charge'); // éŸ³æ•ˆï¼šè¡é‹’
        log(`ğŸ¤– ${unit.name} è¡é‹’æˆåŠŸï¼`, "hit");

        // ===== Tank Shockï¼ˆå¦å…‹è¡æ“Šï¼‰- AIè¼‰å…·è‡ªå‹•è€ƒæ…®ä½¿ç”¨ =====
        if (unit.keywords?.includes("Vehicle")) {
          await checkTankShock(unit, target);
        }
      } else {
        playSound('miss'); // éŸ³æ•ˆï¼šå¤±æ•—
        log(`ğŸ¤– ${unit.name} è¡é‹’å¤±æ•—`, "miss");
      }

      unit.hasCharged = true;
      updateUnitLists();
      render();
    }
    unit.hasCharged = true;
  }
}

// åˆ¤æ–·æ˜¯å¦æ‡‰è©²è¡é‹’
function shouldCharge(unit, enemies) {
  if (aiDifficulty === "easy") return Math.random() > 0.5;

  // è¿‘æˆ°å°ˆç²¾å–®ä½å„ªå…ˆè¡é‹’
  if (!unit.weapons.ranged) return true;

  // å›°é›£æ¨¡å¼ï¼šåˆ†ææ˜¯å¦æœ‰åˆ©
  if (aiDifficulty === "hard") {
    const nearestEnemy = findNearest(unit, enemies);
    if (nearestEnemy) {
      const myMelee = unit.weapons.melee;
      const enemyHP = nearestEnemy.currentHP;
      // å¦‚æœå¯èƒ½é€ æˆå¤§é‡å‚·å®³å°±è¡é‹’
      const potentialDamage = estimateDamage(myMelee, nearestEnemy);
      if (potentialDamage >= enemyHP * 0.5) return true;

      // å¦‚æœæ•µäººåœ¨ç›®æ¨™é»é™„è¿‘ï¼Œè¡é‹’æ¸…é™¤
      const nearObjective = gameState.objectives.some(o =>
        pixelsToInch(Math.hypot(nearestEnemy.x - o.x, nearestEnemy.y - o.y)) <= 3
      );
      if (nearObjective) return true;
    }
  }

  return Math.random() > 0.7;
}

// AIé¸æ“‡è¡é‹’ç›®æ¨™ - ç­–ç•¥æ€§é¸æ“‡
function aiSelectChargeTarget(unit, enemies) {
  if (enemies.length === 1) return enemies[0];

  if (aiDifficulty === "easy") {
    return findNearest(unit, enemies);
  }

  // ç­–ç•¥æ€§é¸æ“‡è¡é‹’ç›®æ¨™
  const objectives = gameState.objectives;
  const scored = enemies.map(enemy => {
    let score = 0;
    const dist = pixelsToInch(Math.hypot(unit.x - enemy.x, unit.y - enemy.y));

    // è·é›¢è¿‘çš„å„ªå…ˆï¼ˆæ›´å®¹æ˜“æˆåŠŸï¼‰
    score += (12 - dist) * 5;

    // å¯æ“Šæ®ºç›®æ¨™å„ªå…ˆ
    const potentialDamage = estimateDamage(unit.weapons.melee, enemy);
    if (potentialDamage >= enemy.currentHP) score += 50;

    // ç›®æ¨™é»é™„è¿‘çš„æ•µäººå„ªå…ˆ
    const nearObjective = objectives.some(o =>
      pixelsToInch(Math.hypot(enemy.x - o.x, enemy.y - o.y)) <= 3
    );
    if (nearObjective) score += 40;

    // é«˜OCæ•µäººå„ªå…ˆ
    score += enemy.stats.OC * 8;

    // ä½HPæ•µäººå„ªå…ˆ
    const hpRatio = enemy.currentHP / enemy.maxHP;
    score += (1 - hpRatio) * 30;

    // å›°é›£æ¨¡å¼ï¼šè€ƒæ…®å¨è„…
    if (aiDifficulty === "hard") {
      // å„ªå…ˆæ¶ˆæ»…é«˜å¨è„…ç›®æ¨™
      const threat = calculateThreat(enemy);
      score += threat * 15;
    }

    return { enemy, score };
  });

  scored.sort((a, b) => b.score - a.score);
  return scored[0].enemy;
}

// AIè¿‘æˆ°éšæ®µ (å®˜æ–¹10ç‰ˆè¦å‰‡ï¼šFight First + Pile In + Consolidate)
async function aiFightPhase() {
  const aiPlayer = gameState.currentPlayer;
  const enemyPlayer = aiPlayer === 1 ? 2 : 1;

  // ç²å–è¿‘æˆ°æ”»æ“Šé †åºï¼ˆè¡é‹’å–®ä½å…ˆæ”»æ“Š = Fight Firstï¼‰
  const fightOrder = getFightOrder();
  const myUnitsInOrder = fightOrder.filter(u => u.player === aiPlayer);

  log(`ã€è¿‘æˆ°éšæ®µã€‘Fight First é †åºï¼š${fightOrder.map(u => u.name + (u.hasCharged ? '(è¡é‹’)' : '')).join(' â†’ ')}`, "info");

  // æˆ°é¬¥éšæ®µé–‹å§‹æ™‚è€ƒæ…®ä½¿ç”¨æˆ°ç•¥
  let fightStratagem = null;
  if (myUnitsInOrder.length > 0) {
    fightStratagem = await aiConsiderStratagem("fight", { attacker: myUnitsInOrder[0] });
  }

  for (const unit of myUnitsInOrder) {
    if (unit.hasFought) continue;

    // ===== Pile In: è¿‘æˆ°å‰3"ç§»å‘æœ€è¿‘æ•µäºº =====
    await performPileIn(unit);

    const enemies = gameState.units.filter(u => u.player === enemyPlayer && u.alive);
    const meleeRange = enemies.filter(e => {
      const dist = pixelsToInch(Math.hypot(e.x - unit.x, e.y - unit.y));
      return dist <= 1.5;
    });

    if (meleeRange.length > 0) {
      await delay(300);
      const target = aiSelectMeleeTarget(unit, meleeRange);

      if (target) {
        gameState.selectedUnit = unit;
        gameState.targetUnit = target;

        // å°é‡è¦ç›®æ¨™è€ƒæ…®ä½¿ç”¨é¡å¤–æˆ°ç•¥
        if (!fightStratagem && target.keywords?.includes("Character") && gameState.cp[aiPlayer] >= 1) {
          fightStratagem = await aiConsiderStratagem("fight", { attacker: unit, target: target });
        }

        log(`ğŸ¤– ${unit.name} è¿‘æˆ°æ”»æ“Š ${target.name}`, "phase");

        // æ‡‰ç”¨æˆ°ç•¥æ•ˆæœ
        const stratagemEffects = applyStratagemEffect(fightStratagem, unit, target, { phase: "fight" });
        gameState.activeStratagemEffects = stratagemEffects;

        await performAttack(unit, target, unit.weapons.melee, "melee");
      }
    }

    unit.hasFought = true;

    // ===== Consolidate: è¿‘æˆ°å¾Œ3"ç§»å‘æœ€è¿‘æ•µäºº =====
    await performConsolidate(unit);

    updateUnitLists();
    render();
  }

  // æ¸…é™¤æˆ°ç•¥æ•ˆæœ
  gameState.activeStratagemEffects = null;
}

// AIé¸æ“‡è¿‘æˆ°ç›®æ¨™ - ç­–ç•¥æ€§é¸æ“‡
function aiSelectMeleeTarget(unit, enemies) {
  if (enemies.length === 0) return null;
  if (enemies.length === 1) return enemies[0];

  if (aiDifficulty === "easy") {
    return enemies[Math.floor(Math.random() * enemies.length)];
  }

  // ===== ç­–ç•¥æ€§è¿‘æˆ°ç›®æ¨™é¸æ“‡ =====
  const objectives = gameState.objectives;
  const weapon = unit.weapons.melee;

  const scored = enemies.map(enemy => {
    let score = 0;

    // å¯æ“Šæ®ºç›®æ¨™å„ªå…ˆ
    const potentialDamage = estimateDamage(weapon, enemy);
    if (potentialDamage >= enemy.currentHP) {
      score += 80;
    }

    // ä½HPç›®æ¨™å„ªå…ˆ
    const hpRatio = enemy.currentHP / enemy.maxHP;
    score += (1 - hpRatio) * 40;

    // ç›®æ¨™é»é™„è¿‘çš„æ•µäººå„ªå…ˆ
    const nearObjective = objectives.some(o =>
      pixelsToInch(Math.hypot(enemy.x - o.x, enemy.y - o.y)) <= 3
    );
    if (nearObjective) {
      score += 35;
      score += enemy.stats.OC * 8;
    }

    // é«˜å¨è„…ç›®æ¨™å„ªå…ˆ
    const threat = calculateThreat(enemy);
    score += threat * 20;

    // è§’è‰²ç›®æ¨™ï¼ˆæ¶ˆæ»…å¯èƒ½é€ æˆæˆ°æ…„ï¼‰
    if (enemy.keywords?.includes("Character")) score += 25;

    // å›°é›£æ¨¡å¼ï¼šè€ƒæ…®å‚·å®³æ•ˆç‡
    if (aiDifficulty === "hard") {
      const woundRoll = getWoundRoll(weapon.S, enemy.stats.T);
      score += (7 - woundRoll) * 6;

      // ä½è­·ç”²æ•µäººæ›´å®¹æ˜“é€ æˆå‚·å®³
      const effectiveSave = Math.max(2, enemy.stats.Sv - (weapon.AP || 0));
      score += (7 - effectiveSave) * 4;
    }

    return { enemy, score };
  });

  scored.sort((a, b) => b.score - a.score);
  return scored[0].enemy;
}

// è¼”åŠ©å‡½æ•¸
function findNearest(unit, targets) {
  if (targets.length === 0) return null;
  let nearest = targets[0];
  let minDist = Math.hypot(unit.x - targets[0].x, unit.y - targets[0].y);

  for (const t of targets) {
    const dist = Math.hypot(unit.x - t.x, unit.y - t.y);
    if (dist < minDist) {
      minDist = dist;
      nearest = t;
    }
  }
  return nearest;
}

function findNearestCover(unit) {
  const validTerrain = gameState.terrain.filter(t => TERRAIN_TYPES[t.type].coverBonus);
  if (validTerrain.length === 0) return null;

  return findNearest(unit, validTerrain.map(t => ({ x: t.x, y: t.y })));
}

function calculateThreat(unit) {
  let threat = 0;
  if (!unit || !unit.weapons) return 0;  // é˜²æ­¢ undefined éŒ¯èª¤
  if (unit.weapons.ranged) {
    const w = unit.weapons.ranged;
    threat += (typeof w.A === 'number' ? w.A : 3) * (w.S || 4) * (1 + Math.abs(w.AP || 0));
  }
  if (unit.weapons.melee) {
    const w = unit.weapons.melee;
    threat += (typeof w.A === 'number' ? w.A : 3) * (w.S || 4) * (1 + Math.abs(w.AP || 0)) * 0.8;
  }
  return threat / 100;
}

function estimateDamage(weapon, target) {
  const attacks = typeof weapon.A === 'number' ? weapon.A : 3;
  const hitChance = (7 - weapon.skill) / 6;
  const woundRoll = getWoundRoll(weapon.S, target.stats.T);
  const woundChance = (7 - woundRoll) / 6;
  const saveRoll = Math.min(7, target.stats.Sv - (weapon.AP || 0));
  const failSaveChance = Math.min(1, (saveRoll - 1) / 6);
  const damage = typeof weapon.D === 'number' ? weapon.D : 3;

  return attacks * hitChance * woundChance * failSaveChance * damage;
}

// ========== æˆ°å ´é è¦½ ==========
function updateBattlefieldPreview() {
  selectedBattlefieldSize = document.getElementById("battlefieldSize")?.value || "strike-force";
  selectedMapScenario = document.getElementById("mapScenario")?.value || "standard";

  const sizeConfig = BATTLEFIELD_SIZES[selectedBattlefieldSize];
  const mapConfig = MAP_SCENARIOS[selectedMapScenario];

  // æ›´æ–°æè¿°
  const sizeDesc = document.getElementById("sizeDesc");
  const mapDesc = document.getElementById("mapDesc");
  if (sizeDesc) sizeDesc.textContent = sizeConfig.desc;
  if (mapDesc) mapDesc.textContent = mapConfig.desc;

  // ç¹ªè£½é è¦½
  const previewCanvas = document.getElementById("previewCanvas");
  if (!previewCanvas) return;

  const previewCtx = previewCanvas.getContext("2d");
  const scale = Math.min(300 / (sizeConfig.width * INCH), 200 / (sizeConfig.height * INCH));
  const w = sizeConfig.width * INCH * scale;
  const h = sizeConfig.height * INCH * scale;

  // èª¿æ•´ canvas å¤§å°
  previewCanvas.width = Math.max(300, w);
  previewCanvas.height = Math.max(150, h);

  // ç¹ªè£½èƒŒæ™¯
  previewCtx.fillStyle = "#1a2a1a";
  previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);

  // ç½®ä¸­åç§»
  const offsetX = (previewCanvas.width - w) / 2;
  const offsetY = (previewCanvas.height - h) / 2;

  // ç¹ªè£½æˆ°å ´å€åŸŸ
  previewCtx.fillStyle = "#243424";
  previewCtx.fillRect(offsetX, offsetY, w, h);
  previewCtx.strokeStyle = "rgba(255,255,255,0.3)";
  previewCtx.lineWidth = 1;
  previewCtx.strokeRect(offsetX, offsetY, w, h);

  // ç¹ªè£½éƒ¨ç½²å€
  const deployWidth = sizeConfig.deployZone * INCH * scale;
  previewCtx.fillStyle = "rgba(70, 130, 180, 0.3)";
  previewCtx.fillRect(offsetX, offsetY, deployWidth, h);
  previewCtx.fillStyle = "rgba(220, 80, 80, 0.3)";
  previewCtx.fillRect(offsetX + w - deployWidth, offsetY, deployWidth, h);

  // ç”Ÿæˆåœ°å½¢å’Œç›®æ¨™
  const fullW = sizeConfig.width * INCH;
  const fullH = sizeConfig.height * INCH;
  const mapData = mapConfig.generate(fullW, fullH);

  // ç¹ªè£½åœ°å½¢
  for (const t of mapData.terrain) {
    const terrainInfo = TERRAIN_TYPES[t.type];
    if (!terrainInfo) continue;

    previewCtx.fillStyle = terrainInfo.color;
    previewCtx.globalAlpha = 0.6;
    previewCtx.fillRect(
      offsetX + (t.x - t.width/2) * scale,
      offsetY + (t.y - t.height/2) * scale,
      t.width * scale,
      t.height * scale
    );
    previewCtx.globalAlpha = 1;
  }

  // ç¹ªè£½ç›®æ¨™é»
  for (const obj of mapData.objectives) {
    previewCtx.beginPath();
    previewCtx.arc(offsetX + obj.x * scale, offsetY + obj.y * scale, 6, 0, Math.PI * 2);
    previewCtx.fillStyle = "#fbbf24";
    previewCtx.fill();
    previewCtx.strokeStyle = "#fff";
    previewCtx.lineWidth = 1;
    previewCtx.stroke();
  }

  // æ¨™ç¤ºå°ºå¯¸
  previewCtx.font = "10px sans-serif";
  previewCtx.fillStyle = "#888";
  previewCtx.textAlign = "center";
  previewCtx.fillText(`${sizeConfig.width}" x ${sizeConfig.height}"`, previewCanvas.width / 2, previewCanvas.height - 5);
}

// ========== åˆå§‹åŒ– ==========
function init() {
  canvas = document.getElementById("gameCanvas");
  ctx = canvas.getContext("2d");

  updateAvailableUnits(1);
  updateAvailableUnits(2);
  updateDetachmentOptions(1);
  updateDetachmentOptions(2);
  updateBattlefieldPreview();

  window.addEventListener("resize", resizeCanvas);
}

// ========== ç¨®æ—è¦å‰‡åŠŸèƒ½ ==========
function updateDetachmentOptions(player) {
  const factionId = document.getElementById(`p${player}Faction`).value;
  const detachmentSelect = document.getElementById(`p${player}Detachment`);
  const descDiv = document.getElementById(`p${player}DetachmentDesc`);

  const factionDetachments = DETACHMENT_RULES[factionId] || {};
  detachmentSelect.innerHTML = '';

  for (const [key, det] of Object.entries(factionDetachments)) {
    const option = document.createElement('option');
    option.value = key;
    option.textContent = det.name;
    detachmentSelect.appendChild(option);
  }

  // é¸æ“‡ç¬¬ä¸€å€‹ä¸¦æ›´æ–°æè¿°
  selectDetachment(player);
}

function selectDetachment(player) {
  const factionId = document.getElementById(`p${player}Faction`).value;
  const detachmentId = document.getElementById(`p${player}Detachment`).value;
  const descDiv = document.getElementById(`p${player}DetachmentDesc`);

  const detachment = DETACHMENT_RULES[factionId]?.[detachmentId];
  if (detachment) {
    playerDetachments[player] = { factionId, detachmentId, ...detachment };
    descDiv.innerHTML = `<strong>${detachment.name}</strong><br>${detachment.description}`;
  }
}

// ç²å–ç¨®æ—è¦å‰‡æ•ˆæœ
function getDetachmentBonus(player, attacker, target, context) {
  const det = playerDetachments[player];
  if (!det || !det.apply) return {};

  try {
    return det.apply(attacker, target, context) || {};
  } catch (e) {
    return {};
  }
}

// æª¢æŸ¥æ˜¯å¦é è¿‘ç›®æ¨™æ¨™è¨˜
function isNearObjective(unit) {
  const OBJ_RANGE = inchToPixels(3);
  for (const obj of gameState.objectives) {
    const dist = Math.hypot(unit.x - obj.x, unit.y - obj.y);
    if (dist <= OBJ_RANGE) return true;
  }
  return false;
}

// æª¢æŸ¥ç›®æ¨™æ˜¯å¦é è¿‘å·±æ–¹æ€ªç¸ï¼ˆç”¨æ–¼ Pantheon of Woeï¼‰
function isNearAllyMonster(target, attackerPlayer) {
  const AURA_RANGE = inchToPixels(6);
  const allyMonsters = gameState.units.filter(u =>
    u.player === attackerPlayer &&
    u.alive &&
    u.keywords?.includes("Monster")
  );

  for (const monster of allyMonsters) {
    const dist = Math.hypot(target.x - monster.x, target.y - monster.y);
    if (dist <= AURA_RANGE) return true;
  }
  return false;
}

// ========== è»è¡¨é…ç½®åŠŸèƒ½ ==========
function updateAvailableUnits(player) {
  const factionId = document.getElementById(`p${player}Faction`).value;
  const faction = UNIT_DATABASE[factionId];
  const grid = document.getElementById(`p${player}UnitGrid`);

  grid.innerHTML = "";

  faction.units.forEach(unit => {
    const div = document.createElement("div");
    div.className = "unit-option";
    div.onclick = () => addUnitToRoster(player, factionId, unit);
    div.innerHTML = `
      <img src="${unit.img}" alt="${unit.name}" onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 40 40%22><rect fill=%22%23333%22 width=%2240%22 height=%2240%22/><text x=%2220%22 y=%2225%22 text-anchor=%22middle%22 fill=%22%23888%22 font-size=%2220%22>?</text></svg>'">
      <div class="unit-option-info">
        <div class="unit-option-name">${unit.name}</div>
        <div class="unit-option-cost">${unit.points} é»</div>
      </div>
    `;
    grid.appendChild(div);
  });
}

function addUnitToRoster(player, factionId, unit) {
  const roster = armyRosters[player];
  const currentPoints = roster.reduce((sum, u) => sum + u.points, 0);

  // ===== é»æ•¸ä¸Šé™æª¢æŸ¥ =====
  if (currentPoints + unit.points > maxPoints) {
    alert(`è¶…å‡ºé»æ•¸ä¸Šé™ï¼(${currentPoints + unit.points} > ${maxPoints})`);
    return;
  }

  // ===== ä¸‰é‡è¦å‰‡ (Rule of Three) - åŒä¸€å–®ä½æœ€å¤š3å€‹ =====
  const sameUnitCount = roster.filter(u => u.id === unit.id).length;
  if (sameUnitCount >= 3) {
    alert(`âŒ ä¸‰é‡è¦å‰‡ï¼šåŒä¸€å–®ä½æœ€å¤šåªèƒ½æœ‰3å€‹ï¼\nã€Œ${unit.name}ã€å·²æœ‰ ${sameUnitCount} å€‹`);
    return;
  }

  // ===== æˆ°ç·šå–®ä½ä¸Šé™ (Battleline) - æœ€å¤š6å€‹ =====
  if (unit.keywords?.includes("Battleline")) {
    const battlelineCount = roster.filter(u => u.keywords?.includes("Battleline")).length;
    if (battlelineCount >= 6) {
      alert(`âŒ æˆ°ç·šä¸Šé™ï¼šBattleline å–®ä½æœ€å¤šåªèƒ½æœ‰6å€‹ï¼\nç›®å‰å·²æœ‰ ${battlelineCount} å€‹æˆ°ç·šå–®ä½`);
      return;
    }
  }

  roster.push({ ...unit, faction: factionId, uid: Date.now() + Math.random() });
  updateRosterDisplay(player);
  checkStartButton();
  syncArmyToFirebase(player);  // å³æ™‚åŒæ­¥è»éšŠ
}

function removeFromRoster(player, index) {
  armyRosters[player].splice(index, 1);
  updateRosterDisplay(player);
  checkStartButton();
  syncArmyToFirebase(player);  // å³æ™‚åŒæ­¥è»éšŠ
}

// ç·šä¸Šæ¨¡å¼ï¼šå³æ™‚åŒæ­¥è»éšŠåˆ° Firebase
function syncArmyToFirebase(player) {
  console.log('[syncArmy] å˜—è©¦åŒæ­¥:', { player, isOnlineMode, hasRoomRef: !!roomRef, onlinePlayerId });
  if (!isOnlineMode || !roomRef) {
    console.log('[syncArmy] è·³éï¼šéç·šä¸Šæ¨¡å¼æˆ–ç„¡æˆ¿é–“');
    return;
  }
  if (player !== onlinePlayerId) {
    console.log('[syncArmy] è·³éï¼šä¸æ˜¯è‡ªå·±çš„è»éšŠ', player, '!=', onlinePlayerId);
    return;
  }

  const roster = armyRosters[player];
  const factionSelect = document.getElementById(`p${player}Faction`);
  const detachmentSelect = document.getElementById(`p${player}Detachment`);

  console.log('[syncArmy] ä¸Šå‚³è»éšŠ:', roster.length, 'å€‹å–®ä½');

  // æ¸…ç†è³‡æ–™ï¼Œç§»é™¤æ‰€æœ‰ undefined å€¼ï¼Œä¿ç•™å®Œæ•´å–®ä½è³‡æ–™
  const cleanRoster = roster.map(u => {
    // æ­£ç¢ºè™•ç†æ­¦å™¨ç‰©ä»¶ {ranged, melee} çµæ§‹
    let cleanWeapons = {};
    if (u.weapons) {
      if (u.weapons.ranged) {
        cleanWeapons.ranged = JSON.parse(JSON.stringify(u.weapons.ranged));
      }
      if (u.weapons.melee) {
        cleanWeapons.melee = JSON.parse(JSON.stringify(u.weapons.melee));
      }
    }

    const clean = {
      id: u.id || '',
      name: u.name || '',
      points: u.points || 0,
      faction: u.faction || '',  // ç¢ºä¿é™£ç‡Ÿè³‡è¨Šä¹ŸåŒæ­¥
      stats: u.stats ? JSON.parse(JSON.stringify(u.stats)) : {},
      weapons: cleanWeapons,
      abilities: Array.isArray(u.abilities) ? u.abilities.filter(a => a !== undefined) : [],
      keywords: Array.isArray(u.keywords) ? u.keywords.filter(k => k !== undefined) : [],
      inv: u.inv !== undefined ? u.inv : null,
      img: u.img || ''
    };
    return clean;
  });

  roomRef.child(`armies/${player}`).set({
    roster: cleanRoster,
    faction: factionSelect ? factionSelect.value : '',
    detachment: detachmentSelect ? detachmentSelect.value : ''
  }).then(() => {
    console.log('[syncArmy] ä¸Šå‚³æˆåŠŸï¼');
  }).catch(err => {
    console.error('[syncArmy] ä¸Šå‚³å¤±æ•—:', err);
  });
}

// ========== é»æ•¸ä¸Šé™è¨­å®š ==========
function updateMaxPoints(value) {
  maxPoints = parseInt(value);
  document.getElementById("maxPointsDisplay").textContent = maxPoints;
  document.getElementById("maxPointsSlider").value = maxPoints;
  // æ›´æ–°å…©é‚Šçš„é»æ•¸é¡¯ç¤º
  document.querySelectorAll(".max-pts").forEach(el => {
    el.textContent = maxPoints;
  });
}

function setPointsPreset(value) {
  updateMaxPoints(value);
  document.getElementById("maxPointsSlider").value = value;
}

// ========== æ¸…ç©ºè»éšŠ ==========
function clearRoster(player) {
  armyRosters[player] = [];
  updateRosterDisplay(player);
  checkStartButton();
  syncArmyToFirebase(player);  // å³æ™‚åŒæ­¥è»éšŠ
}

// ========== Meta è‡ªå‹•é…ç½® ==========
// å„é™£ç‡Ÿçš„ Meta é…ç½®ï¼ˆåŸºæ–¼ç«¶æŠ€å ´å¸¸è¦‹é…ç½®ï¼‰
const META_BUILDS = {
  "necrons": {
    meta: [
      { id: "nc-overlord", count: 1 },       // éœ¸ä¸»å¿…å¸¶
      { id: "nc-ctan-void", count: 1 },      // è™›ç©ºé¾æ˜Ÿç¥
      { id: "nc-warriors", count: 2 },       // æˆ°å£«Ã—10å¡«ç·š
      { id: "nc-immortals", count: 1 },      // ä¸æœ½è€…
      { id: "nc-lychguard", count: 1 },      // æš—è¡›
      { id: "nc-wraiths", count: 1 },        // å¹½éˆ
      { id: "nc-doomstalker", count: 1 }     // æœ«æ—¥è¡Œè€…
    ],
    balanced: [
      { id: "nc-overlord", count: 1 },
      { id: "nc-warriors", count: 2 },
      { id: "nc-immortals", count: 1 },
      { id: "nc-scarabs", count: 2 },
      { id: "nc-skorpekh", count: 1 }
    ]
  },
  "tyranids": {
    meta: [
      { id: "ty-hivetyrant", count: 1 },     // èŸ²å·¢æš´å›
      { id: "ty-swarmlord", count: 1 },      // èŸ²ç¾¤éœ¸ä¸»
      { id: "ty-termagants", count: 2 },     // ç™½èŸ»å¡«ç·š
      { id: "ty-hormagaunts", count: 1 },    // åˆºèŸ²è¡é‹’
      { id: "ty-zoanthropes", count: 1 },    // éˆèƒ½ç¸
      { id: "ty-carnifex", count: 1 },       // å± æ®ºç¸
      { id: "ty-exocrine", count: 1 }        // å™´å°„ç¸
    ],
    balanced: [
      { id: "ty-broodlord", count: 1 },
      { id: "ty-termagants", count: 2 },
      { id: "ty-hormagaunts", count: 2 },
      { id: "ty-warriors", count: 1 },
      { id: "ty-lictors", count: 1 }
    ]
  },
  "space-marines": {
    meta: [
      { id: "sm-captain", count: 1 },
      { id: "sm-intercessors", count: 2 },
      { id: "sm-hellblasters", count: 1 },
      { id: "sm-redemptor", count: 1 }
    ],
    balanced: [
      { id: "sm-captain", count: 1 },
      { id: "sm-tactical", count: 2 },
      { id: "sm-intercessors", count: 1 }
    ]
  },
  "chaos": {
    meta: [
      { id: "ch-lord", count: 1 },
      { id: "ch-legionaries", count: 2 },
      { id: "ch-terminators", count: 1 }
    ],
    balanced: [
      { id: "ch-lord", count: 1 },
      { id: "ch-legionaries", count: 2 }
    ]
  },
  "orks": {
    meta: [
      { id: "ork-warboss", count: 1 },
      { id: "ork-boyz", count: 3 }
    ],
    balanced: [
      { id: "ork-warboss", count: 1 },
      { id: "ork-boyz", count: 2 }
    ]
  }
};

function autoConfigMeta(player) {
  const factionId = document.getElementById(`p${player}Faction`).value;
  autoConfigArmy(player, factionId, "meta");
}

function autoConfigBalanced(player) {
  const factionId = document.getElementById(`p${player}Faction`).value;
  autoConfigArmy(player, factionId, "balanced");
}

function autoConfigArmy(player, factionId, buildType) {
  // æ¸…ç©ºç•¶å‰è»éšŠ
  armyRosters[player] = [];

  const faction = UNIT_DATABASE[factionId];
  if (!faction) return;

  const build = META_BUILDS[factionId]?.[buildType];
  if (!build) {
    // å¦‚æœæ²’æœ‰é è¨­é…ç½®ï¼Œä½¿ç”¨æ™ºèƒ½å¡«å……
    smartFillArmy(player, factionId);
    return;
  }

  let currentPoints = 0;

  // æŒ‰ç…§ Meta é…ç½®æ·»åŠ å–®ä½
  for (const config of build) {
    const unitTemplate = faction.units.find(u => u.id === config.id);
    if (!unitTemplate) continue;

    for (let i = 0; i < config.count; i++) {
      if (currentPoints + unitTemplate.points <= maxPoints) {
        armyRosters[player].push({
          ...unitTemplate,
          faction: factionId,
          uid: Date.now() + Math.random()
        });
        currentPoints += unitTemplate.points;
      }
    }
  }

  // å¦‚æœé‚„æœ‰é»æ•¸ï¼Œæ™ºèƒ½å¡«å……
  smartFillRemaining(player, factionId, currentPoints);

  updateRosterDisplay(player);
  checkStartButton();
  syncArmyToFirebase(player);  // å³æ™‚åŒæ­¥è»éšŠ
}

// æ™ºèƒ½å¡«å……å‰©é¤˜é»æ•¸
function smartFillRemaining(player, factionId, currentPoints) {
  const faction = UNIT_DATABASE[factionId];
  if (!faction) return;

  // æŒ‰é»æ•¸æ’åºï¼Œå„ªå…ˆå¡«å……ä¾¿å®œçš„å–®ä½
  const sortedUnits = [...faction.units].sort((a, b) => a.points - b.points);

  for (const unit of sortedUnits) {
    while (currentPoints + unit.points <= maxPoints) {
      armyRosters[player].push({
        ...unit,
        faction: factionId,
        uid: Date.now() + Math.random()
      });
      currentPoints += unit.points;
    }
  }
}

// æ™ºèƒ½å¡«å……æ•´å€‹è»éšŠï¼ˆæ²’æœ‰ Meta é…ç½®æ™‚ä½¿ç”¨ï¼‰
function smartFillArmy(player, factionId) {
  const faction = UNIT_DATABASE[factionId];
  if (!faction) return;

  let currentPoints = 0;
  const units = faction.units;

  // 1. å…ˆåŠ å…¥ä¸€å€‹è§’è‰²/é ˜è¢–
  const leader = units.find(u => u.keywords?.includes("Character") || u.name.includes("é ˜ä¸»") || u.name.includes("éœ¸ä¸»") || u.name.includes("é€£é•·"));
  if (leader && currentPoints + leader.points <= maxPoints) {
    armyRosters[player].push({ ...leader, faction: factionId, uid: Date.now() + Math.random() });
    currentPoints += leader.points;
  }

  // 2. åŠ å…¥åŸºç¤æ­¥å…µ
  const troops = units.filter(u => u.name.includes("Ã—10") || u.name.includes("Ã—5") || u.points <= 80);
  for (const troop of troops) {
    if (currentPoints + troop.points <= maxPoints * 0.4) { // æœ€å¤š40%èŠ±åœ¨åŸºç¤å–®ä½
      armyRosters[player].push({ ...troop, faction: factionId, uid: Date.now() + Math.random() });
      currentPoints += troop.points;
    }
  }

  // 3. åŠ å…¥ç²¾è‹±/é‡å‹å–®ä½
  const elites = units.filter(u => u.points > 80 && u.points < 200);
  for (const elite of elites) {
    if (currentPoints + elite.points <= maxPoints) {
      armyRosters[player].push({ ...elite, faction: factionId, uid: Date.now() + Math.random() });
      currentPoints += elite.points;
      if (currentPoints >= maxPoints * 0.8) break;
    }
  }

  // 4. å¡«å……å‰©é¤˜é»æ•¸
  smartFillRemaining(player, factionId, currentPoints);

  updateRosterDisplay(player);
  checkStartButton();
  syncArmyToFirebase(player);  // å³æ™‚åŒæ­¥è»éšŠ
}

function updateRosterDisplay(player) {
  const roster = armyRosters[player];
  const container = document.getElementById(`p${player}Roster`);
  const pointsDisplay = document.getElementById(`p${player}Points`);

  const totalPoints = roster.reduce((sum, u) => sum + u.points, 0);
  pointsDisplay.textContent = totalPoints;

  // æª¢æŸ¥æ˜¯å¦æœ‰ä¸»å°‡
  const hasWarlord = roster.some(u => u.isWarlord);

  container.innerHTML = roster.map((unit, i) => {
    const isCharacter = unit.keywords?.includes("Character");
    const warlordBtn = isCharacter ? `
      <button class="warlord-btn ${unit.isWarlord ? 'active' : ''}"
              onclick="setWarlord(${player}, ${i})"
              title="${unit.isWarlord ? 'ä¸»å°‡' : 'è¨­ç‚ºä¸»å°‡'}"
              style="margin-left: 4px; padding: 1px 4px; font-size: 10px;
                     background: ${unit.isWarlord ? '#fbbf24' : '#444'};
                     border: 1px solid ${unit.isWarlord ? '#fbbf24' : '#666'};
                     color: ${unit.isWarlord ? '#000' : '#aaa'};
                     border-radius: 3px; cursor: pointer;">
        ${unit.isWarlord ? 'ğŸ‘‘ä¸»å°‡' : 'ğŸ‘‘'}
      </button>` : '';

    // å¼·åŒ–æŒ‰éˆ•ï¼ˆåªæœ‰è§’è‰²ä¸”ä¸æ˜¯Epic Heroï¼‰
    const canEnhance = isCharacter && !unit.keywords?.includes("Epic Hero");
    const enhanceBtn = canEnhance ? `
      <button class="enhance-btn ${unit.enhancement ? 'active' : ''}"
              onclick="showEnhancementMenu(${player}, ${i})"
              title="${unit.enhancement ? unit.enhancement : 'é¸æ“‡å¼·åŒ–'}"
              style="margin-left: 4px; padding: 1px 4px; font-size: 10px;
                     background: ${unit.enhancement ? '#8b5cf6' : '#444'};
                     border: 1px solid ${unit.enhancement ? '#8b5cf6' : '#666'};
                     color: ${unit.enhancement ? '#fff' : '#aaa'};
                     border-radius: 3px; cursor: pointer;">
        ${unit.enhancement ? 'âš¡' + unit.enhancement.substring(0, 4) : 'âš¡å¼·åŒ–'}
      </button>` : '';

    return `
      <div class="roster-item" style="display: flex; align-items: center; flex-wrap: wrap;">
        <span style="flex: 1;">${unit.name} (${unit.points}é»)</span>
        ${warlordBtn}${enhanceBtn}
        <button class="remove-btn" onclick="removeFromRoster(${player}, ${i})">Ã—</button>
      </div>
    `;
  }).join("");

  // é¡¯ç¤ºä¸»å°‡æé†’
  if (roster.length > 0 && !hasWarlord) {
    const charCount = roster.filter(u => u.keywords?.includes("Character")).length;
    if (charCount > 0) {
      container.innerHTML += `<div style="color: #fbbf24; font-size: 11px; padding: 4px; text-align: center;">
        âš ï¸ è«‹é¸æ“‡ä¸€ä½è§’è‰²å–®ä½ä½œç‚ºä¸»å°‡
      </div>`;
    }
  }
}

// ===== ä¸»å°‡ç³»çµ± =====
function setWarlord(player, index) {
  const roster = armyRosters[player];

  // å…ˆæ¸…é™¤å…¶ä»–ä¸»å°‡
  roster.forEach(u => u.isWarlord = false);

  // è¨­å®šæ–°ä¸»å°‡
  if (roster[index].keywords?.includes("Character")) {
    roster[index].isWarlord = true;
    console.log(`[Warlord] ç©å®¶${player}çš„ä¸»å°‡: ${roster[index].name}`);
  }

  updateRosterDisplay(player);
  syncArmyToFirebase(player);
}

// ===== å¼·åŒ–ç³»çµ± (Enhancements) =====
// æ¯å€‹Detachmentæœ‰ä¸åŒçš„å¼·åŒ–é¸é …
const ENHANCEMENTS = {
  "necrons": {
    "awakened-dynasty": [
      { name: "è¶…è¶Šæ™‚é–“", points: 25, desc: "è©²å–®ä½æ¯å›åˆå¯é‡æ“²1é¡†å‘½ä¸­éª°å’Œ1é¡†å‚·å®³éª°" },
      { name: "ç›¸ä½è­·ç›¾", points: 20, desc: "ç²å¾—4+ç„¡æ•µè±å…" },
      { name: "æ´»é‡‘å±¬å·”å³°", points: 15, desc: "æ´»é‡‘å±¬èƒ½åŠ›æ¯å›åˆæ¢å¾©D3å‚·å£è€Œé1å‚·å£" },
      { name: "æŒ‡æ®å”è­°", points: 10, desc: "6\"å…§å‹è»å–®ä½+1é ˜å°å€¼" }
    ],
    "hypercrypt-legion": [
      { name: "ç¶­åº¦è·³èºè€…", points: 25, desc: "å¯åœ¨ä»»ä½•éšæ®µé€²è¡Œå‚³é€" },
      { name: "æ™‚é–“éŒ¨", points: 20, desc: "è¢«æ¶ˆæ»…æ™‚æ“²D6ï¼Œ4+å¾©æ´»æ–¼å·±æ–¹éƒ¨ç½²å€" }
    ]
  },
  "tyranids": {
    "invasion-fleet": [
      { name: "é©æ‡‰é€²åŒ–", points: 25, desc: "æ¯å›åˆå¯é¸æ“‡ä¸€å€‹æ­¦å™¨é—œéµå­—ç²å¾—" },
      { name: "é ‚ç´šæ é£Ÿè€…", points: 20, desc: "è¡é‹’éšæ®µ+1æ”»æ“Šå’Œ+1å‚·å®³" },
      { name: "å‚¬çœ å‡è¦–", points: 15, desc: "3\"å…§æ•µè»-1å‘½ä¸­" },
      { name: "èŸ²ç¾¤ä¹‹è²", points: 10, desc: "èŸ²ç¾¤å–®ä½6\"å…§é‡æ“²è¡é‹’è·é›¢" }
    ],
    "vanguard-onslaught": [
      { name: "ç”Ÿç‰©å‹æ…‹", points: 25, desc: "+1éŸŒæ€§å’Œ+1å‚·å£" },
      { name: "æ½›è¡ŒåŸºå› ", points: 15, desc: "ç²å¾—éš±åŒ¿å’Œç¨è¡Œè€…èƒ½åŠ›" }
    ]
  }
};

function showEnhancementMenu(player, index) {
  const roster = armyRosters[player];
  const unit = roster[index];

  // æª¢æŸ¥æ˜¯å¦å·²æœ‰å…¶ä»–å–®ä½ä½¿ç”¨å¼·åŒ–
  const enhancedUnits = roster.filter((u, i) => u.enhancement && i !== index);

  // ç²å–ç•¶å‰é™£ç‡Ÿå’Œæµæ´¾
  const factionSelect = document.getElementById(`p${player}Faction`);
  const detachmentSelect = document.getElementById(`p${player}Detachment`);
  const faction = factionSelect?.value;
  const detachment = detachmentSelect?.value;

  const enhancements = ENHANCEMENTS[faction]?.[detachment] || [];

  if (enhancements.length === 0) {
    alert("è©²æµæ´¾æ²’æœ‰å¯ç”¨çš„å¼·åŒ–é¸é …");
    return;
  }

  // éæ¿¾å·²è¢«ä½¿ç”¨çš„å¼·åŒ–
  const usedEnhancements = enhancedUnits.map(u => u.enhancement);
  const availableEnhancements = enhancements.filter(e => !usedEnhancements.includes(e.name));

  if (availableEnhancements.length === 0 && !unit.enhancement) {
    alert("æ‰€æœ‰å¼·åŒ–éƒ½å·²è¢«ä½¿ç”¨ï¼æ¯å€‹å¼·åŒ–åªèƒ½ä½¿ç”¨ä¸€æ¬¡");
    return;
  }

  // å»ºç«‹é¸å–®
  let menuHtml = `<div style="font-weight: bold; margin-bottom: 8px;">é¸æ“‡å¼·åŒ– - ${unit.name}</div>`;

  if (unit.enhancement) {
    menuHtml += `<button onclick="removeEnhancement(${player}, ${index})"
                  style="width: 100%; margin-bottom: 8px; padding: 6px; background: #ef4444; border: none; color: white; cursor: pointer; border-radius: 4px;">
                  ç§»é™¤å¼·åŒ–: ${unit.enhancement}
                </button>`;
  }

  for (const e of availableEnhancements) {
    menuHtml += `<button onclick="applyEnhancement(${player}, ${index}, '${e.name}', ${e.points})"
                  style="width: 100%; margin-bottom: 4px; padding: 6px; background: #8b5cf6; border: none; color: white; cursor: pointer; border-radius: 4px; text-align: left;">
                  <b>${e.name}</b> (+${e.points}é»)<br>
                  <small style="opacity: 0.8;">${e.desc}</small>
                </button>`;
  }

  // é¡¯ç¤ºå½ˆçª—
  const popup = document.createElement('div');
  popup.id = 'enhancementPopup';
  popup.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: #1a1a2e; padding: 16px; border-radius: 8px; border: 2px solid #8b5cf6;
    z-index: 10000; max-width: 300px; max-height: 400px; overflow-y: auto;`;
  popup.innerHTML = menuHtml + `<button onclick="document.getElementById('enhancementPopup').remove()"
    style="width: 100%; margin-top: 8px; padding: 6px; background: #666; border: none; color: white; cursor: pointer; border-radius: 4px;">
    å–æ¶ˆ
  </button>`;
  document.body.appendChild(popup);
}

function applyEnhancement(player, index, enhancementName, points) {
  const roster = armyRosters[player];
  roster[index].enhancement = enhancementName;
  roster[index].enhancementPoints = points;

  document.getElementById('enhancementPopup')?.remove();
  updateRosterDisplay(player);
  syncArmyToFirebase(player);
}

function removeEnhancement(player, index) {
  const roster = armyRosters[player];
  delete roster[index].enhancement;
  delete roster[index].enhancementPoints;

  document.getElementById('enhancementPopup')?.remove();
  updateRosterDisplay(player);
  syncArmyToFirebase(player);
}

// é¡¯ç¤ºå°æ‰‹çš„è»éšŠï¼ˆç·šä¸Šæ¨¡å¼ï¼Œè¨­å®šéšæ®µï¼‰
function displayOpponentArmy(player, armyData) {
  if (!armyData || !armyData.roster) return;

  const container = document.getElementById(`p${player}Roster`);
  const pointsDisplay = document.getElementById(`p${player}Points`);
  if (!container || !pointsDisplay) return;

  const roster = armyData.roster;
  const totalPoints = roster.reduce((sum, u) => sum + (u.points || 0), 0);
  pointsDisplay.textContent = totalPoints;

  // é¡¯ç¤ºå°æ‰‹è»éšŠï¼ˆä¸å¯ç·¨è¼¯ï¼‰
  container.innerHTML = roster.map((unit) => `
    <div class="roster-item" style="opacity: 0.8;">
      <span>ğŸ‘¤ ${unit.name} (${unit.points}é»)</span>
    </div>
  `).join("");

  // æ›´æ–°é™£ç‡Ÿå’Œç¨®æ—è¦å‰‡é¡¯ç¤º
  const factionSelect = document.getElementById(`p${player}Faction`);
  if (factionSelect && armyData.faction) {
    factionSelect.value = armyData.faction;
    // è§¸ç™¼é™£ç‡Ÿè®Šæ›´ä»¥æ›´æ–°ç¨®æ—è¦å‰‡é¸é …
    if (typeof updateDetachmentOptions === 'function') {
      updateDetachmentOptions(player);
    }
  }

  const detachmentSelect = document.getElementById(`p${player}Detachment`);
  if (detachmentSelect && armyData.detachment) {
    detachmentSelect.value = armyData.detachment;
  }
}

function checkStartButton() {
  const btn = document.getElementById("startGameBtn");

  if (isOnlineMode) {
    // ç·šä¸Šæ¨¡å¼ï¼šæˆ¿ä¸»åªéœ€è¦è‡ªå·±æœ‰å–®ä½ï¼Œä¸”å°æ‰‹å·²åŠ å…¥
    if (isHost) {
      btn.disabled = !(armyRosters[1].length > 0 && currentRoomCode);
    } else {
      // åŠ å…¥è€…ä¸èƒ½é»é–‹å§‹æŒ‰éˆ•
      btn.disabled = true;
    }
  } else {
    // æœ¬åœ°æ¨¡å¼ï¼šé›™æ–¹éƒ½è¦æœ‰å–®ä½
    btn.disabled = !(armyRosters[1].length > 0 && armyRosters[2].length > 0);
  }
}

// ========== é–‹å§‹æˆ°é¬¥ ==========
function startBattle() {
  // ç·šä¸Šæ¨¡å¼ï¼šåªæœ‰æˆ¿ä¸»èƒ½é–‹å§‹
  if (isOnlineMode && !isHost) {
    alert('ç­‰å¾…æˆ¿ä¸»é–‹å§‹éŠæˆ²');
    return;
  }

  // ç·šä¸Šæ¨¡å¼ï¼šæª¢æŸ¥ä¸¦è¼‰å…¥å°æ‰‹è»éšŠ
  if (isOnlineMode && roomRef) {
    // ç¢ºä¿è‡ªå·±çš„è»éšŠå·²åŒæ­¥ï¼ˆä»¥é˜²è¬ä¸€ï¼‰
    syncArmyToFirebase(1);

    roomRef.child('status').set('playing');
    roomRef.child('gameStarted').set(true);

    // åŒæ­¥æˆ°å ´è¨­å®šçµ¦ç©å®¶äºŒ
    roomRef.child('battlefieldSettings').set({
      size: selectedBattlefieldSize,
      map: selectedMapScenario
    });

    // è¼‰å…¥å°æ‰‹è»éšŠè³‡æ–™ï¼ˆæ‡‰è©²å·²ç¶“å³æ™‚åŒæ­¥äº†ï¼‰
    roomRef.child('armies/2').once('value').then((snapshot) => {
      if (snapshot.exists()) {
        const enemyArmy = snapshot.val();
        loadEnemyArmy(enemyArmy, 2);
        continueStartBattle();
      } else {
        alert('å°æ‰‹å°šæœªé…ç½®è»éšŠï¼Œè«‹ç­‰å¾…å°æ‰‹å®Œæˆé…ç½®');
      }
    });
    return;
  }

  continueStartBattle();
}

function loadEnemyArmy(armyData, player) {
  if (!armyData || !armyData.roster) return;

  armyRosters[player] = armyData.roster;
  console.warn('[loadEnemyArmy] è¼‰å…¥ç©å®¶', player, 'è»éšŠ:', armyData.roster.length, 'å€‹å–®ä½');

  // è¨­å®šå°æ‰‹çš„é™£ç‡Ÿ
  const factionSelect = document.getElementById(`p${player}Faction`);
  if (factionSelect && armyData.faction) {
    factionSelect.value = armyData.faction;
    updateDetachmentOptions(player);  // æ›´æ–°ç¨®æ—è¦å‰‡é¸é …
  }

  // è¨­å®šå°æ‰‹çš„ç¨®æ—è¦å‰‡
  const detachmentSelect = document.getElementById(`p${player}Detachment`);
  if (detachmentSelect && armyData.detachment) {
    detachmentSelect.value = armyData.detachment;
    selectDetachment(player);  // æ‡‰ç”¨ç¨®æ—è¦å‰‡
    console.warn('[loadEnemyArmy] è¼‰å…¥ç©å®¶', player, 'ç¨®æ—è¦å‰‡:', armyData.detachment);
  }
}

function continueStartBattle() {
  document.getElementById("setupScreen").style.display = "none";
  document.getElementById("gameScreen").classList.add("active");

  resizeCanvas();
  initBattlefield();
  gameInitialized = true;  // æ¨™è¨˜éŠæˆ²å·²åˆå§‹åŒ–å®Œæˆ
  console.warn('[Host] éŠæˆ²åˆå§‹åŒ–å®Œæˆï¼Œå–®ä½æ•¸é‡:', gameState.units.length);

  gameState.phase = "command";
  gameState.round = 1;
  gameState.currentPlayer = 1;

  // æ›´æ–°AIç‹€æ…‹
  ai1Enabled = document.getElementById("ai1ModeToggle")?.checked ?? false;
  ai2Enabled = document.getElementById("aiModeToggle")?.checked ?? true;
  aiDifficulty = getAIDifficulty();
  enableDiceAnimation = document.getElementById("diceAnimToggle")?.checked ?? true;

  const aiIndicator = document.getElementById("aiIndicator");
  if (aiIndicator) {
    if (ai1Enabled && ai2Enabled) {
      aiIndicator.textContent = "ğŸ¤– VS ğŸ¤– è‡ªå‹•å°æˆ°";
      aiIndicator.style.display = "inline";
      aiIndicator.style.background = "linear-gradient(90deg, var(--blue), var(--red))";
    } else if (ai1Enabled || ai2Enabled) {
      aiIndicator.textContent = "ğŸ¤– AIæ¨¡å¼";
      aiIndicator.style.display = "inline";
      aiIndicator.style.background = "var(--red)";
    } else {
      aiIndicator.style.display = "none";
    }
  }

  // ç¢ºä¿ç¨®æ—è¦å‰‡å·²é¸æ“‡
  selectDetachment(1);
  selectDetachment(2);

  updatePhaseDisplay();
  log("=== æˆ°é¬¥é–‹å§‹ ===", "phase");

  // é¡¯ç¤ºé›™æ–¹ç¨®æ—è¦å‰‡
  if (playerDetachments[1]) {
    log(`ç©å®¶ä¸€ç¨®æ—è¦å‰‡: ${playerDetachments[1].name}`, "info");
  }
  if (playerDetachments[2]) {
    log(`ç©å®¶äºŒç¨®æ—è¦å‰‡: ${playerDetachments[2].name}`, "info");
  }

  // é¡¯ç¤ºç•¶å‰ç¨®æ—è¦å‰‡
  const det = playerDetachments[1];
  document.getElementById("currentDetachment").textContent = det ? det.name : "";

  if (ai1Enabled && ai2Enabled) {
    log(`ğŸ¤– VS ğŸ¤– AIè‡ªå‹•å°æˆ°æ¨¡å¼`, "phase");
    log(`é›£åº¦: ${aiDifficulty === "easy" ? "ç°¡å–®" : aiDifficulty === "normal" ? "æ™®é€š" : "å›°é›£"}`, "info");
  } else {
    log(`å›åˆ 1 - ${ai1Enabled ? "AI-1" : "ç©å®¶ä¸€"} å…ˆæ”»`, "info");
    if (ai2Enabled) log(`ğŸ¤– å°æ‰‹AIé›£åº¦: ${aiDifficulty === "easy" ? "ç°¡å–®" : aiDifficulty === "normal" ? "æ™®é€š" : "å›°é›£"}`, "info");
  }

  // é€²å…¥éƒ¨ç½²éšæ®µ
  startDeployPhase();
  render();
}

// ========== éƒ¨ç½²éšæ®µç³»çµ± ==========
function startDeployPhase() {
  gameState.phase = "deployment";
  gameState.deploy = {
    deployingPlayer: 1,
    p1Deployed: false,
    p2Deployed: false
  };

  // éš±è—æ‰€æœ‰å–®ä½ï¼ˆå°šæœªéƒ¨ç½²ï¼‰
  gameState.units.forEach(u => {
    u.deployed = false;
    u.visible = false;
  });

  updatePhaseDisplay();
  updateDeployButtons();
  updateCPDisplay();
  updateUnitLists();
  log("=== éƒ¨ç½²éšæ®µ ===", "phase");
  log("ç©å®¶ä¸€å…ˆéƒ¨ç½²å–®ä½", "info");
  log("é»æ“Šå·¦å´éƒ¨ç½²å€æ”¾ç½®å–®ä½", "info");

  // ç·šä¸Šæ¨¡å¼ï¼šç«‹å³åŒæ­¥åˆå§‹ç‹€æ…‹
  if (isOnlineMode) {
    syncGameStateToFirebase();
  }

  // å¦‚æœæ˜¯AIç©å®¶ï¼Œè‡ªå‹•éƒ¨ç½²
  if (ai1Enabled) {
    setTimeout(() => autoDeployIfNeeded(), 500);
  }
}

function updateDeployButtons() {
  const btnStartRound = document.getElementById("btnStartRound");
  const btnSwitchDeploy = document.getElementById("btnSwitchDeploy");
  const btnNextPhase = document.getElementById("btnNextPhase");

  if (gameState.phase === "deployment") {
    btnStartRound.style.display = "inline-block";
    btnSwitchDeploy.style.display = "inline-block";
    btnNextPhase.style.display = "none";

    // åªæœ‰é›™æ–¹éƒ½è‡³å°‘éƒ¨ç½²ä¸€å€‹å–®ä½å¾Œæ‰èƒ½é–‹å§‹
    const p1HasDeployed = gameState.units.some(u => u.player === 1 && u.deployed);
    const p2HasDeployed = gameState.units.some(u => u.player === 2 && u.deployed);
    btnStartRound.disabled = !(p1HasDeployed && p2HasDeployed);
  } else {
    btnStartRound.style.display = "none";
    btnSwitchDeploy.style.display = "none";
    btnNextPhase.style.display = "inline-block";
  }
}

function switchDeploySide() {
  gameState.deploy.deployingPlayer = gameState.deploy.deployingPlayer === 1 ? 2 : 1;
  const player = gameState.deploy.deployingPlayer;
  log(`åˆ‡æ›åˆ°ç©å®¶${player === 1 ? "ä¸€" : "äºŒ"}éƒ¨ç½²`, "info");
  playSound('click');

  // å¦‚æœåˆ‡æ›åˆ°çš„æ˜¯AIç©å®¶ï¼Œè‡ªå‹•éƒ¨ç½²
  if ((player === 1 && ai1Enabled) || (player === 2 && ai2Enabled)) {
    setTimeout(() => autoDeployIfNeeded(), 500);
  }

  updateDeployButtons();
  updateUnitLists();
  render();
}

function autoDeployIfNeeded() {
  const player = gameState.deploy.deployingPlayer;
  const undeployed = gameState.units.filter(u => u.player === player && !u.deployed);

  if (undeployed.length === 0) return;

  const w = gameState.canvasWidth || 600;
  const h = gameState.canvasHeight || 440;
  const deployZoneWidth = gameState.deployZone || inchToPixels(12);

  // ç¢ºä¿éƒ¨ç½²å€åŸŸæœ‰æ•ˆ
  if (w <= 0 || h <= 0 || deployZoneWidth <= 0) {
    console.error("Invalid deployment zone dimensions", { w, h, deployZoneWidth });
    return;
  }

  // ä½¿ç”¨æ™ºèƒ½éƒ¨ç½²ç³»çµ±
  smartDeployUnits(undeployed, player, deployZoneWidth, w, h);

  log(`AIè‡ªå‹•éƒ¨ç½²äº†${undeployed.length}å€‹å–®ä½`, "info");

  if (player === 1) {
    gameState.deploy.p1Deployed = true;
  } else {
    gameState.deploy.p2Deployed = true;
  }

  updateDeployButtons();
  updateUnitLists();
  render();

  // ç·šä¸Šæ¨¡å¼ï¼šåŒæ­¥AIéƒ¨ç½²çµæœ
  if (isOnlineMode) {
    syncGameStateToFirebase();
  }

  // å¦‚æœå…©é‚Šéƒ½æ˜¯AIä¸”éƒ½å·²éƒ¨ç½²ï¼Œè‡ªå‹•é–‹å§‹
  if (ai1Enabled && ai2Enabled && gameState.deploy.p1Deployed && gameState.deploy.p2Deployed) {
    setTimeout(() => finishDeploymentAndStart(), 1000);
  }
}

function handleDeployClick(canvasX, canvasY) {
  const w = gameState.canvasWidth || canvas.getBoundingClientRect().width;
  const deployZoneWidth = gameState.deployZone || inchToPixels(12);

  // ç·šä¸Šæ¨¡å¼ï¼šæ¯å€‹ç©å®¶åªèƒ½éƒ¨ç½²è‡ªå·±çš„å–®ä½
  // æœ¬åœ°æ¨¡å¼ï¼šæ ¹æ“šç•¶å‰éƒ¨ç½²ç©å®¶
  let player;
  if (isOnlineMode) {
    player = onlinePlayerId;
  } else {
    player = gameState.deploy.deployingPlayer;
  }

  // ä½¿ç”¨é¸ä¸­çš„å–®ä½éƒ¨ç½²ï¼ˆå¦‚æœæœ‰é¸ä¸­ä¸”æœªéƒ¨ç½²ï¼‰
  let unitToDeploy = gameState.selectedUnitForDeploy;

  // ===== Infiltratorsï¼ˆæ»²é€è€…ï¼‰è¦å‰‡ - å®˜æ–¹10ç‰ˆ =====
  // æœ‰æ»²é€è€…èƒ½åŠ›çš„å–®ä½å¯ä»¥éƒ¨ç½²åœ¨ä»»ä½•åœ°æ–¹ï¼Œä½†å¿…é ˆè·é›¢æ•µäºº9"ä»¥ä¸Š
  const hasInfiltrators = unitToDeploy?.abilities?.some(a =>
    a.includes("æ»²é€") || a.includes("Infiltrators") || a.includes("æ½›å…¥") || a.includes("ä¼æ“Š")
  );

  // æª¢æŸ¥æ˜¯å¦åœ¨æ­£ç¢ºçš„éƒ¨ç½²å€å…§
  let inDeployZone = false;
  if (hasInfiltrators) {
    // æ»²é€è€…å¯ä»¥éƒ¨ç½²åœ¨ä»»ä½•åœ°æ–¹ï¼Œä½†éœ€æª¢æŸ¥è·é›¢æ•µäºº9"
    inDeployZone = true;
    const enemies = gameState.units.filter(u => u.deployed && u.player !== player);
    const unitSize = getUnitBaseSize(unitToDeploy);
    for (const enemy of enemies) {
      const enemySize = getUnitBaseSize(enemy);
      const dist = Math.hypot(canvasX - enemy.x, canvasY - enemy.y) - unitSize - enemySize;
      if (dist < inchToPixels(9)) {
        log(`âŒ æ»²é€è€…éƒ¨ç½²ä½ç½®è·é›¢ ${enemy.name} åªæœ‰ ${pixelsToInch(dist).toFixed(1)}"ï¼ˆéœ€ 9"+ï¼‰`, "miss");
        return;
      }
    }
    log(`[æ»²é€è€…] ${unitToDeploy.name} å¯ä»¥åœ¨æ•µäºº9"å¤–ä»»æ„ä½ç½®éƒ¨ç½²`, "info");
  } else if (player === 1 && canvasX < deployZoneWidth) {
    inDeployZone = true;
  } else if (player === 2 && canvasX > w - deployZoneWidth) {
    inDeployZone = true;
  }
  if (!inDeployZone) {
    log(`è«‹åœ¨ç©å®¶${player === 1 ? "ä¸€ï¼ˆå·¦å´ï¼‰" : "äºŒï¼ˆå³å´ï¼‰"}çš„éƒ¨ç½²å€å…§é»æ“Š`, "info");
    return;
  }
  if (!unitToDeploy || unitToDeploy.deployed || unitToDeploy.player !== player) {
    // æ‰¾ä¸‹ä¸€å€‹æœªéƒ¨ç½²çš„å–®ä½
    unitToDeploy = gameState.units.find(u => u.player === player && !u.deployed);
  }

  if (!unitToDeploy) {
    log(`ç©å®¶${player === 1 ? "ä¸€" : "äºŒ"}æ‰€æœ‰å–®ä½å·²éƒ¨ç½²`, "info");
    return;
  }

  // å¸é™„åˆ°ç¶²æ ¼
  const snapped = snapToGrid(canvasX, canvasY);

  // æª¢æŸ¥æ˜¯å¦åœ¨åœ°åœ–é‚Šç•Œå…§
  const baseSize = getUnitBaseSize(unitToDeploy);
  const h = gameState.canvasHeight || 440;
  const margin = baseSize + 5;
  if (snapped.x < margin || snapped.x > w - margin || snapped.y < margin || snapped.y > h - margin) {
    log(`âŒ éƒ¨ç½²ä½ç½®è¶…å‡ºåœ°åœ–é‚Šç•Œï¼`, "miss");
    return;
  }

  // æª¢æŸ¥æ˜¯å¦èˆ‡å·²éƒ¨ç½²å–®ä½é‡ç–Šï¼ˆè€ƒæ…®å°éšŠå±•é–‹ç¯„åœï¼‰
  const deployedUnits = gameState.units.filter(u => u.deployed);
  if (!isPositionValid(snapped.x, snapped.y, baseSize, deployedUnits, 10, unitToDeploy)) {
    log(`æ­¤ä½ç½®èˆ‡å…¶ä»–å–®ä½é‡ç–Šï¼Œè«‹é¸æ“‡å…¶ä»–ä½ç½®`, "info");
    return;
  }

  // éƒ¨ç½²å–®ä½
  unitToDeploy.x = snapped.x;
  unitToDeploy.y = snapped.y;
  unitToDeploy.deployed = true;
  unitToDeploy.visible = true;

  // å°éšŠå–®ä½ï¼šæ›´æ–°æ¨¡å‹ä½ç½®
  updateSquadModelPositions(unitToDeploy);
  if (unitToDeploy.isSquad) {
    log(`${unitToDeploy.name} (${unitToDeploy.modelCount}æ¨¡å‹) å·²éƒ¨ç½²`, "info");
  } else {
    log(`${unitToDeploy.name} å·²éƒ¨ç½²`, "info");
  }

  playSound('click');

  // æ¸…é™¤é¸ä¸­çš„éƒ¨ç½²å–®ä½
  gameState.selectedUnitForDeploy = null;

  // ç·šä¸Šæ¨¡å¼åŒæ­¥éƒ¨ç½²ï¼ˆæ¯æ¬¡éƒ¨ç½²éƒ½åŒæ­¥å®Œæ•´ç‹€æ…‹ï¼‰
  if (isOnlineMode) {
    sendAction({ type: 'deploy', unitId: undeployed.id, x: canvasX, y: canvasY });
    // ç«‹å³åŒæ­¥éŠæˆ²ç‹€æ…‹ç¢ºä¿å°æ–¹çœ‹åˆ°
    syncGameStateToFirebase();
  }

  if (player === 1) {
    gameState.deploy.p1Deployed = true;
  } else {
    gameState.deploy.p2Deployed = true;
  }

  // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰å·±æ–¹å–®ä½éƒ½å·²éƒ¨ç½²
  const myUndeployed = gameState.units.filter(u => u.player === player && !u.deployed);
  if (myUndeployed.length === 0) {
    log(`ç©å®¶${player === 1 ? "ä¸€" : "äºŒ"}æ‰€æœ‰å–®ä½å·²å®Œæˆéƒ¨ç½²ï¼`, "phase");
    // ç·šä¸Šæ¨¡å¼åŒæ­¥éƒ¨ç½²å®Œæˆç‹€æ…‹
    if (isOnlineMode) {
      syncGameStateToFirebase();
    }
  }

  updateDeployButtons();
  updateUnitLists();
  render();
}

async function finishDeploymentAndStart() {
  // ç¢ºä¿æ‰€æœ‰å–®ä½éƒ½å·²éƒ¨ç½²ï¼ˆè‡ªå‹•éƒ¨ç½²å‰©é¤˜å–®ä½ï¼‰
  const w = gameState.canvasWidth || 600;
  const h = gameState.canvasHeight || 440;
  const deployZoneWidth = gameState.deployZone || inchToPixels(12);

  // åˆ†åˆ¥è™•ç†å…©é‚Šæœªéƒ¨ç½²çš„å–®ä½
  const undeployedP1 = gameState.units.filter(u => u.player === 1 && !u.deployed);
  const undeployedP2 = gameState.units.filter(u => u.player === 2 && !u.deployed);

  if (undeployedP1.length > 0) {
    smartDeployUnits(undeployedP1, 1, deployZoneWidth, w, h);
  }
  if (undeployedP2.length > 0) {
    smartDeployUnits(undeployedP2, 2, deployZoneWidth, w, h);
  }

  log("=== éƒ¨ç½²å®Œæˆ ===", "phase");

  // ===== Scoutsï¼ˆæ–¥å€™ï¼‰ç§»å‹• - å®˜æ–¹10ç‰ˆè¦å‰‡ =====
  // éƒ¨ç½²å®Œæˆå¾Œã€ç¬¬ä¸€å›åˆé–‹å§‹å‰ï¼Œæœ‰æ–¥å€™èƒ½åŠ›çš„å–®ä½å¯ä»¥ç§»å‹•
  await performScoutMoves();

  log("=== é–‹å§‹ç¬¬ä¸€å›åˆ ===", "phase");

  // åˆå§‹åŒ–ä»»å‹™ç³»çµ±
  initMissionSystem();

  // é€²å…¥æŒ‡æ®éšæ®µ
  gameState.phase = "command";
  gameState.round = 1;
  gameState.currentPlayer = 1;

  updateDeployButtons();
  updateUnitLists();
  render();

  // é–‹å§‹ç¬¬ä¸€å›åˆ
  if (ai1Enabled) {
    // AIæ§åˆ¶ï¼šç›´æ¥åŸ·è¡ŒAIå›åˆ
    setTimeout(() => runAITurn(), 1000);
  } else {
    // ç©å®¶æ§åˆ¶ï¼šåŸ·è¡ŒæŒ‡æ®éšæ®µ
    startCommandPhase();
  }
}

// ===== Scoutsï¼ˆæ–¥å€™ï¼‰ç§»å‹• - å®˜æ–¹10ç‰ˆè¦å‰‡ =====
// éƒ¨ç½²å®Œæˆå¾Œã€ç¬¬ä¸€å›åˆé–‹å§‹å‰ï¼Œæœ‰æ–¥å€™èƒ½åŠ›çš„å–®ä½å¯ä»¥ç§»å‹• X"
async function performScoutMoves() {
  // æ‰¾å‡ºæ‰€æœ‰æœ‰æ–¥å€™èƒ½åŠ›çš„å–®ä½
  const scoutUnits = gameState.units.filter(unit => {
    if (!unit.alive || !unit.deployed) return false;

    // è§£æ Scouts X" èƒ½åŠ›
    const scoutAbility = unit.abilities?.find(a =>
      a.includes("æ–¥å€™") || a.includes("Scouts") || a.includes("åµå¯Ÿ")
    );
    return !!scoutAbility;
  });

  if (scoutUnits.length === 0) return;

  log("ã€æ–¥å€™ç§»å‹•éšæ®µã€‘", "phase");

  for (const unit of scoutUnits) {
    // è§£ææ–¥å€™ç§»å‹•è·é›¢
    let scoutDistance = 6;  // é»˜èª6"
    const scoutAbility = unit.abilities?.find(a =>
      a.includes("æ–¥å€™") || a.includes("Scouts") || a.includes("åµå¯Ÿ")
    );
    if (scoutAbility) {
      const match = scoutAbility.match(/(\d+)/);
      if (match) {
        scoutDistance = parseInt(match[1]);
      }
    }

    const isAI = (unit.player === 1 && ai1Enabled) || (unit.player === 2 && ai2Enabled);

    if (isAI) {
      // AIè‡ªå‹•åŸ·è¡Œæ–¥å€™ç§»å‹•
      await performAIScoutMove(unit, scoutDistance);
    } else {
      // ç©å®¶æ‰‹å‹•ç§»å‹•ï¼ˆç°¡åŒ–ï¼šç›®å‰è‡ªå‹•ç§»å‹•å‘æœ€è¿‘ç›®æ¨™ï¼‰
      await performAutoScoutMove(unit, scoutDistance);
    }
  }

  render();
  await new Promise(r => setTimeout(r, 500));
}

// AIæ–¥å€™ç§»å‹•ï¼šå‘æœ€è¿‘çš„ç›®æ¨™é»ç§»å‹•
async function performAIScoutMove(unit, maxDistance) {
  const unitSize = getUnitBaseSize(unit);
  const maxDist = inchToPixels(maxDistance);

  // æ‰¾æœ€è¿‘çš„ç›®æ¨™é»
  let targetX = unit.x;
  let targetY = unit.y;
  let bestDist = Infinity;

  for (const obj of gameState.objectives) {
    const dist = Math.hypot(obj.x - unit.x, obj.y - unit.y);
    if (dist < bestDist) {
      bestDist = dist;
      targetX = obj.x;
      targetY = obj.y;
    }
  }

  // è¨ˆç®—ç§»å‹•æ–¹å‘
  const angle = Math.atan2(targetY - unit.y, targetX - unit.x);
  const moveDist = Math.min(maxDist, bestDist - inchToPixels(3));

  if (moveDist > 0) {
    const newX = unit.x + Math.cos(angle) * moveDist;
    const newY = unit.y + Math.sin(angle) * moveDist;

    // æª¢æŸ¥ä¸èƒ½é€²å…¥æ•µäºº9"ç¯„åœ
    const enemies = gameState.units.filter(u => u.alive && u.player !== unit.player);
    let validPosition = true;
    for (const enemy of enemies) {
      const enemyDist = Math.hypot(newX - enemy.x, newY - enemy.y);
      if (enemyDist < inchToPixels(9)) {
        validPosition = false;
        break;
      }
    }

    if (validPosition) {
      unit.x = newX;
      unit.y = newY;
      log(`ğŸƒ ${unit.name} æ–¥å€™ç§»å‹• ${pixelsToInch(moveDist).toFixed(1)}"`, "info");
    }
  }
}

// è‡ªå‹•æ–¥å€™ç§»å‹•ï¼ˆéAIç©å®¶ä¹Ÿè‡ªå‹•ç§»å‹•ï¼‰
async function performAutoScoutMove(unit, maxDistance) {
  await performAIScoutMove(unit, maxDistance);
}

// ========== CPç³»çµ± ==========
function updateCPDisplay() {
  const p1CP = document.getElementById("p1CPDisplay");
  const p2CP = document.getElementById("p2CPDisplay");
  const cpDisplay = document.getElementById("cpDisplay");

  if (p1CP) p1CP.textContent = gameState.cp[1];
  if (p2CP) p2CP.textContent = gameState.cp[2];
  if (cpDisplay) cpDisplay.textContent = gameState.cp[gameState.currentPlayer];

  // æ›´æ–°é‡æ“²æŒ‰éˆ•ç‹€æ…‹
  const btnReroll = document.getElementById("btnReroll");
  if (btnReroll) {
    btnReroll.disabled = gameState.cp[gameState.currentPlayer] < 1;
  }
}

function gainCPAtCommandStart() {
  // é›™æ–¹å„+1 CP
  gameState.cp[1] += 1;
  gameState.cp[2] += 1;
  log(`é›™æ–¹å„ç²å¾— 1 CP (ç©å®¶ä¸€: ${gameState.cp[1]}, ç©å®¶äºŒ: ${gameState.cp[2]})`, "info");
  updateCPDisplay();
}

function spendCP(player, amount) {
  if (gameState.cp[player] >= amount) {
    gameState.cp[player] -= amount;
    updateCPDisplay();
    return true;
  }
  return false;
}

function useCommandReroll() {
  const player = gameState.currentPlayer;
  if (gameState.cp[player] < 1) {
    log("CPä¸è¶³ï¼Œç„¡æ³•ä½¿ç”¨æŒ‡æ®é‡æ“²", "info");
    return;
  }

  // æ¨™è¨˜ä¸‹ä¸€æ¬¡æ“²éª°å¯é‡æ“²
  gameState.pendingReroll = true;
  spendCP(player, 1);
  log(`ç©å®¶${player === 1 ? "ä¸€" : "äºŒ"}èŠ±è²»1CPï¼Œä¸‹æ¬¡æ“²éª°å¯é‡æ“²`, "special");
}

// ========== æˆ°ç•¥é¢æ¿ç³»çµ± ==========
function toggleStratagemPanel() {
  const panel = document.getElementById("stratagemPanel");
  const toggle = document.getElementById("stratagemToggle");
  if (panel.style.display === "none") {
    panel.style.display = "block";
    toggle.textContent = "â–²";
    updateStratagemPanel();
  } else {
    panel.style.display = "none";
    toggle.textContent = "â–¼";
  }
}

// ===== ä»»å‹™é¢æ¿ =====
function toggleMissionPanel() {
  const panel = document.getElementById("missionPanel");
  const toggle = document.getElementById("missionToggle");
  if (panel.style.display === "none") {
    panel.style.display = "block";
    toggle.textContent = "â–²";
    updateMissionUI();
  } else {
    panel.style.display = "none";
    toggle.textContent = "â–¼";
  }
}

function updateMissionUI() {
  const content = document.getElementById("missionContent");
  if (!content) return;

  let html = "";

  // ä¸»è¦ä»»å‹™
  if (gameState.primaryMission && PRIMARY_MISSIONS[gameState.primaryMission]) {
    const mission = PRIMARY_MISSIONS[gameState.primaryMission];
    html += `<div style="margin-bottom: 10px; padding: 8px; background: rgba(255,215,0,0.15); border-radius: 4px; border-left: 3px solid var(--gold);">
      <b style="color: var(--gold);">ğŸ“‹ ä¸»è¦ä»»å‹™: ${mission.name}</b><br>
      <small style="color: var(--muted);">${mission.description}</small>
    </div>`;
  }

  // æ¬¡è¦ä»»å‹™é¸æ“‡
  for (let player = 1; player <= 2; player++) {
    const selected = gameState.secondaryMissions[player] || [];
    const playerColor = player === 1 ? "var(--blue)" : "var(--red)";
    const playerName = player === 1 ? "ç©å®¶ä¸€" : "ç©å®¶äºŒ";

    html += `<div style="margin-bottom: 10px; padding: 6px; background: rgba(0,0,0,0.3); border-radius: 4px;">
      <b style="color: ${playerColor};">ğŸ“ ${playerName} æ¬¡è¦ä»»å‹™ (${selected.length}/3)</b><br>`;

    if (selected.length > 0) {
      for (const missionId of selected) {
        const mission = SECONDARY_MISSIONS[missionId];
        if (mission) {
          html += `<span style="display: inline-block; margin: 2px; padding: 2px 6px; background: rgba(255,255,255,0.1); border-radius: 3px; font-size: 10px;">${mission.name}</span>`;
        }
      }
    } else {
      html += `<small style="color: var(--muted);">å°šæœªé¸æ“‡æ¬¡è¦ä»»å‹™</small>`;
    }

    // å¦‚æœæ˜¯ç•¶å‰ç©å®¶ä¸”æœªé¸æ»¿ï¼Œé¡¯ç¤ºå¯é¸æ¬¡è¦ä»»å‹™
    if (gameState.currentPlayer === player && selected.length < 3 && gameState.phase !== "deployment") {
      html += `<div style="margin-top: 6px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 6px;">
        <small>å¯é¸æ“‡:</small><br>`;
      for (const [id, mission] of Object.entries(SECONDARY_MISSIONS)) {
        if (!selected.includes(id)) {
          html += `<button onclick="selectSecondaryMission(${player}, '${id}'); updateMissionUI();"
                   style="margin: 2px; padding: 2px 6px; font-size: 9px; background: rgba(100,100,100,0.5); border: 1px solid rgba(255,255,255,0.2); color: var(--txt); border-radius: 3px; cursor: pointer;"
                   title="${mission.description}">${mission.name} (+${mission.maxVP}VP)</button>`;
        }
      }
      html += `</div>`;
    }

    html += `</div>`;
  }

  content.innerHTML = html;
}

function updateStratagemPanel() {
  const panel = document.getElementById("stratagemList");
  const player = gameState.currentPlayer;

  // ç²å–ç•¶å‰ç©å®¶çš„æµæ´¾æˆ°ç•¥
  const faction = armyRosters[player]?.[0]?.faction;
  const detachment = playerDetachments[player]?.detachmentId;

  if (!faction || !detachment || !DETACHMENT_RULES[faction]?.[detachment]) {
    panel.innerHTML = '<p style="color: var(--muted); padding: 8px;">æœªé¸æ“‡æµæ´¾æˆ–ç„¡å¯ç”¨æˆ°ç•¥</p>';
    return;
  }

  const rules = DETACHMENT_RULES[faction][detachment];
  const stratagems = rules.stratagems || [];
  const currentCP = gameState.cp[player];

  let html = `<div style="padding: 4px 8px; background: rgba(251,191,36,0.1); border-radius: 4px; margin-bottom: 6px;">
    <b style="color: var(--gold);">${rules.name}</b>
    <div style="font-size: 10px; color: var(--muted);">${rules.description}</div>
  </div>`;

  const phaseNames = {
    command: "æŒ‡æ®", movement: "ç§»å‹•", shooting: "å°„æ“Š", charge: "è¡é‹’", fight: "è¿‘æˆ°"
  };
  const currentPhase = gameState.phase;

  if (stratagems.length === 0) {
    html += '<p style="color: var(--muted); padding: 4px;">æ­¤æµæ´¾ç„¡ç‰¹æ®Šæˆ°ç•¥</p>';
  } else {
    stratagems.forEach((s, i) => {
      const hasEnoughCP = currentCP >= s.cp;
      const phaseAllowed = !s.phases || s.phases.length === 0 || s.phases.includes(currentPhase);
      const canUse = hasEnoughCP && phaseAllowed;

      // é¡¯ç¤ºå¯ç”¨éšæ®µ
      const phaseText = s.phases ? s.phases.map(p => phaseNames[p] || p).join("/") : "å…¨éšæ®µ";
      const phaseColor = phaseAllowed ? "#22c55e" : "#ef4444";

      const btnClass = canUse ? 'background: rgba(34,197,94,0.2); border: 1px solid var(--green); cursor: pointer;' :
                                'background: rgba(100,100,100,0.2); border: 1px solid #555; cursor: not-allowed; opacity: 0.5;';
      html += `
        <div style="padding: 6px; margin: 4px 0; border-radius: 4px; ${btnClass}"
             onclick="${canUse ? `useStratagem(${i})` : ''}"
             title="${s.desc}">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <span style="font-weight: bold; color: ${canUse ? 'var(--gold)' : '#888'};">${s.name}</span>
            <span style="font-size: 10px; padding: 2px 6px; background: rgba(0,0,0,0.3); border-radius: 3px; color: ${hasEnoughCP ? 'var(--green)' : '#888'};">${s.cp} CP</span>
          </div>
          <div style="font-size: 9px; color: ${phaseColor}; margin-top: 2px;">ğŸ“ ${phaseText}éšæ®µ</div>
          <div style="font-size: 10px; color: ${canUse ? 'var(--txt)' : '#666'}; margin-top: 2px;">${s.desc}</div>
          ${!phaseAllowed ? '<div style="font-size: 9px; color: #ef4444;">âŒ éç•¶å‰éšæ®µ</div>' : ''}
          ${!hasEnoughCP ? '<div style="font-size: 9px; color: #ef4444;">âŒ CPä¸è¶³</div>' : ''}
        </div>`;
    });
  }

  panel.innerHTML = html;
}

function useStratagem(index) {
  const player = gameState.currentPlayer;
  const faction = armyRosters[player]?.[0]?.faction;
  const detachment = playerDetachments[player]?.detachmentId;
  const stratagems = DETACHMENT_RULES[faction]?.[detachment]?.stratagems;

  if (!stratagems || !stratagems[index]) return;

  const stratagem = stratagems[index];

  // ç‰¹æ®Šæˆ°ç•¥ï¼šæ°¸æ†äº¡è€…å”è­° - éœ€è¦å…ˆæª¢æŸ¥æ˜¯å¦æœ‰å¯å¾©æ´»çš„è§’è‰²
  if (stratagem.name === "æ°¸æ†äº¡è€…å”è­°") {
    const deadCharacters = gameState.units.filter(u =>
      u.player === player &&
      !u.alive &&
      u.keywords?.includes("Character")
    );
    if (deadCharacters.length === 0) {
      log("âŒ æ²’æœ‰å·²æ­»äº¡çš„è§’è‰²å¯å¾©æ´»ï¼", "info");
      return;
    }
  }

  if (!spendCP(player, stratagem.cp)) {
    log("CPä¸è¶³ï¼", "info");
    return;
  }

  playSound('click');

  // è¨˜éŒ„ä½¿ç”¨çš„æˆ°ç•¥
  gameState.activeStratagems = gameState.activeStratagems || {};
  gameState.activeStratagems[player] = stratagem;

  log(`ğŸ´ ä½¿ç”¨ã€${stratagem.name}ã€‘(${stratagem.cp}CP)`, "phase");
  log(`æ•ˆæœï¼š${stratagem.desc}`, "info");

  // ========== åŸ·è¡Œç‰¹æ®Šæˆ°ç•¥æ•ˆæœ ==========
  executeStratagemEffect(stratagem, player);

  // é¡¯ç¤ºæµ®å‹•æ–‡å­—
  const myUnits = gameState.units.filter(u => u.player === player && u.alive);
  if (myUnits.length > 0) {
    const unit = myUnits[Math.floor(Math.random() * myUnits.length)];
    showFloatingText(unit.x, unit.y, stratagem.name, {
      color: "#fbbf24",
      fontSize: 16,
      duration: 2000
    });
  }

  updateStratagemPanel();
  updateCPDisplay();
}

// åŸ·è¡Œæˆ°ç•¥çš„ç‰¹æ®Šæ•ˆæœ
function executeStratagemEffect(stratagem, player) {
  const name = stratagem.name;

  // ===== æ°¸æ†äº¡è€…å”è­°ï¼šå¾©æ´»è¢«æ‘§æ¯€çš„è§’è‰²ï¼ˆåŠè¡€ï¼‰=====
  if (name === "æ°¸æ†äº¡è€…å”è­°") {
    const deadCharacters = gameState.units.filter(u =>
      u.player === player &&
      !u.alive &&
      u.keywords?.includes("Character")
    );

    if (deadCharacters.length === 0) {
      log("æ²’æœ‰å¯å¾©æ´»çš„è§’è‰²", "info");
      return;
    }

    // å¦‚æœåªæœ‰ä¸€å€‹æ­»äº¡è§’è‰²ï¼Œç›´æ¥å¾©æ´»
    if (deadCharacters.length === 1) {
      reviveCharacter(deadCharacters[0], player);
    } else {
      // å¤šå€‹è§’è‰²ï¼Œè®“ç©å®¶é¸æ“‡
      showReviveSelection(deadCharacters, player);
    }
    return;
  }

  // ===== ä¸æ»…è»åœ˜å”è­°ï¼šè§¸ç™¼å¾©æ´»å”è­° =====
  if (name === "ä¸æ»…è»åœ˜å”è­°") {
    // æ¨™è¨˜ä¸‹æ¬¡å—å‚·å¾Œè§¸ç™¼å¾©æ´»
    gameState.activeStratagems[player].triggerReanimation = true;
    log("ä¸‹æ¬¡å—åˆ°å‚·å®³å¾Œå°‡è§¸ç™¼å¾©æ´»å”è­°ï¼", "info");
    return;
  }

  // ===== é£¢æ¸´è™›ç©ºå”è­°ï¼šè¿‘æˆ°S+1 =====
  if (name === "é£¢æ¸´è™›ç©ºå”è­°") {
    gameState.activeStratagemEffects = gameState.activeStratagemEffects || {};
    gameState.activeStratagemEffects.meleeStrengthBonus = 1;
    log("è¿‘æˆ°æ”»æ“ŠåŠ›é‡+1ï¼", "info");
    return;
  }

  // ===== çªè¥²é¢¨æš´å”è­°ï¼šé ç¨‹æ­¦å™¨ç²å¾—çªæ“Š =====
  if (name === "çªè¥²é¢¨æš´å”è­°") {
    gameState.activeStratagemEffects = gameState.activeStratagemEffects || {};
    gameState.activeStratagemEffects.assaultWeapons = true;
    log("é ç¨‹æ­¦å™¨ç²å¾—[çªæ“Š]ï¼", "info");
    return;
  }

  // ===== å¾æœæš´å›å”è­°ï¼šåŠå°„ç¨‹å…§é‡æ“²å‘½ä¸­1 =====
  if (name === "å¾æœæš´å›å”è­°") {
    gameState.activeStratagemEffects = gameState.activeStratagemEffects || {};
    gameState.activeStratagemEffects.rerollHitOnesHalfRange = true;
    log("åŠå°„ç¨‹å…§å¯é‡æ“²å‘½ä¸­1ï¼", "info");
    return;
  }

  // ===== å¾©ä»‡æ˜Ÿè¾°å”è­°ï¼šæ•µæ–¹æ‘§æ¯€é™„è¿‘å–®ä½å¾Œå¯å°„æ“Š =====
  if (name === "å¾©ä»‡æ˜Ÿè¾°å”è­°") {
    gameState.activeStratagemEffects = gameState.activeStratagemEffects || {};
    gameState.activeStratagemEffects.revengeShoot = true;
    log("ä¸‹æ¬¡å‹è»è¢«æ‘§æ¯€å¾Œï¼Œè§’è‰²å–®ä½å¯åæ“Šå°„æ“Šï¼", "info");
    return;
  }

  // ===== æ­»äº¡é¢å…·ï¼šæ•µæ–¹å‘½ä¸­-1 =====
  if (name === "æ­»äº¡é¢å…·") {
    gameState.activeStratagemEffects = gameState.activeStratagemEffects || {};
    gameState.activeStratagemEffects.enemyHitPenalty = 1;
    log("æ•µæ–¹å°æ­¤å–®ä½å‘½ä¸­-1ï¼", "info");
    return;
  }

  // ===== è™›å¼±æ°£æ¯ï¼šæ”»æ“Šå—å‚·æ•µäººå‘½ä¸­/è‡´å‚·+1 =====
  if (name === "è™›å¼±æ°£æ¯") {
    gameState.activeStratagemEffects = gameState.activeStratagemEffects || {};
    gameState.activeStratagemEffects.bonusVsWounded = true;
    log("æ”»æ“Šå—å‚·æ•µäººå‘½ä¸­/è‡´å‚·+1ï¼", "info");
    return;
  }

  // ========== æ³°å€«èŸ²æ—æˆ°ç•¥ ==========

  // ===== å¿«é€Ÿå†ç”Ÿï¼šç²å¾—6+ç„¡æ‡¼æ­»äº¡ =====
  if (name === "å¿«é€Ÿå†ç”Ÿ") {
    gameState.activeStratagemEffects = gameState.activeStratagemEffects || {};
    gameState.activeStratagemEffects.feelNoPain = 6;
    log("ç²å¾—6+ç„¡æ‡¼æ­»äº¡ï¼(çªè§¸ç¯„åœå…§5+)", "info");
    return;
  }

  // ===== è…ä¸Šè…ºç´ æ¿€å¢ï¼šè¿‘æˆ°5+è‡´å‘½æ‰“æ“Š =====
  if (name === "è…ä¸Šè…ºç´ æ¿€å¢") {
    gameState.activeStratagemEffects = gameState.activeStratagemEffects || {};
    gameState.activeStratagemEffects.lethalHits5 = true;
    log("è¿‘æˆ°æœªä¿®æ­£5+ç‚ºè‡´å‘½æ‰“æ“Šï¼", "info");
    return;
  }

  // ===== ç„¡ç›¡èŸ²ç¾¤ï¼šæ¢å¾©D3+3æ¨¡å‹ =====
  if (name === "ç„¡ç›¡èŸ²ç¾¤") {
    // æ‰¾æœ‰ Endless Multitude é—œéµå­—çš„å–®ä½
    const endlessUnits = gameState.units.filter(u =>
      u.player === player &&
      u.alive &&
      u.keywords?.includes("Endless Multitude") &&
      u.currentHP < u.maxHP
    );

    if (endlessUnits.length === 0) {
      log("æ²’æœ‰å¯æ¢å¾©çš„ç„¡ç›¡ç¾¤é«”å–®ä½ï¼", "info");
      return;
    }

    // é¸æ“‡è¡€é‡æœ€ä½çš„å–®ä½æ¢å¾©
    const targetUnit = endlessUnits.sort((a, b) => (a.currentHP / a.maxHP) - (b.currentHP / b.maxHP))[0];
    const healAmount = Math.floor(Math.random() * 3) + 4; // D3+3 = 4-6
    const oldHP = targetUnit.currentHP;
    targetUnit.currentHP = Math.min(targetUnit.maxHP, targetUnit.currentHP + healAmount);
    const actualHeal = targetUnit.currentHP - oldHP;

    log(`âœ¨ ${targetUnit.name} æ¢å¾© ${actualHeal} HPï¼(${targetUnit.currentHP}/${targetUnit.maxHP})`, "phase");
    showFloatingText(targetUnit.x, targetUnit.y, `+${actualHeal} HP`, { color: "#22c55e", fontSize: 16, duration: 1500 });
    playSound('heal');
    updateUnitLists();
    render();
    return;
  }

  // ===== ç‹‚æš´çªè¥²ï¼šè¡é‹’å¾Œè¿‘æˆ°å‘½ä¸­+1 =====
  if (name === "ç‹‚æš´çªè¥²") {
    gameState.activeStratagemEffects = gameState.activeStratagemEffects || {};
    gameState.activeStratagemEffects.chargeHitBonus = 1;
    log("è¡é‹’å¾Œè¿‘æˆ°å‘½ä¸­+1ï¼", "info");
    return;
  }

  // ===== èŸ²ç¾¤é ˜è¢–ï¼šæˆ°å£«é ˜å°çš„å–®ä½é‡æ“²å‘½ä¸­1 =====
  if (name === "èŸ²ç¾¤é ˜è¢–") {
    gameState.activeStratagemEffects = gameState.activeStratagemEffects || {};
    gameState.activeStratagemEffects.rerollHitOnes = true;
    log("æˆ°å£«é ˜å°çš„å–®ä½å¯é‡æ“²å‘½ä¸­1ï¼", "info");
    return;
  }

  // ===== å¼·åŒ–ç”²æ®¼ï¼šæˆ°å£«ç²å¾—4+ç„¡æ•µè±å… =====
  if (name === "å¼·åŒ–ç”²æ®¼") {
    gameState.activeStratagemEffects = gameState.activeStratagemEffects || {};
    gameState.activeStratagemEffects.invSave = 4;
    log("æˆ°å£«ç²å¾—4+ç„¡æ•µè±å…ï¼", "info");
    return;
  }
}

// å¾©æ´»è§’è‰²
function reviveCharacter(unit, player) {
  unit.alive = true;
  unit.currentHP = Math.ceil(unit.maxHP / 2);
  unit.battleShocked = false;
  unit.hasMoved = true;  // å¾©æ´»å›åˆä¸èƒ½ç§»å‹•
  unit.hasShot = true;   // å¾©æ´»å›åˆä¸èƒ½å°„æ“Š
  unit.hasFought = true; // å¾©æ´»å›åˆä¸èƒ½è¿‘æˆ°

  // æ”¾ç½®åœ¨éƒ¨ç½²å€æˆ–å‹è»æ—é‚Š
  const w = gameState.canvasWidth || 1200;
  const h = gameState.canvasHeight || 800;
  const deployZone = gameState.deployZone || inchToPixels(12);

  // æ‰¾ä¸€å€‹å‹è»å–®ä½æ—é‚Šçš„ç©ºä½
  const friendlyUnits = gameState.units.filter(u => u.player === player && u.alive && u !== unit);
  let placed = false;

  for (const friendly of friendlyUnits) {
    // å˜—è©¦åœ¨å‹è»æ—é‚Šæ”¾ç½®
    const angles = [0, Math.PI/2, Math.PI, Math.PI*1.5];
    for (const angle of angles) {
      const testX = friendly.x + Math.cos(angle) * inchToPixels(3);
      const testY = friendly.y + Math.sin(angle) * inchToPixels(3);

      if (testX > 0 && testX < w && testY > 0 && testY < h) {
        const otherUnits = gameState.units.filter(u => u !== unit && u.alive);
        if (isPositionValid(testX, testY, getUnitBaseSize(unit), otherUnits)) {
          unit.x = testX;
          unit.y = testY;
          placed = true;
          break;
        }
      }
    }
    if (placed) break;
  }

  // å¦‚æœç„¡æ³•åœ¨å‹è»æ—é‚Šæ”¾ç½®ï¼Œæ”¾åœ¨éƒ¨ç½²å€
  if (!placed) {
    if (player === 1) {
      unit.x = deployZone / 2;
    } else {
      unit.x = w - deployZone / 2;
    }
    unit.y = h / 2;
  }

  unit.deployed = true;
  unit.visible = true;

  log(`âœ¨ ${unit.name} å¾©æ´»ï¼(${unit.currentHP}/${unit.maxHP} HP)`, "phase");
  showFloatingText(unit.x, unit.y, "å¾©æ´»ï¼", { color: "#22c55e", fontSize: 18, duration: 2000 });
  playSound('heal');

  updateUnitLists();
  render();
}

// é¡¯ç¤ºå¾©æ´»é¸æ“‡å½ˆçª—
function showReviveSelection(deadCharacters, player) {
  const popup = document.createElement("div");
  popup.id = "revivePopup";
  popup.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.8); display: flex; justify-content: center;
    align-items: center; z-index: 10000;
  `;

  let html = `
    <div style="background: #1a1a2e; padding: 20px; border-radius: 12px; border: 2px solid #22c55e; max-width: 400px;">
      <h3 style="color: #22c55e; margin: 0 0 15px 0; text-align: center;">âœ¨ é¸æ“‡è¦å¾©æ´»çš„è§’è‰²</h3>
      <div style="display: flex; flex-direction: column; gap: 10px;">
  `;

  deadCharacters.forEach((unit, i) => {
    html += `
      <div onclick="confirmRevive(${i})" style="
        padding: 12px; background: rgba(34,197,94,0.1); border: 1px solid #22c55e;
        border-radius: 8px; cursor: pointer; display: flex; align-items: center; gap: 10px;
      " onmouseover="this.style.background='rgba(34,197,94,0.3)'" onmouseout="this.style.background='rgba(34,197,94,0.1)'">
        <img src="${unit.img}" style="width: 40px; height: 40px; border-radius: 50%; border: 2px solid #22c55e;" onerror="this.style.display='none'">
        <div>
          <div style="color: #fff; font-weight: bold;">${unit.name}</div>
          <div style="color: #888; font-size: 12px;">å¾©æ´»å¾Œ HP: ${Math.ceil(unit.maxHP / 2)}/${unit.maxHP}</div>
        </div>
      </div>
    `;
  });

  html += `
      </div>
      <button onclick="closeRevivePopup()" style="
        width: 100%; margin-top: 15px; padding: 10px; background: #333;
        border: 1px solid #555; color: #fff; border-radius: 6px; cursor: pointer;
      ">å–æ¶ˆ</button>
    </div>
  `;

  popup.innerHTML = html;
  document.body.appendChild(popup);

  // å„²å­˜å¾…é¸è§’è‰²ä¾›ç¢ºèªæ™‚ä½¿ç”¨
  window._reviveCharacters = deadCharacters;
  window._revivePlayer = player;
}

function confirmRevive(index) {
  const unit = window._reviveCharacters[index];
  const player = window._revivePlayer;
  if (unit) {
    reviveCharacter(unit, player);
  }
  closeRevivePopup();
}

function closeRevivePopup() {
  const popup = document.getElementById("revivePopup");
  if (popup) popup.remove();
  window._reviveCharacters = null;
  window._revivePlayer = null;
}

// ========== æˆ°ç•¥å½ˆçª—ç³»çµ± ==========
let stratagemPopupCallback = null;

function showStratagemPopup(phase) {
  const player = gameState.currentPlayer;
  const isAI = (player === 1 && ai1Enabled) || (player === 2 && ai2Enabled);

  // AIè‡ªå‹•è™•ç†
  if (isAI) {
    return Promise.resolve();
  }

  // ç²å–ç•¶å‰ç©å®¶çš„æµæ´¾æˆ°ç•¥
  const faction = armyRosters[player]?.[0]?.faction;
  const detachment = playerDetachments[player]?.detachmentId;

  if (!faction || !detachment || !DETACHMENT_RULES[faction]?.[detachment]) {
    return Promise.resolve();
  }

  const rules = DETACHMENT_RULES[faction][detachment];
  const stratagems = rules.stratagems || [];
  const currentCP = gameState.cp[player];

  if (stratagems.length === 0 || currentCP < 1) {
    return Promise.resolve();
  }

  // éæ¿¾å¯ç”¨æˆ°ç•¥ï¼ˆæ ¹æ“šéšæ®µå’ŒCPï¼‰
  const phaseStratagems = stratagems.filter(s => {
    if (currentCP < s.cp) return false;
    // æª¢æŸ¥éšæ®µé™åˆ¶
    if (s.phases && s.phases.length > 0) {
      return s.phases.includes(phase);
    }
    // æ²’æœ‰éšæ®µé™åˆ¶çš„æˆ°ç•¥å¯åœ¨ä»»ä½•éšæ®µä½¿ç”¨
    return true;
  });

  if (phaseStratagems.length === 0) {
    return Promise.resolve();
  }

  return new Promise(resolve => {
    stratagemPopupCallback = resolve;

    const popup = document.getElementById("stratagemPopup");
    const title = document.getElementById("stratagemPopupTitle");
    const cpDisplay = document.getElementById("stratagemPopupCP");
    const phaseInfo = document.getElementById("stratagemPopupPhase");
    const list = document.getElementById("stratagemPopupList");

    const phaseNames = {
      command: "æŒ‡æ®éšæ®µ",
      movement: "ç§»å‹•éšæ®µ",
      shooting: "å°„æ“Šéšæ®µ",
      charge: "è¡é‹’éšæ®µ",
      fight: "è¿‘æˆ°éšæ®µ"
    };

    title.textContent = `${rules.name} - é¸æ“‡æˆ°ç•¥`;
    cpDisplay.textContent = currentCP;
    phaseInfo.innerHTML = `<b>ç•¶å‰éšæ®µï¼š${phaseNames[phase] || phase}</b><br>
      <span style="color: var(--gold);">${rules.description}</span>`;

    let html = '';
    phaseStratagems.forEach((s, i) => {
      const originalIndex = stratagems.indexOf(s);
      html += `
        <div onclick="selectPopupStratagem(${originalIndex})"
             style="padding: 12px; background: rgba(251,191,36,0.1); border: 1px solid var(--gold); border-radius: 8px; cursor: pointer; transition: all 0.2s;"
             onmouseover="this.style.background='rgba(251,191,36,0.25)'"
             onmouseout="this.style.background='rgba(251,191,36,0.1)'">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <span style="font-weight: bold; color: var(--gold); font-size: 14px;">${s.name}</span>
            <span style="padding: 3px 10px; background: linear-gradient(135deg, var(--green), #059669); border-radius: 4px; color: white; font-weight: bold; font-size: 12px;">${s.cp} CP</span>
          </div>
          <div style="font-size: 12px; color: var(--txt); margin-top: 6px;">${s.desc}</div>
        </div>`;
    });

    list.innerHTML = html;
    popup.style.display = "flex";
    playSound('click');
  });
}

function selectPopupStratagem(index) {
  useStratagem(index);
  closeStratagemPopup();
}

function closeStratagemPopup() {
  document.getElementById("stratagemPopup").style.display = "none";
  if (stratagemPopupCallback) {
    stratagemPopupCallback();
    stratagemPopupCallback = null;
  }
}

// ========== ç¸®æ”¾æ§åˆ¶å‡½æ•¸ ==========
function zoomIn() {
  viewZoom = Math.min(MAX_ZOOM, viewZoom + ZOOM_STEP);
  updateZoomDisplay();
  render();
}

function zoomOut() {
  viewZoom = Math.max(MIN_ZOOM, viewZoom - ZOOM_STEP);
  updateZoomDisplay();
  render();
}

function zoomReset() {
  viewZoom = 1.0;
  viewOffsetX = 0;
  viewOffsetY = 0;
  updateZoomDisplay();
  render();
}

function updateZoomDisplay() {
  const display = document.getElementById("zoomDisplay");
  if (display) {
    display.textContent = Math.round(viewZoom * 100) + "%";
  }
}

// æ»‘é¼ æ»¾è¼ªç¸®æ”¾
function handleWheel(e) {
  if (!canvas) return;

  // åªåœ¨canvaså€åŸŸç¸®æ”¾
  const rect = canvas.getBoundingClientRect();
  if (e.clientX < rect.left || e.clientX > rect.right ||
      e.clientY < rect.top || e.clientY > rect.bottom) return;

  e.preventDefault();

  const oldZoom = viewZoom;

  if (e.deltaY < 0) {
    viewZoom = Math.min(MAX_ZOOM, viewZoom + ZOOM_STEP);
  } else {
    viewZoom = Math.max(MIN_ZOOM, viewZoom - ZOOM_STEP);
  }

  // ä»¥æ»‘é¼ ä½ç½®ç‚ºä¸­å¿ƒç¸®æ”¾
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  const zoomRatio = viewZoom / oldZoom;
  viewOffsetX = mouseX - (mouseX - viewOffsetX) * zoomRatio;
  viewOffsetY = mouseY - (mouseY - viewOffsetY) * zoomRatio;

  updateZoomDisplay();
  render();
}

// ========== å–®ä½æ‹–æ›³ç³»çµ± ==========
function handleDragStart(e) {
  // åªè™•ç†å·¦éµ
  if (e.button !== 0) return;

  const rect = canvas.getBoundingClientRect();
  const screenX = e.clientX - rect.left;
  const screenY = e.clientY - rect.top;
  const x = (screenX - viewOffsetX) / viewZoom;
  const y = (screenY - viewOffsetY) / viewZoom;

  // éƒ¨ç½²éšæ®µï¼šæ‹–æ›³æœªéƒ¨ç½²çš„å–®ä½
  if (gameState.phase === "deployment") {
    const player = isOnlineMode ? onlinePlayerId : gameState.deploy.deployingPlayer;
    const unit = gameState.selectedUnitForDeploy;
    if (unit && !unit.deployed && unit.player === player) {
      gameState.draggingUnit = unit;
      unit.dragX = x;
      unit.dragY = y;
      canvas.style.cursor = "grabbing";
    }
  }
  // ç§»å‹•éšæ®µï¼šæ‹–æ›³è‡ªå·±çš„å–®ä½
  else if (gameState.phase === "movement" && gameState.currentAction === "move") {
    const unit = gameState.selectedUnit;
    if (unit && unit.player === gameState.currentPlayer && !unit.hasMoved) {
      gameState.draggingUnit = unit;
      unit.dragStartX = unit.x;
      unit.dragStartY = unit.y;
      canvas.style.cursor = "grabbing";
    }
  }
}

function handleDragMove(e) {
  if (!gameState.draggingUnit) return;

  const rect = canvas.getBoundingClientRect();
  const screenX = e.clientX - rect.left;
  const screenY = e.clientY - rect.top;
  const x = (screenX - viewOffsetX) / viewZoom;
  const y = (screenY - viewOffsetY) / viewZoom;

  const unit = gameState.draggingUnit;

  if (gameState.phase === "deployment") {
    // éƒ¨ç½²éšæ®µï¼šæ›´æ–°æ‹–æ›³ä½ç½®
    unit.dragX = x;
    unit.dragY = y;
    render();
  } else if (gameState.phase === "movement") {
    // ç§»å‹•éšæ®µï¼šé¡¯ç¤ºé è¦½ä½ç½®
    const maxDist = inchToPixels(unit.stats.M);
    const dist = Math.hypot(x - unit.dragStartX, y - unit.dragStartY);
    if (dist <= maxDist) {
      unit.previewX = x;
      unit.previewY = y;
    } else {
      // é™åˆ¶åœ¨ç§»å‹•ç¯„åœå…§
      const angle = Math.atan2(y - unit.dragStartY, x - unit.dragStartX);
      unit.previewX = unit.dragStartX + Math.cos(angle) * maxDist;
      unit.previewY = unit.dragStartY + Math.sin(angle) * maxDist;
    }
    render();
  }
}

function handleDragEnd(e) {
  if (!gameState.draggingUnit) return;

  const unit = gameState.draggingUnit;
  const rect = canvas.getBoundingClientRect();
  const screenX = e.clientX - rect.left;
  const screenY = e.clientY - rect.top;
  const x = (screenX - viewOffsetX) / viewZoom;
  const y = (screenY - viewOffsetY) / viewZoom;

  if (gameState.phase === "deployment") {
    // å˜—è©¦åœ¨æ‹–æ›³ä½ç½®éƒ¨ç½²
    handleDeployClick(x, y);
    unit.dragX = undefined;
    unit.dragY = undefined;
  } else if (gameState.phase === "movement") {
    // å®Œæˆç§»å‹•
    const snapped = snapToGrid(unit.previewX || x, unit.previewY || y);
    const baseSize = getUnitBaseSize(unit);
    const otherUnits = gameState.units.filter(u => u !== unit && u.alive);

    if (isPositionValid(snapped.x, snapped.y, baseSize, otherUnits, 10, unit)) {
      unit.x = snapped.x;
      unit.y = snapped.y;
      unit.hasMoved = true;
      updateSquadModelPositions(unit); // å°éšŠæ¨¡å‹è‡ªå‹•è·Ÿéš¨
      checkCover(unit);
      playSound('click');
      log(`${unit.name} ç§»å‹•å®Œæˆ`, "info");
    } else {
      log(`è©²ä½ç½®èˆ‡å…¶ä»–å–®ä½é‡ç–Š`, "info");
    }
    unit.previewX = undefined;
    unit.previewY = undefined;
    unit.dragStartX = undefined;
    unit.dragStartY = undefined;
  }

  gameState.draggingUnit = null;
  canvas.style.cursor = "default";
  clearAction();
  updateUnitLists();
  render();
}

// æ‹–æ›³å¹³ç§»è¦–åœ–
function handlePanStart(e) {
  // å³éµæˆ–ä¸­éµé–‹å§‹æ‹–æ›³
  if (e.button === 1 || e.button === 2) {
    isDragging = true;
    dragStartX = e.clientX - viewOffsetX;
    dragStartY = e.clientY - viewOffsetY;
    e.preventDefault();
  }
}

function handlePanMove(e) {
  if (isDragging) {
    viewOffsetX = e.clientX - dragStartX;
    viewOffsetY = e.clientY - dragStartY;
    render();
  }
}

function handlePanEnd() {
  isDragging = false;
}

// ========== è§¸æ§æ”¯æ´ ==========
let touchStartDist = 0;  // é›™æŒ‡åˆå§‹è·é›¢
let touchStartZoom = 1;  // é›™æŒ‡é–‹å§‹æ™‚çš„ç¸®æ”¾
let lastTouchX = 0;
let lastTouchY = 0;
let touchStartX = 0;
let touchStartY = 0;
let touchStartTime = 0;
let isTouchPanning = false;
let isTouchZooming = false;

function handleTouchStart(e) {
  if (e.touches.length === 2) {
    // é›™æŒ‡ç¸®æ”¾é–‹å§‹
    e.preventDefault();
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    touchStartDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
    touchStartZoom = viewZoom;
    isTouchPanning = false;
    isTouchZooming = true;
  } else if (e.touches.length === 1) {
    // è¨˜éŒ„èµ·å§‹ä½ç½®å’Œæ™‚é–“
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    lastTouchX = touch.clientX;
    lastTouchY = touch.clientY;
    touchStartTime = Date.now();
    isTouchPanning = false;
    isTouchZooming = false;
  }
}

function handleTouchMove(e) {
  if (e.touches.length === 2) {
    // é›™æŒ‡ç¸®æ”¾
    e.preventDefault();
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    const currentDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);

    if (touchStartDist > 0) {
      const scale = currentDist / touchStartDist;
      const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, touchStartZoom * scale));

      // ä»¥é›™æŒ‡ä¸­å¿ƒç‚ºç¸®æ”¾ä¸­å¿ƒ
      const rect = canvas.getBoundingClientRect();
      const centerX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
      const centerY = (touch1.clientY + touch2.clientY) / 2 - rect.top;

      const zoomRatio = newZoom / viewZoom;
      viewOffsetX = centerX - (centerX - viewOffsetX) * zoomRatio;
      viewOffsetY = centerY - (centerY - viewOffsetY) * zoomRatio;
      viewZoom = newZoom;

      updateZoomDisplay();
      render();
    }
  } else if (e.touches.length === 1) {
    const touch = e.touches[0];
    const deltaX = touch.clientX - lastTouchX;
    const deltaY = touch.clientY - lastTouchY;
    const totalDeltaX = Math.abs(touch.clientX - touchStartX);
    const totalDeltaY = Math.abs(touch.clientY - touchStartY);

    // ç§»å‹•è¶…éé–¾å€¼ï¼Œå•Ÿå‹•å¹³ç§»
    if (totalDeltaX > 15 || totalDeltaY > 15) {
      if (!isTouchPanning) {
        isTouchPanning = true;
        e.preventDefault();
      }
    }

    if (isTouchPanning) {
      e.preventDefault();
      viewOffsetX += deltaX;
      viewOffsetY += deltaY;
      render();
    }

    lastTouchX = touch.clientX;
    lastTouchY = touch.clientY;
  }
}

function handleTouchEnd(e) {
  if (e.touches.length === 0) {
    // å¦‚æœæ²’æœ‰å¹³ç§»æˆ–ç¸®æ”¾ï¼Œè¦–ç‚ºé»æ“Š
    if (!isTouchPanning && !isTouchZooming) {
      const touchDuration = Date.now() - touchStartTime;
      const deltaX = Math.abs(lastTouchX - touchStartX);
      const deltaY = Math.abs(lastTouchY - touchStartY);

      // å¿«é€Ÿé»æ“Šä¸”æ²’æœ‰ç§»å‹•å¤ªå¤š = é»æ“Šäº‹ä»¶
      if (touchDuration < 300 && deltaX < 15 && deltaY < 15) {
        const rect = canvas.getBoundingClientRect();
        const screenX = touchStartX - rect.left;
        const screenY = touchStartY - rect.top;
        const x = (screenX - viewOffsetX) / viewZoom;
        const y = (screenY - viewOffsetY) / viewZoom;
        handleCanvasClick(x, y);
      }
    }

    touchStartDist = 0;
    isTouchPanning = false;
    isTouchZooming = false;
  } else if (e.touches.length === 1) {
    // å¾é›™æŒ‡è®Šå–®æŒ‡ï¼Œé‡ç½®å¹³ç§»èµ·é»
    const touch = e.touches[0];
    lastTouchX = touch.clientX;
    lastTouchY = touch.clientY;
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    touchStartTime = Date.now();
    touchStartDist = 0;
    isTouchZooming = false;
  }
}

// å°‡è¢å¹•åº§æ¨™è½‰æ›ç‚ºéŠæˆ²åº§æ¨™
function screenToGame(screenX, screenY) {
  const rect = canvas.getBoundingClientRect();
  const x = (screenX - rect.left - viewOffsetX) / viewZoom;
  const y = (screenY - rect.top - viewOffsetY) / viewZoom;
  return { x, y };
}

// å°‡éŠæˆ²åº§æ¨™è½‰æ›ç‚ºè¢å¹•åº§æ¨™
function gameToScreen(gameX, gameY) {
  const rect = canvas.getBoundingClientRect();
  const x = gameX * viewZoom + viewOffsetX + rect.left;
  const y = gameY * viewZoom + viewOffsetY + rect.top;
  return { x, y };
}

function resizeCanvas() {
  const wrap = canvas.parentElement;
  const wrapWidth = wrap.clientWidth || 300;
  const wrapHeight = wrap.clientHeight || 200;

  // ä½¿ç”¨å›ºå®šæˆ°å ´å°ºå¯¸ï¼ˆå¦‚æœå·²è¨­å®šï¼‰
  if (gameState.canvasWidth && gameState.canvasHeight) {
    // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ä»¥é©æ‡‰å®¹å™¨
    const scaleX = wrapWidth / gameState.canvasWidth;
    const scaleY = wrapHeight / gameState.canvasHeight;
    const scale = Math.min(scaleX, scaleY, 1);  // ä¸æ”¾å¤§ï¼Œåªç¸®å°

    const displayWidth = gameState.canvasWidth * scale;
    const displayHeight = gameState.canvasHeight * scale;

    canvas.width = gameState.canvasWidth * devicePixelRatio;
    canvas.height = gameState.canvasHeight * devicePixelRatio;

    // ç½®ä¸­é¡¯ç¤ºï¼ˆç¸®æ”¾ä»¥é©æ‡‰è¢å¹•ï¼‰
    canvas.style.width = displayWidth + "px";
    canvas.style.height = displayHeight + "px";
    canvas.style.margin = "auto";
    canvas.style.display = "block";
  } else {
    canvas.width = wrapWidth * devicePixelRatio;
    canvas.height = wrapHeight * devicePixelRatio;
    canvas.style.width = wrapWidth + "px";
    canvas.style.height = wrapHeight + "px";
  }

  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  render();
}

function initBattlefield() {
  // å–å¾—é¸æ“‡çš„æˆ°å ´è¨­å®š
  const sizeConfig = BATTLEFIELD_SIZES[selectedBattlefieldSize];
  const mapConfig = MAP_SCENARIOS[selectedMapScenario];

  // è¨­å®šæˆ°å ´å°ºå¯¸ï¼ˆä¿å­˜ä¾›å…¶ä»–å‡½æ•¸ä½¿ç”¨ï¼‰
  gameState.battlefieldSize = sizeConfig;

  // è¨ˆç®—å¯¦éš›åƒç´ å°ºå¯¸
  const targetW = sizeConfig.width * INCH;
  const targetH = sizeConfig.height * INCH;

  // å–å¾—å®¹å™¨å°ºå¯¸ä¸¦è¨ˆç®—ç¸®æ”¾
  const container = canvas.parentElement;
  const containerW = container.clientWidth || 800;
  const containerH = container.clientHeight || 600;

  // è¨ˆç®—é©åˆçš„ç¸®æ”¾æ¯”ä¾‹ï¼ˆä¿æŒæ¯”ä¾‹ï¼‰
  const scaleX = containerW / targetW;
  const scaleY = containerH / targetH;
  const scale = Math.min(scaleX, scaleY, 1.5); // æœ€å¤§æ”¾å¤§1.5å€

  const w = targetW * scale;
  const h = targetH * scale;

  // è¨­å®š canvas å¯¦éš›æ¸²æŸ“å°ºå¯¸ï¼ˆæ‡‰ç”¨ç¸®æ”¾ï¼‰
  gameState.canvasScale = scale;
  gameState.canvasWidth = w;
  gameState.canvasHeight = h;
  gameState.deployZone = sizeConfig.deployZone * INCH * scale; // éƒ¨ç½²å€ä¹Ÿè¦ç¸®æ”¾

  // åˆå§‹åŒ–å–®ä½
  gameState.units = [];

  console.warn('[initBattlefield] åˆå§‹åŒ–æˆ°å ´:', {
    ç©å®¶1è»éšŠæ•¸é‡: armyRosters[1]?.length || 0,
    ç©å®¶2è»éšŠæ•¸é‡: armyRosters[2]?.length || 0,
    isOnlineMode,
    onlinePlayerId
  });

  // è¼”åŠ©å‡½æ•¸ï¼šè§£æå–®ä½åç¨±ä¸­çš„æ¨¡å‹æ•¸é‡ (ä¾‹å¦‚ "æˆ°å£«Ã—10" â†’ 10)
  function parseModelCount(name) {
    const match = name.match(/[Ã—x](\d+)/i);
    return match ? parseInt(match[1]) : 1;
  }

  // è¼”åŠ©å‡½æ•¸ï¼šç‚ºå°éšŠå‰µå»ºæ¨¡å‹é™£åˆ—
  function createSquadModels(count, baseX, baseY) {
    const models = [];
    const spacing = inchToPixels(1); // 1" é–“è·
    const cols = Math.ceil(Math.sqrt(count));

    for (let i = 0; i < count; i++) {
      const row = Math.floor(i / cols);
      const col = i % cols;
      models.push({
        id: i,
        alive: true,
        x: baseX + (col - cols / 2) * spacing,
        y: baseY + (row - Math.floor(count / cols) / 2) * spacing
      });
    }
    return models;
  }

  // è¼”åŠ©å‡½æ•¸ï¼šå‰µå»ºå–®ä½ç‰©ä»¶
  function createUnitObject(unit, player, id, baseX, baseY) {
    const modelCount = parseModelCount(unit.name);
    const isSquad = modelCount > 1;
    const hpPerModel = Math.max(1, Math.floor(unit.stats.W / modelCount));

    // æª¢æŸ¥æ˜¯å¦æœ‰æ·±å…¥æ‰“æ“Šèƒ½åŠ›
    const hasDeepStrike = unit.abilities?.some(a =>
      a.includes("æ·±å…¥æ‰“æ“Š") || a.includes("Deep Strike")
    ) || false;

    const unitObj = {
      ...unit,
      player: player,
      id: id,
      modelCount: modelCount,
      isSquad: isSquad,
      hpPerModel: hpPerModel,
      currentHP: unit.stats.W,
      maxHP: unit.stats.W,
      x: baseX,
      y: baseY,
      alive: true,
      deployed: false,
      hasMoved: false,
      hasShot: false,
      hasCharged: false,
      hasFought: false,
      inCover: false,
      battleShocked: false,
      battleHistory: [],
      // ===== æ€¥è¡Œ/æ’¤é€€ç‹€æ…‹ (å®˜æ–¹10ç‰ˆè¦å‰‡) =====
      hasAdvanced: false,               // æœ¬å›åˆæ˜¯å¦æ€¥è¡Œéï¼ˆæ€¥è¡Œå¾Œä¸èƒ½å°„æ“ŠéAssaultæ­¦å™¨ã€ä¸èƒ½è¡é‹’é™¤éæœ‰ç‰¹æ®Šèƒ½åŠ›ï¼‰
      hasFallenBack: false,             // æœ¬å›åˆæ˜¯å¦æ’¤é€€éï¼ˆæ’¤é€€å¾Œä¸èƒ½å°„æ“Šã€ä¸èƒ½è¡é‹’ï¼‰
      isInEngagement: false,            // æ˜¯å¦åœ¨æ¥æˆ°ç¯„åœå…§ï¼ˆç”¨æ–¼æ’¤é€€åˆ¤å®šï¼‰
      // ===== æˆ°ç•¥é å‚™éšŠ/æ·±å…¥æ‰“æ“Š =====
      canDeepStrike: hasDeepStrike,    // æœ‰æ·±å…¥æ‰“æ“Šèƒ½åŠ›
      inReserve: false,                 // æ˜¯å¦åœ¨æˆ°ç•¥é å‚™éšŠä¸­
      arrivedThisTurn: false            // æœ¬å›åˆæ˜¯å¦å‰›å¾é å‚™éšŠæŠµé”
    };

    // å°éšŠå–®ä½ï¼šå‰µå»ºå€‹åˆ¥æ¨¡å‹
    if (isSquad) {
      unitObj.models = createSquadModels(modelCount, baseX, baseY);
      unitObj.modelsAlive = modelCount;
    }

    return unitObj;
  }

  // ç©å®¶ä¸€å–®ä½ (å·¦å´) - åˆå§‹æœªéƒ¨ç½²
  armyRosters[1].forEach((unit, i) => {
    const baseX = 60 + (i % 2) * 60;
    const baseY = 80 + Math.floor(i / 2) * 80;
    gameState.units.push(createUnitObject(unit, 1, `p1-${i}`, baseX, baseY));
  });

  // ç©å®¶äºŒå–®ä½ (å³å´) - åˆå§‹æœªéƒ¨ç½²
  armyRosters[2].forEach((unit, i) => {
    const baseX = w - 100 - (i % 2) * 60;
    const baseY = 80 + Math.floor(i / 2) * 80;
    gameState.units.push(createUnitObject(unit, 2, `p2-${i}`, baseX, baseY));
  });

  // ä½¿ç”¨é¸æ“‡çš„åœ°åœ–å ´æ™¯ç”Ÿæˆåœ°å½¢å’Œç›®æ¨™
  const mapData = mapConfig.generate(w, h);

  // åˆå§‹åŒ–åœ°å½¢ï¼ˆæ ¹æ“šç¸®æ”¾èª¿æ•´ï¼‰
  gameState.terrain = mapData.terrain.map(t => ({
    ...t,
    width: t.width * scale,
    height: t.height * scale
  }));

  // åˆå§‹åŒ–ç›®æ¨™é»
  gameState.objectives = mapData.objectives.map(obj => ({
    ...obj,
    control: null
  }));

  // è¨˜éŒ„ç•¶å‰åœ°åœ–è³‡è¨Š
  log(`æˆ°å ´: ${sizeConfig.name} (${sizeConfig.width}" x ${sizeConfig.height}")`, "info");
  log(`å ´æ™¯: ${mapConfig.name}`, "info");

  console.warn('[initBattlefield] æˆ°å ´åˆå§‹åŒ–å®Œæˆ:', {
    ç¸½å–®ä½æ•¸: gameState.units.length,
    ç©å®¶1å–®ä½: gameState.units.filter(u => u.player === 1).length,
    ç©å®¶2å–®ä½: gameState.units.filter(u => u.player === 2).length,
    å–®ä½IDåˆ—è¡¨: gameState.units.map(u => u.id)
  });

  updateUnitLists();
  setupCanvasEvents();
}

// ========== Canvas äº‹ä»¶ ==========
function setupCanvasEvents() {
  canvas.onclick = (e) => {
    // å¦‚æœæ­£åœ¨æ‹–æ›³ï¼Œä¸è™•ç†é»æ“Š
    if (gameState.draggingUnit) return;

    // è½‰æ›è¢å¹•åº§æ¨™åˆ°éŠæˆ²åº§æ¨™ï¼ˆè€ƒæ…®ç¸®æ”¾å’Œå¹³ç§»ï¼‰
    const rect = canvas.getBoundingClientRect();
    const screenX = e.clientX - rect.left;
    const screenY = e.clientY - rect.top;
    const x = (screenX - viewOffsetX) / viewZoom;
    const y = (screenY - viewOffsetY) / viewZoom;

    handleCanvasClick(x, y);
  };

  // æ»‘é¼ æ»¾è¼ªç¸®æ”¾
  canvas.addEventListener('wheel', handleWheel, { passive: false });

  // å·¦éµæ‹–æ›³å–®ä½ï¼ˆéƒ¨ç½²éšæ®µæˆ–ç§»å‹•éšæ®µï¼‰
  canvas.addEventListener('mousedown', handleDragStart);
  canvas.addEventListener('mousemove', handleDragMove);
  canvas.addEventListener('mouseup', handleDragEnd);
  canvas.addEventListener('mouseleave', handleDragEnd);

  // å³éµ/ä¸­éµæ‹–æ›³å¹³ç§»
  canvas.addEventListener('mousedown', handlePanStart);
  canvas.addEventListener('mousemove', handlePanMove);
  canvas.addEventListener('mouseup', handlePanEnd);
  canvas.addEventListener('mouseleave', handlePanEnd);

  // è§¸æ§äº‹ä»¶æ”¯æ´ï¼ˆå¹³æ¿/æ‰‹æ©Ÿï¼‰
  canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
  canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
  canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
  canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });

  // ç¦æ­¢å³éµé¸å–®
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());

  // å¾å·¦å´é¢æ¿æ‹–æ›³éƒ¨ç½² (HTML5 Drag and Drop)
  canvas.addEventListener('dragover', (e) => {
    if (gameState.phase === "deployment" && gameState.draggingFromPanel) {
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";

      // é¡¯ç¤ºé è¦½ä½ç½®
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const x = (screenX - viewOffsetX) / viewZoom;
      const y = (screenY - viewOffsetY) / viewZoom;

      if (gameState.selectedUnitForDeploy) {
        gameState.selectedUnitForDeploy.dragX = x;
        gameState.selectedUnitForDeploy.dragY = y;
        render();
      }
    }
  });

  canvas.addEventListener('drop', (e) => {
    if (gameState.phase === "deployment" && gameState.draggingFromPanel) {
      e.preventDefault();

      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      const x = (screenX - viewOffsetX) / viewZoom;
      const y = (screenY - viewOffsetY) / viewZoom;

      // éƒ¨ç½²å–®ä½
      handleDeployClick(x, y);

      // æ¸…ç†ç‹€æ…‹
      if (gameState.selectedUnitForDeploy) {
        gameState.selectedUnitForDeploy.dragX = undefined;
        gameState.selectedUnitForDeploy.dragY = undefined;
      }
      gameState.draggingFromPanel = false;
    }
  });

  canvas.addEventListener('dragleave', (e) => {
    if (gameState.selectedUnitForDeploy) {
      gameState.selectedUnitForDeploy.dragX = undefined;
      gameState.selectedUnitForDeploy.dragY = undefined;
      render();
    }
  });
}

async function handleCanvasClick(x, y) {
  // éƒ¨ç½²éšæ®µè™•ç†
  if (gameState.phase === "deployment") {
    handleDeployClick(x, y);
    return;
  }

  // æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°å–®ä½
  for (const unit of gameState.units) {
    const dist = Math.hypot(x - unit.x, y - unit.y);
    if (dist < 25) {
      // æ­»äº¡å–®ä½ï¼šå¯æŸ¥çœ‹è³‡è¨Šä½†ä¸èƒ½æ“ä½œ
      if (!unit.alive) {
        selectUnitForView(unit);
        log(`ğŸ’€ æŸ¥çœ‹æ­»äº¡å–®ä½: ${unit.name}`, "info");
        return;
      }

      // ç·šä¸Šæ¨¡å¼ï¼šéè‡ªå·±å›åˆåªèƒ½æŸ¥çœ‹ï¼Œä¸èƒ½è¡Œå‹•
      if (isOnlineMode && !isMyTurn()) {
        selectUnit(unit);
        return;
      }

      // å·²é¸æ“‡æ­¦å™¨ï¼Œé¸æ“‡æ•µæ–¹å–®ä½ä½œç‚ºç›®æ¨™
      if (gameState.selectedWeapon && unit.player !== gameState.currentPlayer) {
        gameState.targetUnit = unit;
        selectUnitForView(unit);
        showAttackConfirmButton();
        return;
      }

      // æœ‰å°„æ“Š/è¿‘æˆ°å‹•ä½œæ™‚ï¼Œæ•µæ–¹å–®ä½ä½œç‚ºç›®æ¨™
      if (gameState.currentAction === "shoot" || gameState.currentAction === "fight") {
        if (unit.player !== gameState.currentPlayer) {
          gameState.targetUnit = unit;
          selectUnitForView(unit);
          showAttackConfirmButton();
          return;
        }
        // è‡ªå·±çš„å–®ä½ï¼šå–æ¶ˆå‹•ä½œä¸¦é¸æ“‡è©²å–®ä½
        selectUnit(unit);
        return;
      }

      // ç„¡å‹•ä½œæ™‚ï¼šé¸æ“‡ä»»ä½•å–®ä½æŸ¥çœ‹è³‡è¨Š
      selectUnit(unit);
      return;
    }
  }

  // ç·šä¸Šæ¨¡å¼ï¼šéè‡ªå·±å›åˆä¸èƒ½é€²è¡Œå…¶ä»–è¡Œå‹•
  if (isOnlineMode && !isMyTurn()) {
    return;
  }

  // ç§»å‹•å‹•ä½œ
  if (gameState.currentAction === "move" && gameState.selectedUnit) {
    const unit = gameState.selectedUnit;
    const maxDist = inchToPixels(unit.stats.M);

    // å¸é™„åˆ°ç¶²æ ¼
    const snapped = snapToGrid(x, y);
    const dist = Math.hypot(snapped.x - unit.x, snapped.y - unit.y);

    if (dist <= maxDist) {
      // æª¢æŸ¥æ˜¯å¦èˆ‡å…¶ä»–å–®ä½é‡ç–Šï¼ˆè€ƒæ…®å°éšŠå±•é–‹ç¯„åœï¼‰
      const baseSize = getUnitBaseSize(unit);
      const otherUnits = gameState.units.filter(u => u !== unit && u.alive);
      if (!isPositionValid(snapped.x, snapped.y, baseSize, otherUnits, 10, unit)) {
        setHint(`ç„¡æ³•ç§»å‹•åˆ°è©²ä½ç½®ï¼Œæœƒèˆ‡å…¶ä»–å–®ä½é‡ç–Š`);
        return;
      }
      unit.x = snapped.x;
      unit.y = snapped.y;
      unit.hasMoved = true;
      updateSquadModelPositions(unit); // å°éšŠæ¨¡å‹è‡ªå‹•è·Ÿéš¨
      checkCover(unit);
      log(`${unit.name} ç§»å‹•åˆ°æ–°ä½ç½®`, "info");

      // ç·šä¸Šæ¨¡å¼åŒæ­¥ï¼ˆä½¿ç”¨å¸é™„å¾Œçš„åº§æ¨™ï¼‰
      if (isOnlineMode) {
        sendAction({ type: 'move', unitId: unit.id, x: unit.x, y: unit.y });
      }

      clearAction();
      updateUnitLists();
      render();
    } else {
      setHint(`ç§»å‹•è·é›¢è¶…å‡ºï¼æœ€å¤§ ${unit.stats.M}"`);
    }
  }

  // ===== æ€¥è¡Œå‹•ä½œ (Advance) - å®˜æ–¹10ç‰ˆè¦å‰‡ =====
  // æ€¥è¡Œï¼šåŸºç¤ç§»å‹•è·é›¢ + D6"ï¼Œä½†ä¹‹å¾Œåªèƒ½å°„æ“ŠAssaultæ­¦å™¨ï¼Œä¸”ä¸èƒ½è¡é‹’
  if (gameState.currentAction === "advance" && gameState.selectedUnit) {
    const unit = gameState.selectedUnit;

    // æ“²D6æ±ºå®šé¡å¤–ç§»å‹•è·é›¢
    const advanceRoll = rollD6();
    const maxDist = inchToPixels(unit.stats.M + advanceRoll);

    log(`ã€æ€¥è¡Œã€‘${unit.name} æ“²å‡º ${advanceRoll}"ï¼Œç¸½ç§»å‹•è·é›¢ ${unit.stats.M + advanceRoll}"`, "phase");

    // å¸é™„åˆ°ç¶²æ ¼
    const snapped = snapToGrid(x, y);
    const dist = Math.hypot(snapped.x - unit.x, snapped.y - unit.y);

    if (dist <= maxDist) {
      // æª¢æŸ¥æ˜¯å¦èˆ‡å…¶ä»–å–®ä½é‡ç–Šï¼ˆè€ƒæ…®å°éšŠå±•é–‹ç¯„åœï¼‰
      const baseSize = getUnitBaseSize(unit);
      const otherUnits = gameState.units.filter(u => u !== unit && u.alive);
      if (!isPositionValid(snapped.x, snapped.y, baseSize, otherUnits, 10, unit)) {
        setHint(`ç„¡æ³•ç§»å‹•åˆ°è©²ä½ç½®ï¼Œæœƒèˆ‡å…¶ä»–å–®ä½é‡ç–Š`);
        return;
      }

      // æ€¥è¡Œæ™‚ä¸èƒ½ç©¿è¶Šæ¥æˆ°ç¯„åœï¼ˆ1"å…§çš„æ•µäººï¼‰
      const enemies = gameState.units.filter(u => u.alive && u.player !== unit.player);
      for (const enemy of enemies) {
        const enemyDist = Math.hypot(snapped.x - enemy.x, snapped.y - enemy.y);
        const enemySize = getUnitBaseSize(enemy);
        if (enemyDist < baseSize + enemySize + inchToPixels(1)) {
          setHint(`æ€¥è¡Œä¸èƒ½é€²å…¥æ•µäººæ¥æˆ°ç¯„åœï¼`);
          return;
        }
      }

      unit.x = snapped.x;
      unit.y = snapped.y;
      unit.hasMoved = true;
      unit.hasAdvanced = true;
      updateSquadModelPositions(unit); // å°éšŠæ¨¡å‹è‡ªå‹•è·Ÿéš¨
      checkCover(unit);

      playSound('click');
      log(`âœ… ${unit.name} æ€¥è¡Œç§»å‹• ${pixelsToInch(dist).toFixed(1)}" (æœ¬å›åˆåªèƒ½Assaultå°„æ“Šï¼Œä¸èƒ½è¡é‹’)`, "hit");

      // ç·šä¸Šæ¨¡å¼åŒæ­¥
      if (isOnlineMode) {
        sendAction({ type: 'advance', unitId: unit.id, x: unit.x, y: unit.y, roll: advanceRoll });
      }

      clearAction();
      updateUnitLists();
      render();
    } else {
      setHint(`æ€¥è¡Œè·é›¢è¶…å‡ºï¼æœ€å¤§ ${unit.stats.M + advanceRoll}" (åŸºç¤${unit.stats.M}" + D6=${advanceRoll}")`);
    }
  }

  // ===== æ’¤é€€å‹•ä½œ (Fall Back) - å®˜æ–¹10ç‰ˆè¦å‰‡ =====
  // æ’¤é€€ï¼šæ¥æˆ°ä¸­çš„å–®ä½å¯ä»¥æ’¤é›¢ï¼Œä½¿ç”¨åŸºç¤ç§»å‹•è·é›¢ï¼Œä½†ä¹‹å¾Œä¸èƒ½å°„æ“Šæˆ–è¡é‹’
  if (gameState.currentAction === "fallback" && gameState.selectedUnit) {
    const unit = gameState.selectedUnit;
    const maxDist = inchToPixels(unit.stats.M);

    // å¸é™„åˆ°ç¶²æ ¼
    const snapped = snapToGrid(x, y);
    const dist = Math.hypot(snapped.x - unit.x, snapped.y - unit.y);

    if (dist <= maxDist) {
      // æª¢æŸ¥æ˜¯å¦èˆ‡å…¶ä»–å–®ä½é‡ç–Šï¼ˆè€ƒæ…®å°éšŠå±•é–‹ç¯„åœï¼‰
      const baseSize = getUnitBaseSize(unit);
      const otherUnits = gameState.units.filter(u => u !== unit && u.alive);
      if (!isPositionValid(snapped.x, snapped.y, baseSize, otherUnits, 10, unit)) {
        setHint(`ç„¡æ³•ç§»å‹•åˆ°è©²ä½ç½®ï¼Œæœƒèˆ‡å…¶ä»–å–®ä½é‡ç–Š`);
        return;
      }

      // æ’¤é€€å¾Œå¿…é ˆé›¢é–‹æ¥æˆ°ç¯„åœ
      const enemies = gameState.units.filter(u => u.alive && u.player !== unit.player);
      let stillInEngagement = false;
      for (const enemy of enemies) {
        const enemyDist = Math.hypot(snapped.x - enemy.x, snapped.y - enemy.y);
        const enemySize = getUnitBaseSize(enemy);
        if (enemyDist < baseSize + enemySize + inchToPixels(1)) {
          stillInEngagement = true;
          break;
        }
      }

      if (stillInEngagement) {
        setHint(`æ’¤é€€å¾Œä»åœ¨æ•µäººæ¥æˆ°ç¯„åœå…§ï¼è«‹é¸æ“‡æ›´é çš„ä½ç½®`);
        return;
      }

      unit.x = snapped.x;
      unit.y = snapped.y;
      unit.hasMoved = true;
      unit.hasFallenBack = true;
      unit.isInEngagement = false;
      updateSquadModelPositions(unit); // å°éšŠæ¨¡å‹è‡ªå‹•è·Ÿéš¨
      checkCover(unit);

      playSound('click');
      log(`ğŸ”™ ${unit.name} æ’¤é€€ç§»å‹• ${pixelsToInch(dist).toFixed(1)}" (æœ¬å›åˆä¸èƒ½å°„æ“Šæˆ–è¡é‹’)`, "info");

      // ç·šä¸Šæ¨¡å¼åŒæ­¥
      if (isOnlineMode) {
        sendAction({ type: 'fallback', unitId: unit.id, x: unit.x, y: unit.y });
      }

      clearAction();
      updateUnitLists();
      render();
    } else {
      setHint(`æ’¤é€€è·é›¢è¶…å‡ºï¼æœ€å¤§ ${unit.stats.M}"`);
    }
  }

  // è¡é‹’å‹•ä½œ (å®˜æ–¹10ç‰ˆè¦å‰‡)
  // 1. å®£å‘Šè¡é‹’ç›®æ¨™ï¼ˆå¿…é ˆæ˜¯æ•µæ–¹å–®ä½ï¼‰
  // 2. æ“²2D6æ±ºå®šè¡é‹’è·é›¢
  // 3. è¡é‹’æˆåŠŸæ¢ä»¶ï¼šæ“²éª°çµæœ >= é€²å…¥æ¥æˆ°ç¯„åœ(1")æ‰€éœ€çš„è·é›¢
  // 4. æˆåŠŸå‰‡ç§»å‹•åˆ°ç›®æ¨™1"å…§çš„æ¥æˆ°ç¯„åœ
  if (gameState.currentAction === "charge" && gameState.selectedUnit) {
    const charger = gameState.selectedUnit;
    const chargerSize = getUnitBaseSize(charger);

    // å°‹æ‰¾é»æ“Šä½ç½®é™„è¿‘çš„æ•µæ–¹å–®ä½ä½œç‚ºè¡é‹’ç›®æ¨™
    const clickedEnemy = gameState.units.find(u => {
      if (!u.alive || u.player === charger.player) return false;
      const enemySize = getUnitBaseSize(u);
      const dist = Math.hypot(u.x - x, u.y - y);
      return dist <= enemySize + 20; // é»æ“Šç¯„åœå®¹å·®
    });

    if (!clickedEnemy) {
      setHint("è«‹é»æ“Šæ•µæ–¹å–®ä½ä½œç‚ºè¡é‹’ç›®æ¨™");
      return;
    }

    // è¨ˆç®—åˆ°ç›®æ¨™çš„è·é›¢ï¼ˆåº•åº§é‚Šç·£åˆ°åº•åº§é‚Šç·£ï¼‰
    const targetSize = getUnitBaseSize(clickedEnemy);
    const distToTarget = Math.hypot(clickedEnemy.x - charger.x, clickedEnemy.y - charger.y);
    const distEdgeToEdge = distToTarget - chargerSize - targetSize;
    const distInches = pixelsToInch(Math.max(0, distEdgeToEdge));

    // æª¢æŸ¥è¡é‹’ç¯„åœï¼ˆæœ€å¤§12"ï¼‰
    if (distInches > 12) {
      setHint(`ç›®æ¨™è¶…å‡ºè¡é‹’ç¯„åœï¼(è·é›¢ ${distInches.toFixed(1)}" > 12")`);
      return;
    }

    // ===== Overwatch (å®˜æ–¹æˆ°ç•¥) =====
    // è¢«è¡é‹’çš„å–®ä½å¯ä»¥ä½¿ç”¨ Overwatch (1CP) é€²è¡Œå°„æ“Š
    // å‘½ä¸­éª°åªæœ‰6+æ‰æœƒå‘½ä¸­ï¼ˆå¤§å¹…æ‡²ç½°ï¼‰
    const defenderPlayer = clickedEnemy.player;
    const defenderHasCP = gameState.cp[defenderPlayer] >= 1;
    const defenderHasRangedWeapon = clickedEnemy.weapons?.ranged && !clickedEnemy.hasShot;
    const isDefenderAI = (defenderPlayer === 1 && ai1Enabled) || (defenderPlayer === 2 && ai2Enabled);

    if (defenderHasCP && defenderHasRangedWeapon) {
      let useOverwatch = false;

      if (isDefenderAI) {
        // AI æ±ºå®šæ˜¯å¦ä½¿ç”¨ Overwatch (ç°¡å–®AIéš¨æ©Ÿï¼Œå›°é›£AIæ›´å¯èƒ½ä½¿ç”¨)
        const overwatchChance = aiDifficulty === "hard" ? 0.6 : (aiDifficulty === "normal" ? 0.3 : 0.1);
        useOverwatch = Math.random() < overwatchChance;
      } else {
        // ç©å®¶æ±ºå®š - é¡¯ç¤ºç¢ºèªå°è©±æ¡†
        useOverwatch = await showOverwatchPrompt(clickedEnemy, charger);
      }

      if (useOverwatch) {
        spendCP(defenderPlayer, 1);
        log(`ğŸ¯ ${clickedEnemy.name} ä½¿ç”¨ Overwatchï¼(1CP) - å‘½ä¸­åªæœ‰6+`, "phase");

        // Overwatch å°„æ“Šï¼šå‘½ä¸­åªæœ‰6+
        const overwatchWeapon = { ...clickedEnemy.weapons.ranged, skill: 6 }; // å¼·åˆ¶6+å‘½ä¸­
        await performAttack(clickedEnemy, charger, overwatchWeapon, "ranged");

        // æª¢æŸ¥è¡é‹’è€…æ˜¯å¦è¢«æ¶ˆæ»…
        if (!charger.alive) {
          log(`ğŸ’€ ${charger.name} è¢« Overwatch æ“Šæ®ºï¼è¡é‹’å¤±æ•—`, "damage");
          clearAction();
          return;
        }
      }
    }

    // è¨ˆç®—é€²å…¥æ¥æˆ°ç¯„åœ(1")éœ€è¦çš„è·é›¢
    const engagementRange = 1; // æ¥æˆ°ç¯„åœ 1"
    const chargeDistNeeded = Math.max(0, distInches - engagementRange);

    // æ“²éª°æ±ºå®šè¡é‹’è·é›¢
    const roll1 = rollD6();
    const roll2 = rollD6();
    const chargeRoll = roll1 + roll2;

    // è¡é‹’éª°å­å‹•ç•«
    if (enableDiceAnimation) {
      await showChargeRoll(roll1, roll2, chargeDistNeeded);
    }

    log(`ã€è¡é‹’ã€‘${charger.name} â†’ ${clickedEnemy.name}`, "phase");
    log(`è·é›¢: ${distInches.toFixed(1)}" (éœ€é€²å…¥1"æ¥æˆ°ç¯„åœ = ${chargeDistNeeded.toFixed(1)}+)`, "info");
    log(`è¡é‹’æ“²éª°: ${roll1} + ${roll2} = ${chargeRoll}"`, "info");

    if (chargeRoll >= chargeDistNeeded) {
      // è¡é‹’æˆåŠŸï¼ç§»å‹•åˆ°ç›®æ¨™1"å…§çš„ä½ç½®
      const angle = Math.atan2(clickedEnemy.y - charger.y, clickedEnemy.x - charger.x);
      const engagementDist = targetSize + chargerSize + inchToPixels(0.5); // 0.5"å…§æ¥æˆ°
      let newX = clickedEnemy.x - Math.cos(angle) * engagementDist;
      let newY = clickedEnemy.y - Math.sin(angle) * engagementDist;

      // æª¢æŸ¥æ˜¯å¦èˆ‡å‹è»é‡ç–Šï¼Œå¦‚æœé‡ç–Šå‰‡èª¿æ•´ä½ç½®
      const friendlyUnits = gameState.units.filter(u => u !== charger && u.alive && u.player === charger.player);
      if (!isPositionValid(newX, newY, chargerSize, friendlyUnits)) {
        // å˜—è©¦ç¹è‘—ç›®æ¨™æ‰¾ä¸€å€‹æœ‰æ•ˆä½ç½®
        for (let offsetAngle = Math.PI / 8; offsetAngle < Math.PI * 2; offsetAngle += Math.PI / 8) {
          const testAngle = angle + offsetAngle;
          const testX = clickedEnemy.x - Math.cos(testAngle) * engagementDist;
          const testY = clickedEnemy.y - Math.sin(testAngle) * engagementDist;
          if (isPositionValid(testX, testY, chargerSize, friendlyUnits)) {
            newX = testX;
            newY = testY;
            break;
          }
        }
      }

      charger.x = newX;
      charger.y = newY;
      charger.hasCharged = true;
      charger.chargeTarget = clickedEnemy.id; // è¨˜éŒ„è¡é‹’ç›®æ¨™ï¼ˆç”¨æ–¼è¿‘æˆ°éšæ®µï¼‰
      charger.isInEngagement = true;  // æ¨™è¨˜é€²å…¥æ¥æˆ°
      clickedEnemy.isInEngagement = true;  // ç›®æ¨™ä¹Ÿé€²å…¥æ¥æˆ°
      updateSquadModelPositions(charger); // å°éšŠæ¨¡å‹è‡ªå‹•è·Ÿéš¨
      playSound('charge');
      log(`âœ… ${charger.name} è¡é‹’æˆåŠŸï¼é€²å…¥èˆ‡ ${clickedEnemy.name} çš„æ¥æˆ°ç¯„åœ`, "hit");

      // ===== Tank Shockï¼ˆå¦å…‹è¡æ“Šï¼‰- æ ¸å¿ƒè¦å‰‡æ›´æ–° v1.8 =====
      // è¼‰å…·è¡é‹’æˆåŠŸæ™‚ï¼Œå¯èŠ±è²»1CPä½¿ç”¨å¦å…‹è¡æ“Šï¼Œæ“²D6ç­‰æ–¼è¼‰å…·éŸŒæ€§ï¼Œ5+é€ æˆè‡´å‘½å‚·ï¼ˆæœ€å¤š6ï¼‰
      if (charger.keywords?.includes("Vehicle")) {
        await checkTankShock(charger, clickedEnemy);
      }

      // ===== Heroic Interventionï¼ˆè‹±å‹‡ä»‹å…¥ï¼‰- å®˜æ–¹10ç‰ˆè¦å‰‡ =====
      // ç•¶æ•µæ–¹è¡é‹’æˆåŠŸå¾Œï¼Œ6"å…§çš„å‹æ–¹è§’è‰²å¯ä»¥ç§»å‹•æœ€å¤š3"åŠ å…¥æˆ°é¬¥
      await checkHeroicIntervention(charger, clickedEnemy);

      // ç·šä¸Šæ¨¡å¼åŒæ­¥
      if (isOnlineMode) {
        sendAction({ type: 'charge', unitId: charger.id, targetId: clickedEnemy.id, x: newX, y: newY });
      }

      clearAction();
      updateUnitLists();
      render();
    } else {
      // è¡é‹’å¤±æ•—
      playSound('miss');
      log(`âŒ è¡é‹’å¤±æ•—ï¼éœ€è¦ ${chargeDistNeeded.toFixed(1)}"+ ä½†åªæ“²å‡º ${chargeRoll}"`, "miss");
      charger.hasCharged = true; // è¡é‹’å¤±æ•—ä¹Ÿæ¶ˆè€—è¡é‹’å‹•ä½œ
      clearAction();
    }
  }

  // æ·±å…¥æ‰“æ“Šéƒ¨ç½²å‹•ä½œ
  if (gameState.currentAction === "deepstrike" && gameState.selectedUnit) {
    const unit = gameState.selectedUnit;
    if (!unit.inReserve) {
      setHint("è©²å–®ä½ä¸åœ¨æˆ°ç•¥é å‚™éšŠä¸­ï¼");
      clearAction();
      return;
    }

    const success = await deployFromReserves(unit, x, y);
    if (success) {
      clearAction();
    }
    // å¦‚æœå¤±æ•—ï¼Œä¿æŒåœ¨æ·±å…¥æ‰“æ“Šæ¨¡å¼è®“ç©å®¶é¸æ“‡å…¶ä»–ä½ç½®
  }
}

// ========== é¸æ“‡å–®ä½ ==========
function selectUnit(unit) {
  // å®‰å…¨æª¢æŸ¥ï¼šç¢ºä¿å–®ä½è³‡æ–™å®Œæ•´
  if (!unit || !unit.id) {
    console.warn('[selectUnit] ç„¡æ•ˆå–®ä½');
    return;
  }

  gameState.selectedUnit = unit;
  playSound('select'); // éŸ³æ•ˆï¼šé¸æ“‡

  // æ ¹æ“šç•¶å‰éšæ®µè‡ªå‹•è¨­å®šå‹•ä½œ
  const phase = gameState.phase;
  const isMyUnit = unit.player === gameState.currentPlayer;

  // ç¢ºä¿å–®ä½æœ‰å®Œæ•´è³‡æ–™æ‰è¨­å®šå‹•ä½œ
  if (isMyUnit && unit.stats && unit.weapons) {
    if (phase === "movement" && !unit.hasMoved) {
      gameState.currentAction = "move";
      setHint(`é»æ“Šæˆ°å ´ç§»å‹• ${unit.name}ï¼ˆæœ€å¤§ ${unit.stats.M}"ï¼‰`);
    } else if (phase === "shooting" && !unit.hasShot && unit.weapons.ranged) {
      gameState.currentAction = "shoot";
      setHint(`é»æ“Šæ•µæ–¹å–®ä½ä½œç‚º ${unit.name} çš„å°„æ“Šç›®æ¨™`);
    } else if (phase === "charge" && !unit.hasCharged && !unit.battleShocked) {
      gameState.currentAction = "charge";
      setHint(`é»æ“Šæˆ°å ´ä½ç½®é€²è¡Œè¡é‹’ï¼ˆ2D6ï¼‰`);
    } else if (phase === "fight" && !unit.hasFought && unit.weapons.melee) {
      gameState.currentAction = "fight";
      setHint(`é»æ“Šç›¸é„°æ•µæ–¹å–®ä½é€²è¡Œè¿‘æˆ°`);
    } else {
      gameState.currentAction = null;
      setHint(`${unit.name} åœ¨æ­¤éšæ®µç„¡æ³•è¡Œå‹•`);
    }
  } else {
    gameState.currentAction = null;
    if (!isMyUnit) {
      setHint(`æŸ¥çœ‹æ•µæ–¹å–®ä½: ${unit.name}`);
    } else {
      setHint(`${unit.name || 'å–®ä½'} è³‡æ–™è¼‰å…¥ä¸­...`);
    }
  }

  updateSelectedUnitInfo();
  updateActionButtons();
  highlightSelectedUnit();
  render();
}

// åªæŸ¥çœ‹å–®ä½è³‡è¨Šï¼Œä¸æ”¹è®Šå·²é¸ä¸­çš„æ”»æ“Šå–®ä½
function selectUnitForView(unit) {
  // æš«å­˜ç›®å‰é¸ä¸­çš„å–®ä½
  const currentAttacker = gameState.selectedUnit;

  // ç¢ºä¿å–®ä½è³‡æ–™å®Œæ•´
  if (!unit || !unit.stats || !unit.weapons) {
    console.warn('[selectUnitForView] å–®ä½è³‡æ–™ä¸å®Œæ•´:', unit?.id, unit?.name);
    setHint('ç„¡æ³•é¡¯ç¤ºå–®ä½è³‡è¨Š');
    return;
  }

  // é¡¯ç¤ºç›®æ¨™å–®ä½è³‡è¨Š
  const faction = UNIT_DATABASE[unit.faction];
  const factionName = faction?.name || unit.faction || 'æœªçŸ¥';
  let weaponsHtml = "";

  if (unit.weapons.ranged) {
    const w = unit.weapons.ranged;
    const keywords = w.keywords ? `<div style="font-size: 9px; color: #fbbf24; margin-top: 2px;">${w.keywords.join(", ")}</div>` : "";
    weaponsHtml += `
      <div class="weapon-item">
        <div class="weapon-name">ğŸ”« ${w.name}</div>
        <div class="weapon-stats">å°„ç¨‹${w.range}" A${w.A} BS${w.skill}+ S${w.S} AP${w.AP} D${w.D}</div>
        ${keywords}
      </div>
    `;
  }
  if (unit.weapons.melee) {
    const w = unit.weapons.melee;
    const keywords = w.keywords ? `<div style="font-size: 9px; color: #fbbf24; margin-top: 2px;">${w.keywords.join(", ")}</div>` : "";
    weaponsHtml += `
      <div class="weapon-item">
        <div class="weapon-name">âš”ï¸ ${w.name}</div>
        <div class="weapon-stats">A${w.A} WS${w.skill}+ S${w.S} AP${w.AP} D${w.D}</div>
        ${keywords}
      </div>
    `;
  }

  document.getElementById("selectedUnitInfo").innerHTML = `
    <div style="background: rgba(220,38,38,0.2); border: 1px solid var(--red); border-radius: 8px; padding: 8px; margin-bottom: 8px;">
      <div style="font-size: 12px; color: var(--red); font-weight: bold;">ğŸ¯ æ”»æ“Šç›®æ¨™</div>
    </div>
    <div class="selected-unit-header">
      <div class="selected-avatar"><img src="${unit.img}" onerror="this.style.display='none'"></div>
      <div class="selected-details">
        <div class="selected-name">${unit.name}</div>
        <div class="selected-faction">${factionName} - ${unit.points}é»</div>
        <div style="margin-top: 4px; font-size: 11px;">
          HP: ${unit.currentHP}/${unit.maxHP} ${unit.inCover ? "ğŸ›¡ï¸æ©è­·" : ""} ${unit.battleShocked ? "ğŸ’€æˆ°æ…„" : ""}
        </div>
      </div>
    </div>
    <div class="stats-grid">
      <div class="stat-cell"><div class="stat-label">ç§»å‹•</div><div class="stat-value">${unit.stats.M}"</div></div>
      <div class="stat-cell"><div class="stat-label">éŸŒæ€§</div><div class="stat-value">${unit.stats.T}</div></div>
      <div class="stat-cell"><div class="stat-label">è­·ç”²</div><div class="stat-value">${unit.stats.Sv}+</div></div>
      <div class="stat-cell"><div class="stat-label">å‚·å£</div><div class="stat-value">${unit.currentHP}</div></div>
      <div class="stat-cell"><div class="stat-label">é ˜å°</div><div class="stat-value">${unit.stats.Ld}+</div></div>
      <div class="stat-cell"><div class="stat-label">OC</div><div class="stat-value">${unit.stats.OC}</div></div>
    </div>
    <div class="weapons-section">
      ${weaponsHtml}
    </div>
    ${unit.abilities?.length ? `<div style="margin-top: 8px; font-size: 10px; color: var(--muted);">
      <b>ç‰¹æ®Šèƒ½åŠ›:</b> ${unit.abilities.join(", ")}
    </div>` : ""}
    ${unit.battleHistory?.length ? `
    <div style="margin-top: 10px; border-top: 1px solid var(--line); padding-top: 8px;">
      <div style="font-size: 11px; font-weight: bold; color: var(--gold); margin-bottom: 5px;">ğŸ“œ æˆ°é¬¥æ­·å²</div>
      <div style="max-height: 80px; overflow-y: auto; font-size: 10px;">
        ${unit.battleHistory.slice().reverse().map(h => `
          <div style="padding: 2px 0; color: ${h.type === 'kill' ? '#22c55e' : h.type === 'death' ? '#ef4444' : h.type === 'damage' ? '#f97316' : h.type === 'attack' ? '#60a5fa' : '#94a3b8'};">
            [R${h.round}] ${h.message}
          </div>
        `).join('')}
      </div>
    </div>
    ` : ""}
  `;

  setHint(`ç›®æ¨™: ${unit.name} | é»æ“Šã€Œç¢ºèªæ”»æ“Šã€åŸ·è¡Œæ”»æ“Š`);
  render();
}

// é¡¯ç¤ºæ”»æ“Šç¢ºèªæŒ‰éˆ•
function showAttackConfirmButton() {
  const btnConfirmAttack = document.getElementById("btnConfirmAttack");
  if (btnConfirmAttack) {
    btnConfirmAttack.style.display = "inline-block";
    btnConfirmAttack.disabled = false;
  }
}

// éš±è—æ”»æ“Šç¢ºèªæŒ‰éˆ•
function hideAttackConfirmButton() {
  const btnConfirmAttack = document.getElementById("btnConfirmAttack");
  if (btnConfirmAttack) {
    btnConfirmAttack.style.display = "none";
  }
}

// åŸ·è¡Œç¢ºèªçš„æ”»æ“Š
async function confirmAttack() {
  if (gameState.selectedUnit && gameState.targetUnit) {
    await executeAction();
  }
  hideAttackConfirmButton();
}

function updateSelectedUnitInfo() {
  const unit = gameState.selectedUnit;
  if (!unit) {
    document.getElementById("selectedUnitInfo").innerHTML = `<p style="color: var(--muted); text-align: center; padding: 20px;">é»æ“Šå–®ä½æŸ¥çœ‹è©³ç´°è³‡è¨Š</p>`;
    return;
  }

  // ç¢ºä¿å–®ä½è³‡æ–™å®Œæ•´ï¼ˆä½¿ç”¨æœ¬åœ°è³‡æ–™ï¼‰
  if (!unit.stats || !unit.weapons) {
    console.warn('[updateSelectedUnitInfo] å–®ä½è³‡æ–™ä¸å®Œæ•´:', unit.id, unit.name);
    document.getElementById("selectedUnitInfo").innerHTML = `<p style="color: var(--muted); text-align: center; padding: 20px;">è¼‰å…¥å–®ä½è³‡æ–™ä¸­...</p>`;
    return;
  }

  const faction = UNIT_DATABASE[unit.faction];
  const factionName = faction?.name || unit.faction || 'æœªçŸ¥';
  let weaponsHtml = "";

  const isMyUnit = unit.player === gameState.currentPlayer;
  const canShoot = gameState.phase === "shooting" && isMyUnit && !unit.hasShot && unit.alive;
  const canFight = gameState.phase === "fight" && isMyUnit && !unit.hasFought && unit.alive;

  if (unit.weapons.ranged) {
    const w = unit.weapons.ranged;
    const keywords = w.keywords ? `<div style="font-size: 9px; color: #fbbf24; margin-top: 2px;">${w.keywords.join(", ")}</div>` : "";
    const isUsed = w.oneUse && unit.usedOneUseWeapons?.[w.name];
    const isSelected = gameState.selectedWeapon?.name === w.name && gameState.selectedWeapon?.type === "ranged";
    const clickable = canShoot && !isUsed;
    weaponsHtml += `
      <div class="weapon-item ${isSelected ? 'weapon-selected' : ''} ${clickable ? 'weapon-clickable' : ''} ${isUsed ? 'weapon-used' : ''}"
           onclick="${clickable ? `selectWeaponForAttack('ranged', '${w.name.replace(/'/g, "\\'")}')` : ''}">
        <div class="weapon-name">ğŸ”« ${w.name} ${isSelected ? 'âœ“' : ''}</div>
        <div class="weapon-stats">å°„ç¨‹${w.range}" A${w.A} BS${w.skill}+ S${w.S} AP${w.AP} D${w.D}</div>
        ${keywords}
        ${isUsed ? '<div style="color: var(--red); font-size: 9px;">âŒ å·²ä½¿ç”¨</div>' : ''}
        ${clickable && !isSelected ? '<div style="color: #22c55e; font-size: 9px;">ğŸ‘† é»æ“Šé¸æ“‡æ­¦å™¨</div>' : ''}
        ${isSelected ? '<div style="color: #3b82f6; font-size: 9px;">ğŸ‘‰ é»æ“Šæ•µæ–¹å–®ä½æ”»æ“Š</div>' : ''}
      </div>
    `;
  }
  if (unit.weapons.melee) {
    const w = unit.weapons.melee;
    const keywords = w.keywords ? `<div style="font-size: 9px; color: #fbbf24; margin-top: 2px;">${w.keywords.join(", ")}</div>` : "";
    const isUsed = w.oneUse && unit.usedOneUseWeapons?.[w.name];
    const isSelected = gameState.selectedWeapon?.name === w.name && gameState.selectedWeapon?.type === "melee";
    const clickable = canFight && !isUsed;
    weaponsHtml += `
      <div class="weapon-item ${isSelected ? 'weapon-selected' : ''} ${clickable ? 'weapon-clickable' : ''} ${isUsed ? 'weapon-used' : ''}"
           onclick="${clickable ? `selectWeaponForAttack('melee', '${w.name.replace(/'/g, "\\'")}')` : ''}">
        <div class="weapon-name">âš”ï¸ ${w.name} ${isSelected ? 'âœ“' : ''}</div>
        <div class="weapon-stats">A${w.A} WS${w.skill}+ S${w.S} AP${w.AP} D${w.D}</div>
        ${keywords}
        ${isUsed ? '<div style="color: var(--red); font-size: 9px;">âŒ å·²ä½¿ç”¨</div>' : ''}
        ${clickable && !isSelected ? '<div style="color: #22c55e; font-size: 9px;">ğŸ‘† é»æ“Šé¸æ“‡æ­¦å™¨</div>' : ''}
        ${isSelected ? '<div style="color: #3b82f6; font-size: 9px;">ğŸ‘‰ é»æ“Šæ•µæ–¹å–®ä½æ”»æ“Š</div>' : ''}
      </div>
    `;
  }

  // å»ºç«‹é‹è¼¸å’Œé£›è¡Œå™¨ç‹€æ…‹é¡¯ç¤º
  let transportInfo = '';
  const capacity = getTransportCapacity(unit);
  if (capacity > 0) {
    const embarkedNames = (unit.embarkedUnits || []).map(id => {
      const u = gameState.units.find(x => x.id === id);
      return u ? u.name : '?';
    }).join(', ');
    transportInfo = `<div style="font-size: 10px; color: #447799; margin-top: 2px;">
      ğŸš é‹è¼¸å®¹é‡: ${(unit.embarkedUnits || []).length}/${capacity} ${unit.embarkedUnits?.length ? `(${embarkedNames})` : ''}
    </div>`;
  }
  if (unit.embarkedIn) {
    const transport = gameState.units.find(u => u.id === unit.embarkedIn);
    transportInfo = `<div style="font-size: 10px; color: #774499; margin-top: 2px;">
      ğŸ“¦ æ­è¼‰æ–¼: ${transport?.name || 'æœªçŸ¥è¼‰å…·'}
    </div>`;
  }
  const aircraftStatus = isAircraft(unit) ? (unit.isHovering ? " ğŸšæ‡¸åœ" : " âœˆï¸é£›è¡Œ") : "";

  document.getElementById("selectedUnitInfo").innerHTML = `
    <div class="selected-unit-header">
      <div class="selected-avatar"><img src="${unit.img}" onerror="this.style.display='none'"></div>
      <div class="selected-details">
        <div class="selected-name">${unit.name}</div>
        <div class="selected-faction">${factionName} - ${unit.points}é»</div>
        <div style="margin-top: 4px; font-size: 11px;">
          HP: ${unit.currentHP}/${unit.maxHP} ${unit.inCover ? "ğŸ›¡ï¸æ©è­·" : ""} ${unit.battleShocked ? "ğŸ’€æˆ°æ…„" : ""}${aircraftStatus}
        </div>
        ${transportInfo}
      </div>
    </div>
    <div class="stats-grid">
      <div class="stat-cell"><div class="stat-label">ç§»å‹•</div><div class="stat-value">${unit.stats.M}"</div></div>
      <div class="stat-cell"><div class="stat-label">éŸŒæ€§</div><div class="stat-value">${unit.stats.T}</div></div>
      <div class="stat-cell"><div class="stat-label">è­·ç”²</div><div class="stat-value">${unit.stats.Sv}+</div></div>
      <div class="stat-cell"><div class="stat-label">å‚·å£</div><div class="stat-value">${unit.currentHP}</div></div>
      <div class="stat-cell"><div class="stat-label">é ˜å°</div><div class="stat-value">${unit.stats.Ld}+</div></div>
      <div class="stat-cell"><div class="stat-label">OC</div><div class="stat-value">${unit.isHovering ? 0 : unit.stats.OC}</div></div>
    </div>
    <div class="weapons-section">
      ${weaponsHtml}
    </div>
    ${unit.abilities?.length ? `<div style="margin-top: 8px; font-size: 10px; color: var(--muted);">
      <b>ç‰¹æ®Šèƒ½åŠ›:</b> ${unit.abilities.join(", ")}
    </div>` : ""}
    ${unit.battleHistory?.length ? `
    <div style="margin-top: 10px; border-top: 1px solid var(--line); padding-top: 8px;">
      <div style="font-size: 11px; font-weight: bold; color: var(--gold); margin-bottom: 5px;">ğŸ“œ æˆ°é¬¥æ­·å²</div>
      <div style="max-height: 100px; overflow-y: auto; font-size: 10px;">
        ${unit.battleHistory.slice().reverse().map(h => `
          <div style="padding: 2px 0; color: ${h.type === 'kill' ? '#22c55e' : h.type === 'death' ? '#ef4444' : h.type === 'damage' ? '#f97316' : h.type === 'attack' ? '#60a5fa' : '#94a3b8'};">
            [R${h.round}] ${h.message}
          </div>
        `).join('')}
      </div>
    </div>
    ` : `
    <div style="margin-top: 10px; border-top: 1px solid var(--line); padding-top: 8px;">
      <div style="font-size: 11px; font-weight: bold; color: var(--gold); margin-bottom: 5px;">ğŸ“œ æˆ°é¬¥æ­·å²</div>
      <div style="font-size: 10px; color: var(--muted);">å°šç„¡æˆ°é¬¥è¨˜éŒ„</div>
    </div>
    `}
  `;
}

// ========== å‹•ä½œç³»çµ± ==========
function setAction(action) {
  if (!gameState.selectedUnit) {
    setHint("è«‹å…ˆé¸æ“‡ä¸€å€‹å–®ä½");
    return;
  }

  const unit = gameState.selectedUnit;

  if (action === "move" && unit.hasMoved) {
    setHint("è©²å–®ä½å·²ç§»å‹•é");
    return;
  }
  // ===== æ€¥è¡Œ (Advance) - å®˜æ–¹10ç‰ˆè¦å‰‡ =====
  // æ€¥è¡Œï¼šç§»å‹•æ™‚é¡å¤–+D6"ï¼Œä½†ä¹‹å¾Œä¸èƒ½å°„æ“Šï¼ˆé™¤äº†Assaultæ­¦å™¨ï¼‰ä¸”ä¸èƒ½è¡é‹’ï¼ˆé™¤éæœ‰ç‰¹æ®Šèƒ½åŠ›ï¼‰
  if (action === "advance" && unit.hasMoved) {
    setHint("è©²å–®ä½å·²ç§»å‹•éï¼Œç„¡æ³•æ€¥è¡Œ");
    return;
  }
  if (action === "advance" && unit.isInEngagement) {
    setHint("æ¥æˆ°ä¸­çš„å–®ä½ç„¡æ³•æ€¥è¡Œï¼è«‹ä½¿ç”¨æ’¤é€€");
    return;
  }
  // ===== æ’¤é€€ (Fall Back) - å®˜æ–¹10ç‰ˆè¦å‰‡ =====
  // æ’¤é€€ï¼šæ¥æˆ°ä¸­çš„å–®ä½å¯ä»¥æ’¤é›¢ï¼Œç§»å‹•è·é›¢=Mï¼Œä½†ä¹‹å¾Œä¸èƒ½å°„æ“Šæˆ–è¡é‹’
  if (action === "fallback" && unit.hasMoved) {
    setHint("è©²å–®ä½å·²ç§»å‹•éï¼Œç„¡æ³•æ’¤é€€");
    return;
  }
  if (action === "fallback" && !unit.isInEngagement) {
    setHint("åªæœ‰æ¥æˆ°ä¸­çš„å–®ä½æ‰èƒ½æ’¤é€€ï¼");
    return;
  }
  if (action === "shoot" && unit.hasShot) {
    setHint("è©²å–®ä½å·²å°„æ“Šé");
    return;
  }
  // å®˜æ–¹è¦å‰‡ï¼šæ’¤é€€å¾Œä¸èƒ½å°„æ“Š
  if (action === "shoot" && unit.hasFallenBack) {
    setHint("æ’¤é€€å¾Œçš„å–®ä½æœ¬å›åˆç„¡æ³•å°„æ“Šï¼");
    return;
  }
  // å®˜æ–¹è¦å‰‡ï¼šæ€¥è¡Œå¾Œåªèƒ½å°„æ“ŠAssaultæ­¦å™¨
  if (action === "shoot" && unit.hasAdvanced && unit.weapons?.ranged) {
    const hasAssault = unit.weapons.ranged.keywords?.some(k =>
      k === "Assault" || k.startsWith("Assault ")
    );
    if (!hasAssault) {
      setHint("æ€¥è¡Œå¾Œåªèƒ½å°„æ“ŠAssaultï¼ˆçªæ“Šï¼‰æ­¦å™¨ï¼");
      return;
    }
  }
  if (action === "charge" && unit.hasCharged) {
    setHint("è©²å–®ä½å·²è¡é‹’é");
    return;
  }
  // å®˜æ–¹è¦å‰‡ï¼šæˆ°æ…„ä¸­çš„å–®ä½ä¸èƒ½è¡é‹’
  if (action === "charge" && unit.battleShocked) {
    setHint("æˆ°æ…„ä¸­çš„å–®ä½ç„¡æ³•è¡é‹’ï¼");
    return;
  }
  // å®˜æ–¹è¦å‰‡ï¼šæ’¤é€€å¾Œä¸èƒ½è¡é‹’
  if (action === "charge" && unit.hasFallenBack) {
    setHint("æ’¤é€€å¾Œçš„å–®ä½æœ¬å›åˆç„¡æ³•è¡é‹’ï¼");
    return;
  }
  // å®˜æ–¹è¦å‰‡ï¼šæ€¥è¡Œå¾Œä¸èƒ½è¡é‹’ï¼ˆé™¤éæœ‰ç‰¹æ®Šèƒ½åŠ›ï¼‰
  if (action === "charge" && unit.hasAdvanced) {
    const canChargeAfterAdvance = unit.abilities?.some(a =>
      a.includes("æ€¥è¡Œè¡é‹’") || a.includes("Assault") || a.includes("ç–¾é€Ÿ")
    );
    if (!canChargeAfterAdvance) {
      setHint("æ€¥è¡Œå¾Œçš„å–®ä½æœ¬å›åˆç„¡æ³•è¡é‹’ï¼");
      return;
    }
  }
  if (action === "fight" && unit.hasFought) {
    setHint("è©²å–®ä½å·²è¿‘æˆ°é");
    return;
  }

  // ===== æ­è¼‰ (Embark) - å®˜æ–¹10ç‰ˆè¦å‰‡ =====
  if (action === "embark") {
    if (!unit.keywords?.includes("Infantry")) {
      setHint("åªæœ‰æ­¥å…µå–®ä½å¯ä»¥æ­è¼‰é‹è¼¸è¼‰å…·ï¼");
      return;
    }
    if (unit.hasMoved) {
      setHint("è©²å–®ä½å·²ç§»å‹•éï¼Œç„¡æ³•æ­è¼‰");
      return;
    }
    const transports = findNearbyTransports(unit);
    if (transports.length === 0) {
      setHint("é™„è¿‘æ²’æœ‰å¯æ­è¼‰çš„é‹è¼¸è¼‰å…·ï¼ˆéœ€åœ¨3\"å…§ï¼‰");
      return;
    }
    // å¦‚æœåªæœ‰ä¸€å€‹é‹è¼¸è¼‰å…·ï¼Œç›´æ¥æ­è¼‰
    if (transports.length === 1) {
      embarkUnit(unit, transports[0]);
      clearAction();
      return;
    }
    // å¤šå€‹è¼‰å…·ï¼šè¨­ç½®å‹•ä½œè®“ç©å®¶é»é¸
    setHint(`é»æ“Šè¦æ­è¼‰çš„é‹è¼¸è¼‰å…·ï¼ˆ${transports.map(t => t.name).join(", ")}ï¼‰`);
  }

  // ===== ä¸‹è»Š (Disembark) - å®˜æ–¹10ç‰ˆè¦å‰‡ =====
  if (action === "disembark") {
    if (!unit.embarkedUnits || unit.embarkedUnits.length === 0) {
      setHint("è©²é‹è¼¸è¼‰å…·æ²’æœ‰æ­è¼‰å–®ä½ï¼");
      return;
    }
    // è®“æ‰€æœ‰æ­è¼‰çš„å–®ä½ä¸‹è»Š
    for (const unitId of [...unit.embarkedUnits]) {
      const embarkedUnit = gameState.units.find(u => u.id === unitId);
      if (embarkedUnit) {
        disembarkUnit(embarkedUnit, unit, false);
      }
    }
    clearAction();
    return;
  }

  // æ·±å…¥æ‰“æ“Šå‹•ä½œï¼šé¸æ“‡é å‚™éšŠä¸­çš„å–®ä½ä¾†éƒ¨ç½²
  if (action === "deepstrike") {
    if (!canDeployFromReserves()) {
      setHint("æ·±å…¥æ‰“æ“Šåªèƒ½åœ¨ç¬¬2å›åˆæˆ–ä¹‹å¾Œä½¿ç”¨ï¼");
      return;
    }
    const reserveUnits = getReserveUnits(gameState.currentPlayer);
    if (reserveUnits.length === 0) {
      setHint("æ²’æœ‰å–®ä½åœ¨æˆ°ç•¥é å‚™éšŠä¸­ï¼");
      return;
    }
    // é¡¯ç¤ºé å‚™éšŠå–®ä½é¸æ“‡
    showReserveUnitSelection(reserveUnits);
    return;
  }

  gameState.currentAction = action;

  const hints = {
    move: `é»æ“Šæˆ°å ´ç§»å‹• ${unit.name}ï¼ˆæœ€å¤§ ${unit.stats.M}"ï¼‰`,
    advance: `é»æ“Šæˆ°å ´æ€¥è¡Œ ${unit.name}ï¼ˆç§»å‹•+D6"ï¼Œä¹‹å¾Œåªèƒ½Assaultå°„æ“Šï¼Œä¸èƒ½è¡é‹’ï¼‰`,
    fallback: `é»æ“Šæˆ°å ´æ’¤é€€ ${unit.name}ï¼ˆæœ€å¤§ ${unit.stats.M}"ï¼Œä¹‹å¾Œä¸èƒ½å°„æ“Š/è¡é‹’ï¼‰`,
    shoot: `é»æ“Šæ•µæ–¹å–®ä½ä½œç‚º ${unit.name} çš„å°„æ“Šç›®æ¨™`,
    charge: `é»æ“Šæ•µæ–¹å–®ä½é€²è¡Œè¡é‹’ï¼ˆ2D6ï¼Œæœ€å¤§12"ï¼Œéœ€é€²å…¥1"æ¥æˆ°ç¯„åœï¼‰`,
    fight: `é»æ“Šç›¸é„°æ•µæ–¹å–®ä½é€²è¡Œè¿‘æˆ°`,
    deepstrike: `é»æ“Šæˆ°å ´ä½ç½®éƒ¨ç½² ${unit?.name || 'å–®ä½'}ï¼ˆè·æ•µäºº9"+ï¼‰`
  };

  setHint(hints[action] || hints.move);
  render();
}

function clearAction() {
  gameState.currentAction = null;
  gameState.targetUnit = null;
  gameState.selectedWeapon = null;
  setHint("é¸æ“‡ä¸€å€‹å–®ä½é–‹å§‹è¡Œå‹•");
  updateSelectedUnitInfo();
}

function setHint(text) {
  document.getElementById("actionHint").textContent = text;
}

// é¸æ“‡æ­¦å™¨é€²è¡Œæ”»æ“Šï¼ˆæ–°æ”»æ“Šæµç¨‹ï¼‰
function selectWeaponForAttack(type, weaponName) {
  const unit = gameState.selectedUnit;
  if (!unit) return;

  // æ‰¾åˆ°å°æ‡‰çš„æ­¦å™¨
  let weapon = null;
  if (type === "ranged" && unit.weapons.ranged) {
    weapon = unit.weapons.ranged;
  } else if (type === "melee" && unit.weapons.melee) {
    weapon = unit.weapons.melee;
  }

  if (!weapon || weapon.name !== weaponName) return;

  gameState.selectedWeapon = { ...weapon, type: type };
  gameState.currentAction = type === "ranged" ? "shoot" : "fight";

  playSound('select');
  setHint(`å·²é¸æ“‡ ${weapon.name}ï¼Œé»æ“Šæ•µæ–¹å–®ä½ä½œç‚ºç›®æ¨™`);
  updateSelectedUnitInfo();
  render();
}

// æ­¦å™¨é¸æ“‡ç›¸é—œ
let weaponPopupCallback = null;
let selectedWeaponForAttack = null;

async function executeAction() {
  const attacker = gameState.selectedUnit;
  const target = gameState.targetUnit;

  if (!attacker || !target) return;

  // ===== Lone Operativeï¼ˆç¨è¡Œè€…ï¼‰è¦å‰‡ - å®˜æ–¹10ç‰ˆ =====
  // æœ‰ç¨è¡Œè€…èƒ½åŠ›çš„å–®ä½åªèƒ½åœ¨12"å…§è¢«å°„æ“Šï¼ˆé™¤éå°„æ“Šè€…æ˜¯è§’è‰²æˆ–ç›®æ¨™åœ¨å–®ä½ä¸­ï¼‰
  const hasLoneOperative = target.abilities?.some(a =>
    a.includes("ç¨è¡Œè€…") || a.includes("Lone Operative") || a.includes("ç¨è¡Œ")
  );
  if (hasLoneOperative && gameState.currentAction === "shoot") {
    const distance = pixelsToInch(Math.hypot(attacker.x - target.x, attacker.y - target.y));
    const attackerIsCharacter = attacker.keywords?.includes("Character");

    if (distance > 12 && !attackerIsCharacter) {
      log(`âŒ ${target.name} æ˜¯ç¨è¡Œè€…ï¼åªèƒ½åœ¨12"å…§è¢«å°„æ“Šï¼ˆç•¶å‰è·é›¢ ${distance.toFixed(1)}"ï¼‰`, "miss");
      clearAction();
      return;
    }
    if (distance > 12) {
      log(`[ç¨è¡Œè€…] ${target.name} è·é›¢ ${distance.toFixed(1)}"ï¼Œä½†å°„æ“Šè€…æ˜¯è§’è‰²ï¼Œå¯ä»¥æ”»æ“Š`, "info");
    }
  }

  // å¦‚æœå·²ç¶“é å…ˆé¸æ“‡äº†æ­¦å™¨ï¼ˆæ–°æµç¨‹ï¼‰ï¼Œç›´æ¥ä½¿ç”¨
  if (gameState.selectedWeapon) {
    const weapon = gameState.selectedWeapon;
    const distance = pixelsToInch(Math.hypot(attacker.x - target.x, attacker.y - target.y));

    // æª¢æŸ¥å°„ç¨‹ï¼ˆé ç¨‹æ­¦å™¨ï¼‰
    if (weapon.type === "ranged" && distance > weapon.range) {
      log(`ç›®æ¨™è¶…å‡ºå°„ç¨‹ï¼(è·é›¢ ${distance.toFixed(1)}" / å°„ç¨‹ ${weapon.range}")`, "miss");
      clearAction();
      return;
    }

    // æª¢æŸ¥è¿‘æˆ°ç¯„åœ
    if (weapon.type === "melee" && distance > 1.5) {
      log(`ç›®æ¨™è¶…å‡ºè¿‘æˆ°ç¯„åœï¼`, "miss");
      clearAction();
      return;
    }

    await performAttack(attacker, target, weapon, weapon.type);
    if (weapon.type === "ranged") {
      resolveHazardous(attacker, weapon);
      attacker.hasShot = true;
    } else {
      attacker.hasFought = true;
    }

    // æ¨™è¨˜ä¸€æ¬¡æ€§æ­¦å™¨å·²ä½¿ç”¨
    if (weapon.oneUse) {
      if (!attacker.usedOneUseWeapons) attacker.usedOneUseWeapons = {};
      attacker.usedOneUseWeapons[weapon.name] = true;
      log(`âš¡ ${weapon.name} å·²ä½¿ç”¨ï¼ˆä¸€æ¬¡æ€§æ­¦å™¨ï¼‰`, "info");
    }

    clearAction();
    updateUnitLists();
    render();
    return;
  }

  if (gameState.currentAction === "shoot") {
    // èˆŠæµç¨‹ï¼šæª¢æŸ¥æ˜¯å¦æœ‰é ç¨‹æ­¦å™¨
    const rangedWeapons = [];
    if (attacker.weapons.ranged) {
      if (Array.isArray(attacker.weapons.ranged)) {
        rangedWeapons.push(...attacker.weapons.ranged);
      } else {
        rangedWeapons.push(attacker.weapons.ranged);
      }
    }

    if (rangedWeapons.length === 0) {
      log(`${attacker.name} æ²’æœ‰é ç¨‹æ­¦å™¨ï¼`, "miss");
      clearAction();
      return;
    }

    const distance = pixelsToInch(Math.hypot(attacker.x - target.x, attacker.y - target.y));

    // æ¨™è¨˜æ¯å€‹æ­¦å™¨çš„å¯ç”¨ç‹€æ…‹
    const weaponsWithStatus = rangedWeapons.map(w => {
      let available = true;
      let reason = "";
      if (distance > w.range) {
        available = false;
        reason = `è¶…å‡ºå°„ç¨‹ (${w.range}")`;
      } else if (w.oneUse && attacker.usedOneUseWeapons?.[w.name]) {
        available = false;
        reason = "å·²ä½¿ç”¨";
      }
      return { ...w, available, reason };
    });

    const availableWeapons = weaponsWithStatus.filter(w => w.available);

    if (availableWeapons.length === 0) {
      log(`æ²’æœ‰å¯ç”¨çš„æ­¦å™¨ï¼ˆè¶…å‡ºå°„ç¨‹æˆ–å·²ä½¿ç”¨ï¼‰ï¼`, "miss");
      clearAction();
      return;
    }

    // é¡¯ç¤ºæ­¦å™¨é¸æ“‡ï¼ˆåŒ…å«ä¸å¯ç”¨çš„æ­¦å™¨ï¼‰
    let weapon;
    if (availableWeapons.length === 1 && weaponsWithStatus.length === 1) {
      weapon = availableWeapons[0];
    } else {
      weapon = await showWeaponPopup(attacker, target, weaponsWithStatus, "ranged", distance);
      if (!weapon) {
        clearAction();
        return;
      }
    }

    await performAttack(attacker, target, weapon, "ranged");
    resolveHazardous(attacker, weapon);
    attacker.hasShot = true;

    // æ¨™è¨˜ä¸€æ¬¡æ€§æ­¦å™¨å·²ä½¿ç”¨
    if (weapon.oneUse) {
      if (!attacker.usedOneUseWeapons) attacker.usedOneUseWeapons = {};
      attacker.usedOneUseWeapons[weapon.name] = true;
      log(`âš¡ ${weapon.name} å·²ä½¿ç”¨ï¼ˆä¸€æ¬¡æ€§æ­¦å™¨ï¼‰`, "info");
    }
  }
  else if (gameState.currentAction === "fight") {
    // æª¢æŸ¥æ˜¯å¦æœ‰è¿‘æˆ°æ­¦å™¨
    const meleeWeapons = [];
    if (attacker.weapons.melee) {
      if (Array.isArray(attacker.weapons.melee)) {
        meleeWeapons.push(...attacker.weapons.melee);
      } else {
        meleeWeapons.push(attacker.weapons.melee);
      }
    }

    if (meleeWeapons.length === 0) {
      log(`${attacker.name} æ²’æœ‰è¿‘æˆ°æ­¦å™¨ï¼`, "miss");
      clearAction();
      return;
    }

    const distance = pixelsToInch(Math.hypot(attacker.x - target.x, attacker.y - target.y));
    if (distance > 1.5) {
      log(`ç›®æ¨™è¶…å‡ºè¿‘æˆ°ç¯„åœï¼`, "miss");
      clearAction();
      return;
    }

    // æ¨™è¨˜æ¯å€‹æ­¦å™¨çš„å¯ç”¨ç‹€æ…‹
    const weaponsWithStatus = meleeWeapons.map(w => {
      let available = true;
      let reason = "";
      // è¿‘æˆ°æ­¦å™¨é€šå¸¸éƒ½å¯ç”¨ï¼Œé™¤éæœ‰ç‰¹æ®Šé™åˆ¶
      if (w.oneUse && attacker.usedOneUseWeapons?.[w.name]) {
        available = false;
        reason = "å·²ä½¿ç”¨";
      }
      return { ...w, available, reason };
    });

    const availableWeapons = weaponsWithStatus.filter(w => w.available);

    if (availableWeapons.length === 0) {
      log(`æ²’æœ‰å¯ç”¨çš„è¿‘æˆ°æ­¦å™¨ï¼`, "miss");
      clearAction();
      return;
    }

    // é¡¯ç¤ºæ­¦å™¨é¸æ“‡ï¼ˆåŒ…å«ä¸å¯ç”¨çš„æ­¦å™¨ï¼‰
    let weapon;
    if (availableWeapons.length === 1 && weaponsWithStatus.length === 1) {
      weapon = availableWeapons[0];
    } else {
      weapon = await showWeaponPopup(attacker, target, weaponsWithStatus, "melee", distance);
      if (!weapon) {
        clearAction();
        return;
      }
    }

    await performAttack(attacker, target, weapon, "melee");
    attacker.hasFought = true;
  }

  clearAction();
  updateUnitLists();
  render();
}

// é¡¯ç¤ºé å‚™éšŠå–®ä½é¸æ“‡å°è©±æ¡†
function showReserveUnitSelection(reserveUnits) {
  const popup = document.getElementById("weaponPopup");
  const info = document.getElementById("weaponPopupInfo");
  const list = document.getElementById("weaponPopupList");

  info.innerHTML = `
    <div style="font-size: 16px; color: var(--gold); margin-bottom: 8px;">ğŸ“¡ æ·±å…¥æ‰“æ“Šéƒ¨ç½²</div>
    <div>é¸æ“‡è¦å¾æˆ°ç•¥é å‚™éšŠéƒ¨ç½²çš„å–®ä½ï¼š</div>
    <div style="font-size: 11px; color: var(--muted); margin-top: 4px;">ï¼ˆå¿…é ˆè·é›¢æ‰€æœ‰æ•µäºº9"ä»¥ä¸Šï¼‰</div>
  `;

  list.innerHTML = "";
  reserveUnits.forEach((unit, index) => {
    const btn = document.createElement("div");
    btn.style.cssText = "padding: 12px; background: rgba(102,34,170,0.2); border: 1px solid #6622aa; border-radius: 8px; cursor: pointer; margin-bottom: 8px;";
    btn.innerHTML = `
      <div style="font-weight: bold; color: var(--gold);">ğŸ“¡ ${unit.name}</div>
      <div style="font-size: 11px; color: var(--txt); margin-top: 4px;">
        HP: ${unit.currentHP}/${unit.maxHP} | ${unit.abilities?.find(a => a.includes("æ·±å…¥æ‰“æ“Š")) ? "æ·±å…¥æ‰“æ“Š" : "æˆ°ç•¥é å‚™éšŠ"}
      </div>
    `;
    btn.onmouseover = () => btn.style.background = "rgba(102,34,170,0.4)";
    btn.onmouseout = () => btn.style.background = "rgba(102,34,170,0.2)";
    btn.onclick = () => {
      popup.style.display = "none";
      gameState.selectedUnit = unit;
      gameState.currentAction = "deepstrike";
      setHint(`é»æ“Šæˆ°å ´ä½ç½®éƒ¨ç½² ${unit.name}ï¼ˆè·æ•µäºº9"+ï¼‰`);
      updateSelectedUnitInfo();
      render();
    };
    list.appendChild(btn);
  });

  // å–æ¶ˆæŒ‰éˆ•
  const cancelBtn = document.createElement("div");
  cancelBtn.style.cssText = "padding: 10px; background: rgba(100,100,100,0.2); border: 1px solid #555; border-radius: 8px; cursor: pointer; text-align: center;";
  cancelBtn.textContent = "âŒ å–æ¶ˆ";
  cancelBtn.onclick = () => {
    popup.style.display = "none";
    clearAction();
  };
  list.appendChild(cancelBtn);

  popup.style.display = "flex";
}

// é¡¯ç¤º Overwatch ç¢ºèªå°è©±æ¡†
function showOverwatchPrompt(defender, charger) {
  return new Promise((resolve) => {
    const popup = document.getElementById("weaponPopup");
    const info = document.getElementById("weaponPopupInfo");
    const list = document.getElementById("weaponPopupList");

    info.innerHTML = `
      <div style="font-size: 16px; color: var(--gold); margin-bottom: 8px;">âš ï¸ Overwatch åæ‡‰å°„æ“Š</div>
      <div><b>${charger.name}</b> æ­£åœ¨å‘ <b>${defender.name}</b> è¡é‹’ï¼</div>
      <div style="margin-top: 8px;">èŠ±è²» <b>1 CP</b> ä½¿ç”¨ Overwatch é€²è¡Œåæ‡‰å°„æ“Šï¼Ÿ</div>
      <div style="font-size: 11px; color: var(--muted); margin-top: 4px;">ï¼ˆå‘½ä¸­åªæœ‰6+æ‰æœƒæˆåŠŸï¼‰</div>
    `;

    list.innerHTML = `
      <div style="display: flex; gap: 10px; margin-top: 10px;">
        <div id="overwatchYes" style="flex: 1; padding: 12px; background: rgba(34,197,94,0.2); border: 1px solid var(--green); border-radius: 8px; cursor: pointer; text-align: center; font-weight: bold;">
          âœ… ä½¿ç”¨ Overwatch (1 CP)
        </div>
        <div id="overwatchNo" style="flex: 1; padding: 12px; background: rgba(100,100,100,0.2); border: 1px solid #555; border-radius: 8px; cursor: pointer; text-align: center;">
          âŒ ä¸ä½¿ç”¨
        </div>
      </div>
    `;

    document.getElementById("overwatchYes").onclick = () => {
      popup.style.display = "none";
      resolve(true);
    };
    document.getElementById("overwatchNo").onclick = () => {
      popup.style.display = "none";
      resolve(false);
    };

    popup.style.display = "flex";
  });
}

// é¡¯ç¤ºæ­¦å™¨é¸æ“‡å½ˆçª—
function showWeaponPopup(attacker, target, weapons, type, distance) {
  return new Promise((resolve) => {
    weaponPopupCallback = resolve;

    const popup = document.getElementById("weaponPopup");
    const info = document.getElementById("weaponPopupInfo");
    const list = document.getElementById("weaponPopupList");

    info.innerHTML = `
      <div><b>${attacker.name}</b> æ”»æ“Š <b>${target.name}</b></div>
      <div>è·é›¢: ${distance.toFixed(1)}" | é¡å‹: ${type === "ranged" ? "å°„æ“Š" : "è¿‘æˆ°"}</div>
    `;

    list.innerHTML = "";
    weapons.forEach((weapon, index) => {
      const keywords = weapon.keywords ? weapon.keywords.join(", ") : "";
      const isAvailable = weapon.available !== false; // é è¨­ç‚ºå¯ç”¨
      const btn = document.createElement("div");

      if (isAvailable) {
        // å¯ç”¨æ­¦å™¨ï¼šé‡‘è‰²é‚Šæ¡†ï¼Œå¯é»æ“Š
        btn.style.cssText = "padding: 12px; background: rgba(251,191,36,0.1); border: 1px solid var(--gold); border-radius: 8px; cursor: pointer; transition: all 0.2s;";
        btn.innerHTML = `
          <div style="font-weight: bold; color: var(--gold);">${type === "ranged" ? "ğŸ”«" : "âš”ï¸"} ${weapon.name}</div>
          <div style="font-size: 11px; color: var(--txt); margin-top: 4px;">
            ${type === "ranged" ? `å°„ç¨‹${weapon.range}"` : ""} A${weapon.A} ${type === "ranged" ? "BS" : "WS"}${weapon.skill}+ S${weapon.S} AP${weapon.AP} D${weapon.D}
          </div>
          ${keywords ? `<div style="font-size: 10px; color: #fbbf24; margin-top: 4px;">${keywords}</div>` : ""}
          ${weapon.oneUse ? `<div style="font-size: 10px; color: var(--red); margin-top: 2px;">âš¡ ä¸€æ¬¡æ€§æ­¦å™¨</div>` : ""}
        `;
        btn.onmouseover = () => btn.style.background = "rgba(251,191,36,0.2)";
        btn.onmouseout = () => btn.style.background = "rgba(251,191,36,0.1)";
        btn.onclick = () => {
          popup.style.display = "none";
          resolve(weapon);
        };
      } else {
        // ä¸å¯ç”¨æ­¦å™¨ï¼šç°è‰²ï¼Œä¸å¯é»æ“Š
        btn.style.cssText = "padding: 12px; background: rgba(100,100,100,0.2); border: 1px solid #555; border-radius: 8px; cursor: not-allowed; opacity: 0.6;";
        btn.innerHTML = `
          <div style="font-weight: bold; color: #888;">ğŸš« ${weapon.name}</div>
          <div style="font-size: 11px; color: #666; margin-top: 4px;">
            ${type === "ranged" ? `å°„ç¨‹${weapon.range}"` : ""} A${weapon.A} ${type === "ranged" ? "BS" : "WS"}${weapon.skill}+ S${weapon.S} AP${weapon.AP} D${weapon.D}
          </div>
          ${keywords ? `<div style="font-size: 10px; color: #666; margin-top: 4px;">${keywords}</div>` : ""}
          <div style="font-size: 10px; color: var(--red); margin-top: 4px; font-weight: bold;">âŒ ${weapon.reason || "ç„¡æ³•ä½¿ç”¨"}</div>
        `;
        // ä¸å¯ç”¨æ­¦å™¨ä¸èƒ½é»æ“Š
      }
      list.appendChild(btn);
    });

    popup.style.display = "flex";
  });
}

function closeWeaponPopup() {
  document.getElementById("weaponPopup").style.display = "none";
  if (weaponPopupCallback) {
    weaponPopupCallback(null);
    weaponPopupCallback = null;
  }
}

// ========== å–®ä½èƒ½åŠ›ç³»çµ± ==========

// ç²å–ç›®æ¨™çš„é˜²ç¦¦èƒ½åŠ›ï¼ˆFNPã€å‚·å®³æ¸›å…ç­‰ï¼‰
function getTargetDefenseAbilities(unit) {
  const defense = {
    fnp: 0,             // ç„¡æ‡¼æ­»äº¡ï¼ˆ0è¡¨ç¤ºæ²’æœ‰ï¼‰
    damageReduction: 0, // å‚·å®³æ¸›å…
    bodyguard: false,   // è­·è¡›å”è­°
    bodyguardRange: 3   // è­·è¡›ç¯„åœï¼ˆè‹±å‹ï¼‰
  };

  if (!unit || !unit.abilities) return defense;

  for (const ability of unit.abilities) {
    const abilityLower = ability.toLowerCase();

    // C'tan ä¸æ»…é‡‘å±¬ï¼šå‚·å®³æ¸›å…1
    if (ability.includes("ä¸æ»…é‡‘å±¬") || ability.includes("Living Metal") ||
        ability.includes("å‚·å®³-1")) {
      // C'tan ç‰¹æ®Šè¦å‰‡ï¼šæ¸›å°‘æ‰€æœ‰å—åˆ°çš„å‚·å®³1ï¼ˆæœ€ä½1ï¼‰
      if (unit.keywords && unit.keywords.includes("C'tan")) {
        defense.damageReduction = Math.max(defense.damageReduction, 1);
      }
    }

    // ç„¡æ‡¼æ­»äº¡ (Feel No Pain) 5+ / æ™‚é–“æ“æ§
    if (ability.includes("ç„¡æ‡¼æ­»äº¡") || ability.includes("ä¸æ‡¼æ­»äº¡") ||
        ability.includes("FNP") || ability.includes("Feel No Pain") ||
        ability.includes("æ™‚é–“æ“æ§") || ability.includes("ç„¡è¦–å‚·å®³")) {
      const match = ability.match(/(\d)\+/);
      if (match) {
        defense.fnp = Math.max(defense.fnp, parseInt(match[1]));
      } else {
        defense.fnp = Math.max(defense.fnp, 5); // é è¨­5+
      }
    }

    // èŸ²æ—ç—›è‹¦æŠµæŠ— (é€šå¸¸æ˜¯6+)
    if (ability.includes("ç—›è‹¦æŠµæŠ—") || ability.includes("Pain Token") ||
        ability.includes("ç”ŸåŒ–é©æ‡‰")) {
      defense.fnp = Math.max(defense.fnp, 6);
    }

    // è­·è¡›å”è­° / è­·è¡›å–®ä½
    if (ability.includes("è­·è¡›å”è­°") || ability.includes("Bodyguard") ||
        ability.includes("è­·è¡›") || ability.includes("ä¿è­·")) {
      defense.bodyguard = true;
    }

    // å …éŸŒä¸æ‹”ï¼ˆéƒ¨åˆ†å–®ä½æœ‰æ›´å¥½çš„FNPï¼‰
    if (ability.includes("å …éŸŒ") && ability.includes("4+")) {
      defense.fnp = Math.max(defense.fnp, 4);
    }
  }

  return defense;
}

// è§£æä¸¦æ‡‰ç”¨å–®ä½ç‰¹æ®Šèƒ½åŠ›
function getUnitAbilityBonus(unit, target, context) {
  const bonus = {
    attackBonus: 0,
    damageBonus: 0,
    hitBonus: 0,
    woundBonus: 0,
    apBonus: 0,
    saveBonus: 0,
    invSave: null,
    rerollHits: false,
    rerollWounds: false,
    healAfterKill: 0,
    healOnDamage: false,
    mortalWoundsOnCharge: 0,
    triggeredAbilities: []  // è¨˜éŒ„è§¸ç™¼çš„èƒ½åŠ›åç¨±
  };

  if (!unit.abilities) return bonus;

  const abilities = unit.abilities;
  const hasCharged = unit.hasCharged || context.charged;
  const isMelee = context.mode === "melee";
  const isRanged = context.mode === "ranged";

  for (const ability of abilities) {
    const abilityLower = ability.toLowerCase();

    // ===== è¡é‹’ç›¸é—œ =====
    // ä¸å¯é˜»æ“‹: è¡é‹’æ™‚+1å‚·å®³
    if ((ability.includes("ä¸å¯é˜»æ“‹") || ability.includes("Unstoppable")) && hasCharged && isMelee) {
      bonus.damageBonus += 1;
      bonus.triggeredAbilities.push("ä¸å¯é˜»æ“‹ +1å‚·å®³");
    }

    // è¡é‹’æ™‚+1æ”»æ“Š
    if ((ability.includes("è¡é‹’") && ability.includes("+1æ”»æ“Š")) ||
        (ability.includes("charge") && ability.includes("+1 attack"))) {
      if (hasCharged && isMelee) {
        bonus.attackBonus += 1;
        bonus.triggeredAbilities.push("è¡é‹’ +1æ”»æ“Š");
      }
    }

    // ===== å‘½ä¸­/è‡´å‚·åŠ æˆ =====
    // é ˜è¢–: 6"å…§å‹è»é‡æ“²å‘½ä¸­1
    if (ability.includes("é ˜è¢–") && ability.includes("é‡æ“²å‘½ä¸­")) {
      // é€™å€‹èƒ½åŠ›å½±éŸ¿é™„è¿‘å‹è»ï¼Œåœ¨é€™è£¡æ¨™è¨˜
      bonus.rerollHits = true;
      bonus.triggeredAbilities.push("é ˜è¢–å…‰ç’°");
    }

    // ç›®æ¨™é–å®š: +æ”»æ“Š
    if (ability.includes("ç›®æ¨™é–å®š") || ability.includes("Target Lock")) {
      const match = ability.match(/\+(\d+)/);
      if (match) {
        bonus.attackBonus += parseInt(match[1]);
        bonus.triggeredAbilities.push(`ç›®æ¨™é–å®š +${match[1]}æ”»æ“Š`);
      }
    }

    // ===== é˜²ç¦¦èƒ½åŠ› =====
    // éˆèƒ½è­·ç›¾ / ç„¡æ•µè±å…
    if (ability.includes("éˆèƒ½è­·ç›¾") || ability.includes("Psychic Shield")) {
      bonus.invSave = bonus.invSave ? Math.min(bonus.invSave, 4) : 4;
      bonus.triggeredAbilities.push("éˆèƒ½è­·ç›¾ 4+ç„¡æ•µ");
    }

    // æ¯’éœ§: 6"å…§å‹è»-1è¢«å‘½ä¸­ (é˜²ç¦¦æ–¹)
    if (context.isDefending && ability.includes("æ¯’éœ§")) {
      bonus.hitPenalty = 1;
      bonus.triggeredAbilities.push("æ¯’éœ§ -1è¢«å‘½ä¸­");
    }

    // ===== æ¢å¾©èƒ½åŠ› =====
    // åå™¬æ¢å¾©: é€ æˆå‚·å®³æ¢å¾©HP
    if (ability.includes("åå™¬æ¢å¾©") || ability.includes("å™¬æ®ºæ¢å¾©") ||
        ability.includes("éˆå™¬") || ability.includes("æ¢å¾©HP")) {
      bonus.healOnDamage = true;
      bonus.triggeredAbilities.push("é€ å‚·å›è¡€");
    }

    // å†ç”Ÿ / æ´»é‡‘å±¬
    if (ability.includes("å†ç”Ÿ") || ability.includes("æ´»é‡‘å±¬") || ability.includes("Living Metal")) {
      bonus.regenerate = true;
      bonus.triggeredAbilities.push("å†ç”Ÿ");
    }

    // ===== ç‰¹æ®Šæ”»æ“Š =====
    // ææ€–çªç¾: æ·±å…¥æ‰“æ“Šæ™‚é€ æˆè‡´å‘½å‚·å®³
    if (ability.includes("ææ€–çªç¾") && context.deepStrike) {
      bonus.mortalWoundsOnArrival = "D3+3";
      bonus.triggeredAbilities.push("ææ€–çªç¾");
    }

    // Hazardous æ­¦å™¨ (é€™å€‹é€šå¸¸åœ¨æ­¦å™¨é—œéµå­—è™•ç†)
    if (ability.includes("Hazardous") || ability.includes("éè¼‰")) {
      bonus.hazardous = true;
    }

    // ===== é›™å°„ / å¿«é€Ÿå°„æ“Š =====
    if (ability.includes("å¿«é€Ÿå°„æ“Š") || ability.includes("Rapid Fire")) {
      if (isRanged && context.halfRange) {
        bonus.attackBonus += bonus.attackBonus || 1;
        bonus.triggeredAbilities.push("å¿«é€Ÿå°„æ“Š");
      }
    }

    // ===== Synapse çªè§¸ =====
    if (ability.includes("Synapse") || ability.includes("çªè§¸")) {
      bonus.hasSynapse = true;
    }

    // ===== é‡ç«åŠ›æ¨¡å¼ =====
    if (ability.includes("é‡ç«åŠ›") && !unit.hasMoved && isRanged) {
      bonus.hitBonus += 1;
      bonus.triggeredAbilities.push("é‡ç«åŠ›æ¨¡å¼ +1å‘½ä¸­");
    }

    // ===== ææ‡¼å°–å˜¯ =====
    if (ability.includes("ææ‡¼å°–å˜¯") || ability.includes("Terror")) {
      bonus.causesFear = true;
      bonus.triggeredAbilities.push("ææ‡¼");
    }

    // ===== è‡´å‘½å‘½ä¸­ (Lethal Hits) =====
    if (ability.includes("è‡´å‘½å‘½ä¸­") || ability.includes("Lethal Hits") ||
        ability.includes("Lethal Hit")) {
      bonus.lethalHits = true;
      bonus.triggeredAbilities.push("è‡´å‘½å‘½ä¸­");
    }

    // ===== æŒçºŒå‘½ä¸­ (Sustained Hits) =====
    if (ability.includes("æŒçºŒå‘½ä¸­") || ability.includes("Sustained Hits")) {
      const match = ability.match(/(\d+)/);
      bonus.sustainedHits = match ? parseInt(match[1]) : 1;
      bonus.triggeredAbilities.push(`æŒçºŒå‘½ä¸­ ${bonus.sustainedHits}`);
    }

    // ===== å¸å–ç”Ÿå‘½ (è¿‘æˆ°å¾Œè‡´å‘½å‚·) =====
    if (ability.includes("å¸å–ç”Ÿå‘½") || ability.includes("éˆèƒ½å¸å–") ||
        ability.includes("è¿‘æˆ°å¾Œ") && ability.includes("è‡´å‘½å‚·")) {
      bonus.lifeDrain = true;
      const dmgMatch = ability.match(/D(\d+)/);
      bonus.lifeDrainDice = dmgMatch ? parseInt(dmgMatch[1]) : 3;
      bonus.triggeredAbilities.push("å¸å–ç”Ÿå‘½");
    }

    // ===== ç‹™æ“Š (å¯ä»¥é‡å°è§’è‰²) =====
    if (ability.includes("ç‹™æ“Š") || ability.includes("Sniper") ||
        ability.includes("Precision")) {
      bonus.precision = true;
      bonus.triggeredAbilities.push("ç‹™æ“Š");
    }

    // ===== æ¯€æ»…ç‹‚ç†± (Destroyer) =====
    if (ability.includes("æ¯€æ»…ç‹‚ç†±") || ability.includes("Destroyer Cult")) {
      bonus.rerollWounds = true;
      bonus.triggeredAbilities.push("æ¯€æ»…ç‹‚ç†±");
    }
  }

  return bonus;
}

// æ›´æ–°å°éšŠæ¨¡å‹å­˜æ´»ç‹€æ…‹ï¼ˆæ ¹æ“šå‰©é¤˜HPè¨ˆç®—ï¼‰
function updateSquadModels(unit) {
  if (!unit.isSquad || !unit.models) return;

  const totalHP = unit.maxHP;
  const currentHP = Math.max(0, unit.currentHP);
  const hpPerModel = unit.hpPerModel || Math.ceil(totalHP / unit.modelCount);

  // è¨ˆç®—æ‡‰è©²å­˜æ´»çš„æ¨¡å‹æ•¸
  const modelsAlive = Math.ceil(currentHP / hpPerModel);

  // å¾å¾Œå¾€å‰ç§»é™¤æ¨¡å‹
  let aliveCount = 0;
  for (let i = 0; i < unit.models.length; i++) {
    if (aliveCount < modelsAlive) {
      if (!unit.models[i].alive) {
        unit.models[i].alive = true; // å¾©æ´»ï¼ˆç”¨æ–¼æ¢å¾©HPçš„æƒ…æ³ï¼‰
      }
      aliveCount++;
    } else {
      if (unit.models[i].alive) {
        unit.models[i].alive = false;
        log(`ğŸ’€ ${unit.name} çš„ä¸€å€‹æ¨¡å‹è¢«æ¶ˆæ»…ï¼`, "damage");
      }
    }
  }

  unit.modelsAlive = aliveCount;
}

// æ‡‰ç”¨èƒ½åŠ›å¾Œæ•ˆæœï¼ˆå¦‚å›è¡€ï¼‰
function applyPostCombatAbilities(attacker, target, damageDealt, context) {
  const abilityBonus = getUnitAbilityBonus(attacker, target, context);

  // åå™¬æ¢å¾©ï¼šé€ æˆå‚·å®³æ™‚æ¢å¾©HP
  if (abilityBonus.healOnDamage && damageDealt > 0) {
    const healAmount = Math.min(damageDealt, 3); // æœ€å¤šå›3é»
    const oldHP = attacker.currentHP;
    attacker.currentHP = Math.min(attacker.maxHP, attacker.currentHP + healAmount);
    const actualHeal = attacker.currentHP - oldHP;
    if (actualHeal > 0) {
      playSound('heal'); // éŸ³æ•ˆï¼šæ²»ç™‚
      log(`ğŸ’š ${attacker.name} åå™¬æ¢å¾© +${actualHeal} HPï¼`, "heal");
      showFloatingText(attacker.x, attacker.y, `+${actualHeal} HP`, {
        color: "#22cc66",
        fontSize: 16,
        duration: 1200
      });
    }
  }

  // å¸å–ç”Ÿå‘½ï¼šè¿‘æˆ°å¾Œå°ç›®æ¨™é€ æˆé¡å¤–è‡´å‘½å‚·
  if (abilityBonus.lifeDrain && context.mode === "melee" && target.alive) {
    const dice = abilityBonus.lifeDrainDice || 3;
    let mortalWounds = 0;
    for (let i = 0; i < dice; i++) {
      mortalWounds += (rollD6() >= 4) ? 1 : 0; // D3 å¹³å‡è‡´å‘½å‚·
    }
    if (mortalWounds > 0) {
      log(`ğŸ’€ ${attacker.name} å¸å–ç”Ÿå‘½é€ æˆ ${mortalWounds} è‡´å‘½å‚·ï¼`, "damage");
      showFloatingText(target.x, target.y, `-${mortalWounds} è‡´å‘½å‚·`, {
        color: "#ff00ff",
        fontSize: 16,
        duration: 1500
      });
      target.currentHP -= mortalWounds;
      if (target.currentHP <= 0) {
        target.currentHP = 0;
        target.alive = false;
        log(`ğŸ’€ ${target.name} è¢«å¸å–ç”Ÿå‘½æ¶ˆæ»…ï¼`, "damage");
      }
    }
  }
}

// å›åˆé–‹å§‹æ™‚çš„å†ç”Ÿèƒ½åŠ›
function applyRegenerationAbilities() {
  const currentPlayer = gameState.currentPlayer;
  const myUnits = gameState.units.filter(u => u.player === currentPlayer && u.alive);

  for (const unit of myUnits) {
    if (!unit.abilities) continue;

    // æ´»é‡‘å±¬ / å†ç”Ÿï¼šå›åˆé–‹å§‹æ¢å¾©1å‚·å£
    const hasRegen = unit.abilities.some(a =>
      a.includes("å†ç”Ÿ") || a.includes("æ´»é‡‘å±¬") || a.includes("Living Metal")
    );

    if (hasRegen && unit.currentHP < unit.maxHP) {
      unit.currentHP = Math.min(unit.maxHP, unit.currentHP + 1);
      playSound('heal'); // éŸ³æ•ˆï¼šæ²»ç™‚
      log(`ğŸ”§ ${unit.name} æ´»é‡‘å±¬å†ç”Ÿ +1 HP`, "heal");
      showFloatingText(unit.x, unit.y, "+1 å†ç”Ÿ", {
        color: "#44aaff",
        fontSize: 14,
        duration: 1000
      });
    }
  }
}

// ========== æˆ°ç•¥é å‚™éšŠ / æ·±å…¥æ‰“æ“Šç³»çµ± (å®˜æ–¹10ç‰ˆè¦å‰‡) ==========
// Strategic Reserves: å¯æ”¾å…¥é å‚™éšŠçš„å–®ä½ï¼Œå›åˆ2+çš„ç§»å‹•éšæ®µçµæŸæ™‚å¯éƒ¨ç½²
// Deep Strike: æœ‰æ­¤èƒ½åŠ›çš„å–®ä½å¯å…è²»é€²å…¥é å‚™éšŠï¼Œä¸¦åœ¨å›åˆ2+éƒ¨ç½²æ–¼è·æ•µäºº9"å¤–

// å°‡å–®ä½æ”¾å…¥æˆ°ç•¥é å‚™éšŠ
function putInReserve(unit) {
  if (!unit || !unit.alive) return false;

  unit.inReserve = true;
  unit.deployed = false;
  unit.x = -1000; // ç§»å‡ºæˆ°å ´
  unit.y = -1000;

  log(`ğŸ“¦ ${unit.name} é€²å…¥æˆ°ç•¥é å‚™éšŠ`, "info");
  return true;
}

// å¾é å‚™éšŠéƒ¨ç½²å–®ä½ï¼ˆæ·±å…¥æ‰“æ“Šï¼‰
// å®˜æ–¹è¦å‰‡ï¼šå¿…é ˆè·é›¢æ‰€æœ‰æ•µäºº9"ä»¥ä¸Š
async function deployFromReserves(unit, x, y) {
  if (!unit || !unit.inReserve) return false;

  const DEEP_STRIKE_DISTANCE = inchToPixels(9); // 9" æœ€å°è·é›¢
  const unitSize = getUnitBaseSize(unit);

  // æª¢æŸ¥æ˜¯å¦è·é›¢æ‰€æœ‰æ•µäºº9"ä»¥ä¸Š
  const enemies = gameState.units.filter(u => u.alive && u.player !== unit.player && u.deployed);
  for (const enemy of enemies) {
    const enemySize = getUnitBaseSize(enemy);
    const dist = Math.hypot(enemy.x - x, enemy.y - y) - unitSize - enemySize;
    if (dist < DEEP_STRIKE_DISTANCE) {
      const distInches = pixelsToInch(dist);
      log(`âŒ éƒ¨ç½²ä½ç½®è·é›¢ ${enemy.name} åªæœ‰ ${distInches.toFixed(1)}"ï¼ˆéœ€ 9"+ï¼‰`, "miss");
      return false;
    }
  }

  // æª¢æŸ¥æ˜¯å¦èˆ‡å‹è»é‡ç–Š
  const friendlyUnits = gameState.units.filter(u => u !== unit && u.alive && u.deployed);
  if (!isPositionValid(x, y, unitSize, friendlyUnits)) {
    log(`âŒ éƒ¨ç½²ä½ç½®èˆ‡å…¶ä»–å–®ä½é‡ç–Š`, "miss");
    return false;
  }

  // éƒ¨ç½²æˆåŠŸ
  unit.x = x;
  unit.y = y;
  unit.inReserve = false;
  unit.deployed = true;
  unit.arrivedThisTurn = true;
  unit.hasMoved = true; // å¾é å‚™éšŠæŠµé”è¦–ç‚ºå·²ç§»å‹•

  playSound('teleport');
  log(`âœ… ${unit.name} æ·±å…¥æ‰“æ“Šéƒ¨ç½²æˆåŠŸï¼`, "hit");

  // é¡¯ç¤ºç‰¹æ•ˆ
  showFloatingText(x, y, "æ·±å…¥æ‰“æ“Š!", {
    color: "#aa66ff",
    fontSize: 16,
    duration: 1500
  });
  showExplosion(x, y, { radius: 40, color: "#6622ff", duration: 500 });

  // æª¢æŸ¥æ˜¯å¦æœ‰ã€Œææ€–çªç¾ã€èƒ½åŠ›
  if (unit.abilities?.some(a => a.includes("ææ€–çªç¾"))) {
    // å°é™„è¿‘æ•µäººé€ æˆè‡´å‘½å‚·
    const nearbyEnemies = enemies.filter(e => {
      const dist = Math.hypot(e.x - x, e.y - y);
      return dist < inchToPixels(6);
    });

    if (nearbyEnemies.length > 0) {
      const mortalWounds = rollD6();
      for (const enemy of nearbyEnemies) {
        enemy.currentHP -= mortalWounds;
        log(`ğŸ’€ ææ€–çªç¾ï¼${enemy.name} å—åˆ° ${mortalWounds} è‡´å‘½å‚·`, "damage");
        if (enemy.currentHP <= 0) {
          enemy.currentHP = 0;
          enemy.alive = false;
          log(`ğŸ’€ ${enemy.name} è¢«ææ€–çªç¾æ¶ˆæ»…ï¼`, "damage");
        }
      }
    }
  }

  updateUnitLists();
  render();
  return true;
}

// ç²å–å¯å¾é å‚™éšŠéƒ¨ç½²çš„å–®ä½
function getReserveUnits(player) {
  return gameState.units.filter(u =>
    u.player === player &&
    u.alive &&
    u.inReserve
  );
}

// æª¢æŸ¥æ˜¯å¦å¯ä»¥å¾é å‚™éšŠéƒ¨ç½²ï¼ˆå›åˆ2+ï¼‰
function canDeployFromReserves() {
  return gameState.round >= 2;
}

// å›åˆçµæŸæ™‚é‡ç½®æŠµé”ç‹€æ…‹
function resetArrivedThisTurn() {
  for (const unit of gameState.units) {
    unit.arrivedThisTurn = false;
  }
}

// ========== æˆ°é¬¥ç³»çµ± ==========
// æ˜¯å¦å•Ÿç”¨éª°å­å‹•ç•«ï¼ˆå¯åœ¨é«˜é€ŸAIæˆ°é¬¥æ™‚é—œé–‰ï¼‰
let enableDiceAnimation = true;

// ===== Tank Shockï¼ˆå¦å…‹è¡æ“Šï¼‰- æ ¸å¿ƒè¦å‰‡æ›´æ–° v1.8 =====
// è¼‰å…·è¡é‹’æˆåŠŸæ™‚ï¼Œå¯èŠ±è²»1CPï¼Œæ“²D6ç­‰æ–¼è¼‰å…·éŸŒæ€§ï¼Œ5+å„é€ æˆ1è‡´å‘½å‚·ï¼ˆæœ€å¤š6å‚·ï¼‰
async function checkTankShock(charger, target) {
  const chargerPlayer = charger.player;
  const isChargerAI = (chargerPlayer === 1 && ai1Enabled) || (chargerPlayer === 2 && ai2Enabled);

  // æª¢æŸ¥æ˜¯å¦æœ‰è¶³å¤ CP
  if (gameState.cp[chargerPlayer] < 1) {
    return;
  }

  let useTankShock = false;

  if (isChargerAI) {
    // AIæ±ºå®šæ˜¯å¦ä½¿ç”¨å¦å…‹è¡æ“Šï¼ˆæ ¹æ“šç›®æ¨™åƒ¹å€¼å’Œå‰©é¤˜CPï¼‰
    const targetValue = target.points || 100;
    const chance = aiDifficulty === "hard" ? 0.7 : (aiDifficulty === "normal" ? 0.4 : 0.2);
    useTankShock = Math.random() < chance && gameState.cp[chargerPlayer] >= 2;
  } else {
    // ç©å®¶æ±ºå®š
    useTankShock = await showTankShockPrompt(charger, target);
  }

  if (useTankShock) {
    // èŠ±è²»1CP
    if (!spendCP(chargerPlayer, 1)) {
      log(`âŒ CPä¸è¶³ï¼Œç„¡æ³•ç™¼å‹•å¦å…‹è¡æ“Š`, "info");
      return;
    }

    log(`ğŸš› ${charger.name} ç™¼å‹•å¦å…‹è¡æ“Šï¼(1CP)`, "phase");

    // æ“²D6ç­‰æ–¼è¼‰å…·éŸŒæ€§
    const toughness = charger.stats.T || 6;
    const rolls = [];
    for (let i = 0; i < toughness; i++) {
      rolls.push(rollD6());
    }

    // é¡¯ç¤ºæ“²éª°å‹•ç•«
    if (enableDiceAnimation && rolls.length <= 12) {
      await showDiceRoll(`å¦å…‹è¡æ“Š (${charger.name})`, rolls, 5, { duration: 1500 });
    }

    log(`å¦å…‹è¡æ“Šæ“²éª° (${toughness}D6): ${rolls.join(", ")} (éœ€è¦ 5+)`, "info");

    // è¨ˆç®—è‡´å‘½å‚·ï¼ˆ5+æˆåŠŸï¼Œæœ€å¤š6å‚·ï¼‰
    const mortalWounds = Math.min(6, rolls.filter(r => r >= 5).length);

    if (mortalWounds > 0) {
      log(`ğŸ’€ å¦å…‹è¡æ“Šé€ æˆ ${mortalWounds} è‡´å‘½å‚·ï¼`, "damage");
      target.currentHP -= mortalWounds;

      showFloatingText(target.x, target.y, `å¦å…‹è¡æ“Š! -${mortalWounds}`, {
        color: "#ff4444",
        fontSize: 16,
        duration: 1500
      });

      // ç·šä¸Šæ¨¡å¼åŒæ­¥
      if (isOnlineMode) {
        sendAction({ type: 'tankShock', chargerId: charger.id, targetId: target.id, damage: mortalWounds });
      }

      if (target.currentHP <= 0) {
        target.currentHP = 0;
        target.alive = false;
        log(`ğŸ’€ ${target.name} è¢«å¦å…‹è¡æ“Šæ‘§æ¯€ï¼`, "damage");
        playSound('death');
      }
    } else {
      log(`å¦å…‹è¡æ“Šæœªé€ æˆå‚·å®³`, "miss");
      showFloatingText(target.x, target.y, "å¦å…‹è¡æ“Šå¤±æ•—", {
        color: "#888888",
        fontSize: 14,
        duration: 1000
      });
    }

    await new Promise(r => setTimeout(r, 500));
  }
}

// é¡¯ç¤ºå¦å…‹è¡æ“Šç¢ºèªå°è©±æ¡†
function showTankShockPrompt(charger, target) {
  return new Promise((resolve) => {
    const popup = document.getElementById("weaponPopup");
    const info = document.getElementById("weaponPopupInfo");
    const list = document.getElementById("weaponPopupList");

    const toughness = charger.stats.T || 6;

    info.innerHTML = `
      <div style="font-size: 16px; color: var(--gold); margin-bottom: 8px;">ğŸš› å¦å…‹è¡æ“Š</div>
      <div><b>${charger.name}</b> è¡é‹’æˆåŠŸï¼</div>
      <div style="margin-top: 8px;">èŠ±è²» <b>1 CP</b> ç™¼å‹•å¦å…‹è¡æ“Šï¼Ÿ</div>
      <div style="margin-top: 8px; font-size: 12px; color: var(--muted);">
        æ“² ${toughness}D6ï¼ˆéŸŒæ€§ï¼‰ï¼Œæ¯å€‹ 5+ é€ æˆ 1 è‡´å‘½å‚·ï¼ˆæœ€å¤š6å‚·ï¼‰
      </div>
    `;

    list.innerHTML = `
      <div style="display: flex; gap: 10px; margin-top: 10px;">
        <div id="tankShockYes" style="flex: 1; padding: 12px; background: rgba(251,191,36,0.2); border: 1px solid var(--gold); border-radius: 8px; cursor: pointer; text-align: center; font-weight: bold;">
          ğŸš› å¦å…‹è¡æ“Š (1 CP)
        </div>
        <div id="tankShockNo" style="flex: 1; padding: 12px; background: rgba(100,100,100,0.2); border: 1px solid #555; border-radius: 8px; cursor: pointer; text-align: center;">
          âŒ ä¸ä½¿ç”¨
        </div>
      </div>
    `;

    popup.style.display = "block";

    document.getElementById("tankShockYes").onclick = () => {
      popup.style.display = "none";
      resolve(true);
    };

    document.getElementById("tankShockNo").onclick = () => {
      popup.style.display = "none";
      resolve(false);
    };
  });
}

// ===== Heroic Interventionï¼ˆè‹±å‹‡ä»‹å…¥ï¼‰- å®˜æ–¹10ç‰ˆè¦å‰‡ =====
// ç•¶æ•µæ–¹è¡é‹’æˆåŠŸå¾Œï¼Œ6"å…§çš„å‹æ–¹è§’è‰²å¯ä»¥ç§»å‹•æœ€å¤š3"åŠ å…¥æˆ°é¬¥
async function checkHeroicIntervention(charger, chargeTarget) {
  const defenderPlayer = chargeTarget.player;
  const INTERVENTION_RANGE = inchToPixels(6);  // 6" è§¸ç™¼ç¯„åœ
  const INTERVENTION_MOVE = inchToPixels(3);    // 3" ä»‹å…¥ç§»å‹•

  // æ‰¾å‡ºå¯ä»¥é€²è¡Œè‹±å‹‡ä»‹å…¥çš„è§’è‰²
  const eligibleCharacters = gameState.units.filter(unit => {
    if (!unit.alive || unit.player !== defenderPlayer) return false;
    if (!unit.keywords?.includes("Character")) return false;
    if (unit.isInEngagement) return false;  // å·²ç¶“åœ¨æ¥æˆ°ä¸­çš„ä¸èƒ½ä»‹å…¥
    if (unit.hasMoved) return false;  // å·²ç¶“ç§»å‹•éçš„ä¸èƒ½ä»‹å…¥

    // æª¢æŸ¥æ˜¯å¦æœ‰è‹±å‹‡ä»‹å…¥èƒ½åŠ›ï¼ˆæ‰€æœ‰è§’è‰²é»˜èªå¯ä»¥ï¼Œæˆ–æœ‰ç‰¹å®šèƒ½åŠ›ï¼‰
    const hasHeroicIntervention = unit.abilities?.some(a =>
      a.includes("è‹±å‹‡ä»‹å…¥") || a.includes("Heroic Intervention")
    ) || unit.keywords?.includes("Character");

    if (!hasHeroicIntervention) return false;

    // æª¢æŸ¥è·é›¢ï¼šéœ€åœ¨è¡é‹’ç›®æ¨™æˆ–è¡é‹’è€…6"å…§
    const distToTarget = Math.hypot(unit.x - chargeTarget.x, unit.y - chargeTarget.y);
    const distToCharger = Math.hypot(unit.x - charger.x, unit.y - charger.y);

    return distToTarget <= INTERVENTION_RANGE || distToCharger <= INTERVENTION_RANGE;
  });

  if (eligibleCharacters.length === 0) return;

  // æª¢æŸ¥æ˜¯å¦ç”±AIæ§åˆ¶
  const isDefenderAI = (defenderPlayer === 1 && ai1Enabled) || (defenderPlayer === 2 && ai2Enabled);

  for (const character of eligibleCharacters) {
    let useIntervention = false;

    if (isDefenderAI) {
      // AIæ±ºå®šæ˜¯å¦ä½¿ç”¨è‹±å‹‡ä»‹å…¥ï¼ˆç°¡å–®ï¼šè§’è‰²è¡€é‡é«˜æ™‚æ›´å¯èƒ½ä»‹å…¥ï¼‰
      const hpRatio = character.currentHP / character.maxHP;
      const chance = aiDifficulty === "hard" ? 0.7 : (aiDifficulty === "normal" ? 0.4 : 0.2);
      useIntervention = Math.random() < (chance * hpRatio);
    } else {
      // ç©å®¶æ±ºå®š
      useIntervention = await showHeroicInterventionPrompt(character, charger);
    }

    if (useIntervention) {
      // è‹±å‹‡ä»‹å…¥éœ€è¦èŠ±è²» 1CPï¼ˆæ ¸å¿ƒè¦å‰‡æ›´æ–° v1.8ï¼‰
      if (!spendCP(defenderPlayer, 1)) {
        log(`âŒ ${character.name} CPä¸è¶³ï¼Œç„¡æ³•ç™¼å‹•è‹±å‹‡ä»‹å…¥`, "info");
        continue;
      }
      log(`âš”ï¸ ${character.name} ç™¼å‹•è‹±å‹‡ä»‹å…¥ï¼(1CP)`, "phase");

      // è¨ˆç®—ä»‹å…¥ä½ç½®ï¼ˆå‘è¡é‹’è€…ç§»å‹•æœ€å¤š3"ï¼‰
      const chargerSize = getUnitBaseSize(charger);
      const characterSize = getUnitBaseSize(character);
      const distToCharger = Math.hypot(character.x - charger.x, character.y - charger.y);

      // è¨ˆç®—ç›®æ¨™ä½ç½®ï¼šæ¥è§¸è¡é‹’è€…ä½†ä¸é‡ç–Š
      const angle = Math.atan2(charger.y - character.y, charger.x - character.x);
      const targetDist = Math.min(INTERVENTION_MOVE, distToCharger - chargerSize - characterSize - inchToPixels(0.5));

      if (targetDist > 0) {
        const newX = character.x + Math.cos(angle) * targetDist;
        const newY = character.y + Math.sin(angle) * targetDist;

        // æª¢æŸ¥ä½ç½®æœ‰æ•ˆæ€§
        const friendlyUnits = gameState.units.filter(u => u !== character && u.alive && u.player === character.player);
        if (isPositionValid(newX, newY, characterSize, friendlyUnits)) {
          character.x = newX;
          character.y = newY;
          character.isInEngagement = true;
          charger.isInEngagement = true;
          updateSquadModelPositions(character); // å°éšŠæ¨¡å‹è‡ªå‹•è·Ÿéš¨

          log(`â†—ï¸ ${character.name} ç§»å‹• ${pixelsToInch(targetDist).toFixed(1)}" åŠ å…¥æˆ°é¬¥ï¼`, "hit");
          showFloatingText(character.x, character.y, "è‹±å‹‡ä»‹å…¥!", {
            color: "#ffaa00",
            fontSize: 14,
            duration: 1500
          });

          // ç·šä¸Šæ¨¡å¼åŒæ­¥
          if (isOnlineMode) {
            sendAction({ type: 'heroicIntervention', characterId: character.id, chargerId: charger.id, x: newX, y: newY });
          }

          await new Promise(r => setTimeout(r, 300));
        }
      }
    }
  }

  render();
}

// é¡¯ç¤ºè‹±å‹‡ä»‹å…¥ç¢ºèªå°è©±æ¡†
function showHeroicInterventionPrompt(character, charger) {
  return new Promise((resolve) => {
    const popup = document.getElementById("weaponPopup");
    const info = document.getElementById("weaponPopupInfo");
    const list = document.getElementById("weaponPopupList");

    info.innerHTML = `
      <div style="font-size: 16px; color: var(--gold); margin-bottom: 8px;">âš”ï¸ è‹±å‹‡ä»‹å…¥</div>
      <div><b>${charger.name}</b> æ­£åœ¨å‘ä½ çš„å–®ä½è¡é‹’ï¼</div>
      <div style="margin-top: 8px;"><b>${character.name}</b> å¯ä»¥ç§»å‹•æœ€å¤š 3" åŠ å…¥æˆ°é¬¥</div>
      <div style="margin-top: 8px;">èŠ±è²» <b>1 CP</b> ç™¼å‹•è‹±å‹‡ä»‹å…¥ï¼Ÿ</div>
      <div style="font-size: 11px; color: var(--muted); margin-top: 4px;">ï¼ˆè§’è‰²å–®ä½å¯åœ¨æ•µæ–¹è¡é‹’å¾Œä»‹å…¥ï¼‰</div>
    `;

    list.innerHTML = `
      <div style="display: flex; gap: 10px; margin-top: 10px;">
        <div id="interventionYes" style="flex: 1; padding: 12px; background: rgba(251,191,36,0.2); border: 1px solid var(--gold); border-radius: 8px; cursor: pointer; text-align: center; font-weight: bold;">
          âš”ï¸ è‹±å‹‡ä»‹å…¥ (1 CP)
        </div>
        <div id="interventionNo" style="flex: 1; padding: 12px; background: rgba(100,100,100,0.2); border: 1px solid #555; border-radius: 8px; cursor: pointer; text-align: center;">
          âŒ ä¸ä»‹å…¥
        </div>
      </div>
    `;

    document.getElementById("interventionYes").onclick = () => {
      popup.style.display = "none";
      resolve(true);
    };
    document.getElementById("interventionNo").onclick = () => {
      popup.style.display = "none";
      resolve(false);
    };

    popup.style.display = "flex";
  });
}

// ========== Pile In / Consolidate ç§»å‹• (å®˜æ–¹10ç‰ˆè¦å‰‡) ==========
// Pile In: è¿‘æˆ°å‰æœ€å¤šç§»å‹•3"å‘æœ€è¿‘çš„æ•µäºº
// Consolidate: è¿‘æˆ°å¾Œæœ€å¤šç§»å‹•3"å‘æœ€è¿‘çš„æ•µäºº

function findClosestEnemy(unit) {
  const enemies = gameState.units.filter(u => u.alive && u.player !== unit.player);
  if (enemies.length === 0) return null;

  let closest = null;
  let minDist = Infinity;
  for (const enemy of enemies) {
    const dist = Math.hypot(enemy.x - unit.x, enemy.y - unit.y);
    if (dist < minDist) {
      minDist = dist;
      closest = enemy;
    }
  }
  return closest;
}

// åŸ·è¡Œ Pile In æˆ– Consolidate ç§»å‹•ï¼ˆæœ€å¤š3"å‘æœ€è¿‘æ•µäººï¼‰
async function performPileInOrConsolidate(unit, moveName) {
  const maxMove = inchToPixels(3); // 3" æœ€å¤§ç§»å‹•
  const closestEnemy = findClosestEnemy(unit);

  if (!closestEnemy) {
    log(`${unit.name} ç„¡æ³•${moveName}ï¼šæ²’æœ‰æ•µäºº`, "info");
    return;
  }

  const distToEnemy = Math.hypot(closestEnemy.x - unit.x, closestEnemy.y - unit.y);
  const unitSize = getUnitBaseSize(unit);
  const enemySize = getUnitBaseSize(closestEnemy);
  const engagementDist = unitSize + enemySize + inchToPixels(0.5); // æ¥æˆ°è·é›¢

  // å¦‚æœå·²ç¶“åœ¨æ¥æˆ°ç¯„åœå…§ï¼Œä¸éœ€è¦ç§»å‹•
  if (distToEnemy <= engagementDist) {
    log(`${unit.name} å·²åœ¨æ¥æˆ°ç¯„åœå…§`, "info");
    return;
  }

  // è¨ˆç®—ç§»å‹•è·é›¢ï¼ˆå‘æ•µäººç§»å‹•ï¼Œæœ€å¤š3"ï¼Œä½†ä¸èƒ½è¶…éæ¥è§¸è·é›¢ï¼‰
  const angle = Math.atan2(closestEnemy.y - unit.y, closestEnemy.x - unit.x);
  const moveDistance = Math.min(maxMove, distToEnemy - engagementDist);

  if (moveDistance <= 0) return;

  const newX = unit.x + Math.cos(angle) * moveDistance;
  const newY = unit.y + Math.sin(angle) * moveDistance;

  // æª¢æŸ¥æ˜¯å¦èˆ‡å‹è»é‡ç–Š
  const friendlyUnits = gameState.units.filter(u => u !== unit && u.alive && u.player === unit.player);
  if (isPositionValid(newX, newY, unitSize, friendlyUnits)) {
    unit.x = newX;
    unit.y = newY;
    updateSquadModelPositions(unit); // å°éšŠæ¨¡å‹è‡ªå‹•è·Ÿéš¨
    const moveInches = pixelsToInch(moveDistance);
    log(`â†ªï¸ ${unit.name} ${moveName} ${moveInches.toFixed(1)}" å‘ ${closestEnemy.name}`, "info");

    // é¡¯ç¤ºç§»å‹•å‹•ç•«
    showFloatingText(unit.x, unit.y, moveName, {
      color: "#aa88ff",
      fontSize: 12,
      duration: 800
    });
  }

  render();
  await new Promise(r => setTimeout(r, 200));
}

// Pile In ç§»å‹•ï¼ˆè¿‘æˆ°å‰ï¼‰
async function performPileIn(unit) {
  await performPileInOrConsolidate(unit, "Pile In");
}

// Consolidate ç§»å‹•ï¼ˆè¿‘æˆ°å¾Œï¼‰
async function performConsolidate(unit) {
  await performPileInOrConsolidate(unit, "Consolidate");
}

// ç²å–è¿‘æˆ°éšæ®µçš„æ”»æ“Šé †åº (Fight First / Fight Last è¦å‰‡)
// å®˜æ–¹10ç‰ˆè¦å‰‡é †åºï¼š
// 1. Fights Firstï¼ˆè¡é‹’çš„å–®ä½ã€æœ‰å…ˆæ‰‹æ”»æ“Šèƒ½åŠ›çš„å–®ä½ï¼‰
// 2. æ­£å¸¸å–®ä½ï¼ˆäº¤æ›¿é¸æ“‡ï¼‰
// 3. Fights Lastï¼ˆæœ‰å¾Œæ‰‹æ”»æ“Šèƒ½åŠ›çš„å–®ä½ï¼‰
function getFightOrder() {
  const fightingUnits = [];

  // æ”¶é›†æ‰€æœ‰å¯ä»¥è¿‘æˆ°çš„å–®ä½
  for (const unit of gameState.units) {
    if (!unit.alive || unit.hasFought) continue;
    if (!unit.weapons?.melee) continue;

    // æª¢æŸ¥æ˜¯å¦åœ¨æ¥æˆ°ç¯„åœå…§æœ‰æ•µäºº
    const hasEnemyInMelee = gameState.units.some(enemy => {
      if (!enemy.alive || enemy.player === unit.player) return false;
      const dist = pixelsToInch(Math.hypot(enemy.x - unit.x, enemy.y - unit.y));
      return dist <= 1.5;
    });

    if (hasEnemyInMelee) {
      // æª¢æŸ¥ Fights First èƒ½åŠ›
      const hasFightsFirst = unit.abilities?.some(a =>
        a.includes("å…ˆæ‰‹æ”»æ“Š") || a.includes("Fights First") || a.includes("å…ˆåˆ¶æ”»æ“Š")
      );

      // æª¢æŸ¥ Fights Last èƒ½åŠ›
      const hasFightsLast = unit.abilities?.some(a =>
        a.includes("å¾Œæ‰‹æ”»æ“Š") || a.includes("Fights Last") || a.includes("ç·©æ…¢")
      );

      fightingUnits.push({
        unit: unit,
        chargedThisTurn: unit.hasCharged === true,
        hasFightsFirst: hasFightsFirst || unit.hasCharged,  // è¡é‹’è¦–ç‚º Fights First
        hasFightsLast: hasFightsLast,
        player: unit.player
      });
    }
  }

  // æ’åºï¼šå…ˆæ‰‹æ”»æ“Š > æ­£å¸¸ > å¾Œæ‰‹æ”»æ“Š
  // å®˜æ–¹è¦å‰‡ï¼šè¡é‹’çš„å–®ä½å’Œæœ‰Fights Firstèƒ½åŠ›çš„å–®ä½å…ˆæ”»æ“Šï¼ŒFights Lastæœ€å¾Œ
  fightingUnits.sort((a, b) => {
    // Fights Last æœ€å¾Œ
    if (a.hasFightsLast && !b.hasFightsLast) return 1;
    if (!a.hasFightsLast && b.hasFightsLast) return -1;

    // Fights First å„ªå…ˆï¼ˆåŒ…å«è¡é‹’ï¼‰
    if (a.hasFightsFirst && !b.hasFightsFirst) return -1;
    if (!a.hasFightsFirst && b.hasFightsFirst) return 1;

    // åŒç­‰å„ªå…ˆç´šæ™‚ï¼Œç•¶å‰ç©å®¶çš„å–®ä½å…ˆæ”»æ“Š
    if (a.player === gameState.currentPlayer && b.player !== gameState.currentPlayer) return -1;
    if (a.player !== gameState.currentPlayer && b.player === gameState.currentPlayer) return 1;
    return 0;
  });

  return fightingUnits.map(f => f.unit);
}

async function performAttack(attacker, target, weapon, mode) {
  log(`ã€${mode === "ranged" ? "å°„æ“Š" : "è¿‘æˆ°"}ã€‘${attacker.name} â†’ ${target.name}`, "phase");
  log(`ä½¿ç”¨ ${weapon.name}`, "info");

  // é¡¯ç¤ºæ”»æ“Šå‹•ç•« + éŸ³æ•ˆ
  if (mode === "ranged") {
    playSound('shoot', { weapon: weapon.name.includes('é›·å°„') || weapon.name.includes('å…‰æŸ') ? 'laser' : 'rifle' });
    showAttackLine(attacker.x, attacker.y, target.x, target.y, {
      color: "#ffaa00",
      type: "beam",
      duration: 500
    });
  } else {
    playSound('melee');
    showAttackLine(attacker.x, attacker.y, target.x, target.y, {
      color: "#ff4444",
      type: "melee",
      duration: 400
    });
  }

  // é¡¯ç¤ºæ­¦å™¨åç¨±
  showFloatingText(attacker.x, attacker.y, weapon.name, {
    color: mode === "ranged" ? "#ffaa00" : "#ff6666",
    fontSize: 14,
    duration: 1000
  });

  await new Promise(r => setTimeout(r, 200)); // ç­‰å¾…å‹•ç•«é–‹å§‹

  // ç²å–ç¨®æ—è¦å‰‡åŠ æˆ
  const context = {
    phase: mode === "ranged" ? "shooting" : "fight",
    mode: mode,
    nearObjective: isNearObjective(target),
    nearAllyMonster: isNearAllyMonster(target, attacker.player),
    charged: attacker.hasCharged
  };
  const detBonus = getDetachmentBonus(attacker.player, attacker, target, context);

  // ç²å–å–®ä½èƒ½åŠ›åŠ æˆ
  const abilityBonus = getUnitAbilityBonus(attacker, target, context);

  // é¡¯ç¤ºç¨®æ—è¦å‰‡æ•ˆæœï¼ˆå¸¶è¦–è¦ºç‰¹æ•ˆï¼‰
  const bonusTexts = [];
  if (detBonus.hitBonus) bonusTexts.push(`å‘½ä¸­+${detBonus.hitBonus}`);
  if (detBonus.strengthBonus) bonusTexts.push(`åŠ›é‡+${detBonus.strengthBonus}`);
  if (detBonus.woundBonus) bonusTexts.push(`è‡´å‚·+${detBonus.woundBonus}`);
  if (detBonus.apBonus) bonusTexts.push(`AP+${detBonus.apBonus}`);
  if (detBonus.rerollHitOnes) bonusTexts.push(`é‡æ“²å‘½ä¸­1`);
  if (detBonus.rerollWoundOnes) bonusTexts.push(`é‡æ“²è‡´å‚·1`);
  if (detBonus.attackBonus) bonusTexts.push(`æ”»æ“Š+${detBonus.attackBonus}`);

  if (bonusTexts.length > 0) {
    // é¡¯ç¤ºç¨®æ—è¦å‰‡æ¿€æ´»æ–‡å­—
    showFloatingText(attacker.x, attacker.y - 20, "âš”ï¸ " + bonusTexts[0], {
      color: "#aa66ff",
      fontSize: 12,
      duration: 1500
    });
    bonusTexts.forEach(txt => log(`[ç¨®æ—è¦å‰‡] ${txt}`, "info"));
  }

  // é¡¯ç¤ºå–®ä½èƒ½åŠ›è§¸ç™¼æ•ˆæœ
  if (abilityBonus.triggeredAbilities.length > 0) {
    abilityBonus.triggeredAbilities.forEach((abil, i) => {
      setTimeout(() => {
        showFloatingText(attacker.x, attacker.y - 40 - i * 20, "âœ¨ " + abil, {
          color: "#66ffaa",
          fontSize: 13,
          duration: 1800
        });
      }, i * 200);
      log(`[å–®ä½èƒ½åŠ›] ${abil}`, "info");
    });
  }

  // ========== æ­¦å™¨é—œéµå­—è™•ç† ==========
  const weaponKeywords = weapon.keywords || [];
  const distance = pixelsToInch(Math.hypot(attacker.x - target.x, attacker.y - target.y));
  const halfRange = weapon.range ? weapon.range / 2 : 12;
  const isHalfRange = distance <= halfRange;

  // è§£ææ­¦å™¨é—œéµå­—æ•ˆæœ
  const weaponEffects = {
    torrent: weaponKeywords.includes("Torrent"),
    twinLinked: weaponKeywords.includes("Twin-linked"),
    blast: weaponKeywords.includes("Blast"),
    indirectFire: weaponKeywords.includes("Indirect Fire"),
    ignoresCover: weaponKeywords.includes("Ignores Cover"),
    heavy: weaponKeywords.some(k => k === "Heavy" || k.startsWith("Heavy ")),
    assault: weaponKeywords.some(k => k === "Assault" || k.startsWith("Assault ")),
    rapidFire: 0,
    melta: 0,
    anti: null,
    sustainedHits: 0,
    lethalHits: weaponKeywords.includes("Lethal Hits"),
    devastatingWounds: weaponKeywords.includes("Devastating Wounds")
  };

  // è§£æ Rapid Fire X
  const rapidFireMatch = weaponKeywords.find(k => k.match(/Rapid Fire (\d+)/i));
  if (rapidFireMatch) {
    const match = rapidFireMatch.match(/Rapid Fire (\d+)/i);
    weaponEffects.rapidFire = match ? parseInt(match[1]) : 1;
  }

  // è§£æ Melta X
  const meltaMatch = weaponKeywords.find(k => k.match(/Melta (\d+)/i));
  if (meltaMatch) {
    const match = meltaMatch.match(/Melta (\d+)/i);
    weaponEffects.melta = match ? parseInt(match[1]) : 1;
  }

  // è§£æ Anti-X Y+
  const antiMatch = weaponKeywords.find(k => k.match(/Anti-(\w+) (\d+)\+/i));
  if (antiMatch) {
    const match = antiMatch.match(/Anti-(\w+) (\d+)\+/i);
    if (match) {
      weaponEffects.anti = { keyword: match[1], roll: parseInt(match[2]) };
    }
  }

  // è§£æ Sustained Hits X
  const sustainedMatch = weaponKeywords.find(k => k.match(/Sustained Hits (\d+)/i));
  if (sustainedMatch) {
    const match = sustainedMatch.match(/Sustained Hits (\d+)/i);
    weaponEffects.sustainedHits = match ? parseInt(match[1]) : 1;
  }

  // è¨ˆç®—æ”»æ“Šæ¬¡æ•¸ï¼ˆåŠ ä¸Šæ”»æ“ŠåŠ æˆï¼‰
  let attacks = weapon.A;
  if (typeof attacks === "string") {
    if (attacks.includes("D6")) {
      const base = attacks.replace("D6", "").replace("+", "") || "0";
      attacks = rollD6() + parseInt(base);
    } else if (attacks.includes("D3")) {
      const base = attacks.replace("D3", "").replace("+", "") || "0";
      attacks = Math.ceil(Math.random() * 3) + parseInt(base);
    }
  }

  // [Rapid Fire X] åŠå°„ç¨‹å…§æ”»æ“Š+X
  if (weaponEffects.rapidFire > 0 && isHalfRange && mode === "ranged") {
    const bonus = weaponEffects.rapidFire;
    attacks += bonus;
    log(`[Rapid Fire ${bonus}] åŠå°„ç¨‹å…§ +${bonus} æ”»æ“Š`, "info");
  }

  // [Blast] å°11+æ¨¡å‹å–®ä½é¡å¤– +D3 æ”»æ“Š
  if (weaponEffects.blast && target.isSquad && target.modelsAlive >= 11) {
    const blastBonus = Math.ceil(Math.random() * 3);
    attacks += blastBonus;
    log(`[Blast] å°å¤§å‹å°éšŠ +${blastBonus} æ”»æ“Š`, "info");
  } else if (weaponEffects.blast && target.isSquad && target.modelsAlive >= 6) {
    attacks += 1;
    log(`[Blast] å°6+æ¨¡å‹å°éšŠ +1 æ”»æ“Š`, "info");
  }

  // å°éšŠå–®ä½ï¼šæ”»æ“Šæ¬¡æ•¸ Ã— å­˜æ´»æ¨¡å‹æ•¸
  if (attacker.isSquad && attacker.modelsAlive) {
    const modelsAlive = attacker.modelsAlive;
    const baseAttacks = attacks;
    attacks = attacks * modelsAlive;
    log(`å°éšŠæ”»æ“Š: ${baseAttacks} Ã— ${modelsAlive}æ¨¡å‹ = ${attacks}æ¬¡`, "info");
  }

  attacks += detBonus.attackBonus || 0;
  attacks += abilityBonus.attackBonus || 0;  // å–®ä½èƒ½åŠ›æ”»æ“ŠåŠ æˆ

  log(`æ”»æ“Šæ¬¡æ•¸: ${attacks}`, "info");

  // ========== å‘½ä¸­æ“²éª° ==========
  let hitModifier = (detBonus.hitBonus || 0) + (abilityBonus.hitBonus || 0);

  // [Heavy] æœªç§»å‹•æ™‚å‘½ä¸­+1
  if (weaponEffects.heavy && !attacker.hasMoved && mode === "ranged") {
    hitModifier += 1;
    log(`[Heavy] æœªç§»å‹• â†’ å‘½ä¸­+1`, "info");
  }

  // [Indirect Fire] ç„¡æ³•ç›´è¦–ç›®æ¨™æ™‚å‘½ä¸­-1 (ç°¡åŒ–ï¼šç¸½æ˜¯-1)
  if (weaponEffects.indirectFire) {
    hitModifier -= 1;
    log(`[Indirect Fire] é–“æ¥å°„æ“Š â†’ å‘½ä¸­-1`, "info");
  }

  // ===== Stealthï¼ˆéš±åŒ¿ï¼‰è¦å‰‡ - å®˜æ–¹10ç‰ˆ =====
  // é ç¨‹æ”»æ“Šæ™‚ï¼Œæœ‰éš±åŒ¿èƒ½åŠ›çš„å–®ä½ -1 è¢«å‘½ä¸­
  if (mode === "ranged") {
    const hasStealth = target.abilities?.some(a =>
      a.includes("éš±åŒ¿") || a.includes("Stealth") || a.includes("æ½›è¡Œ")
    );
    if (hasStealth) {
      hitModifier -= 1;
      log(`[Stealth] ${target.name} éš±åŒ¿ â†’ å‘½ä¸­-1`, "info");
    }
  }

  const hitNeed = Math.max(2, weapon.skill - hitModifier);
  let hitRolls = [];

  // [Torrent] è‡ªå‹•å‘½ä¸­ï¼
  if (weaponEffects.torrent) {
    log(`[Torrent] è‡ªå‹•å‘½ä¸­ï¼è·³éå‘½ä¸­æ“²éª°`, "info");
    for (let i = 0; i < attacks; i++) hitRolls.push(6); // è¦–ç‚ºå…¨éƒ¨6å‘½ä¸­
  } else {
    for (let i = 0; i < attacks; i++) hitRolls.push(rollD6());
  }

  // é‡æ“²å‘½ä¸­1ï¼ˆç¨®æ—è¦å‰‡æˆ–å–®ä½èƒ½åŠ›ï¼‰
  if (detBonus.rerollHitOnes || abilityBonus.rerollHits) {
    hitRolls = hitRolls.map(r => r === 1 ? rollD6() : r);
  }

  // å‘½ä¸­éª°å­å‹•ç•«
  if (enableDiceAnimation && hitRolls.length <= 12) {
    await showDiceRoll(`å‘½ä¸­æ“²éª° (${attacker.name})`, hitRolls, hitNeed, { duration: 1500 });
  }

  log(`å‘½ä¸­æ“²éª°: ${hitRolls.join(", ")} (éœ€è¦ ${hitNeed}+)`, "info");

  // è¨ˆç®—å‘½ä¸­æ•¸ï¼ˆåŒ…å«æŒçºŒå‘½ä¸­å’Œè‡´å‘½å‘½ä¸­ï¼‰
  let hits = 0;
  let lethalWounds = 0;  // è‡´å‘½å‘½ä¸­ç›´æ¥è®Šæˆå‚·
  let sustainedExtra = 0; // æŒçºŒå‘½ä¸­é¡å¤–å‘½ä¸­æ•¸

  for (const roll of hitRolls) {
    // [Indirect Fire] æ ¸å¿ƒè¦å‰‡æ›´æ–° v1.8ï¼šæœªä¿®æ­£å‘½ä¸­éª°1-3ç¸½æ˜¯å¤±æ•—
    if (weaponEffects.indirectFire && roll <= 3) {
      log(`[Indirect Fire] æœªä¿®æ­£éª° ${roll} â†’ è‡ªå‹•å¤±æ•—ï¼ˆ1-3å¿…å¤±ï¼‰`, "miss");
      continue;
    }

    if (roll >= hitNeed || weaponEffects.torrent) {
      hits++;

      // è‡´å‘½å‘½ä¸­ï¼š6å‘½ä¸­ç›´æ¥è‡´å‚·ï¼ˆè·³éè‡´å‚·éª°ï¼‰- æ­¦å™¨é—œéµå­—æˆ–å–®ä½èƒ½åŠ›
      if (roll === 6 && (weaponEffects.lethalHits || abilityBonus.lethalHits)) {
        lethalWounds++;
        log(`[Lethal Hits] 6å‘½ä¸­ â†’ è‡ªå‹•è‡´å‚·ï¼`, "info");
      }

      // æŒçºŒå‘½ä¸­ï¼š6å‘½ä¸­é¡å¤–+Nå‘½ä¸­ - æ­¦å™¨é—œéµå­—æˆ–å–®ä½èƒ½åŠ›
      const sustainedValue = weaponEffects.sustainedHits || abilityBonus.sustainedHits || 0;
      if (roll === 6 && sustainedValue > 0) {
        sustainedExtra += sustainedValue;
        log(`[Sustained Hits ${sustainedValue}] +${sustainedValue} é¡å¤–å‘½ä¸­ï¼`, "info");
      }
    }
  }

  hits += sustainedExtra;
  log(`å‘½ä¸­: ${hits}/${attacks}${sustainedExtra > 0 ? ` (+${sustainedExtra}æŒçºŒå‘½ä¸­)` : ''}`, hits > 0 ? "hit" : "miss");

  if (hits === 0) {
    // é¡¯ç¤ºæœªå‘½ä¸­
    showFloatingText(target.x, target.y, "MISS", {
      color: "#888888",
      fontSize: 18,
      duration: 1000
    });
    return;
  }

  // è‡´å‚·æ“²éª°ï¼ˆåŒ…å«åŠ›é‡åŠ æˆå’Œè‡´å‚·åŠ æˆï¼‰
  const effectiveS = weapon.S + (detBonus.strengthBonus || 0);
  const woundNeed = Math.max(2, getWoundRoll(effectiveS, target.stats.T) - (detBonus.woundBonus || 0));
  const woundExplanation = `S${effectiveS} vs T${target.stats.T} â†’ ${woundNeed}+`;

  // è‡´å‘½å‘½ä¸­çš„è‡ªå‹•å‚·ä¸éœ€è¦æ“²éª°
  const hitsNeedingWoundRoll = abilityBonus.lethalHits ? (hits - lethalWounds) : hits;

  let woundRolls = [];
  for (let i = 0; i < hitsNeedingWoundRoll; i++) woundRolls.push(rollD6());

  // é‡æ“²è‡´å‚·1ï¼ˆç¨®æ—è¦å‰‡æˆ–å–®ä½èƒ½åŠ›ï¼‰
  if (detBonus.rerollWoundOnes || abilityBonus.rerollWounds) {
    woundRolls = woundRolls.map(r => r === 1 ? rollD6() : r);
  }

  // [Twin-linked] é‡æ“²æ‰€æœ‰å¤±æ•—çš„è‡´å‚·éª°
  if (weaponEffects.twinLinked) {
    woundRolls = woundRolls.map(r => r < woundNeed ? rollD6() : r);
    log(`[Twin-linked] é‡æ“²å¤±æ•—çš„è‡´å‚·éª°`, "info");
  }

  // è‡´å‚·éª°å­å‹•ç•«
  if (enableDiceAnimation && woundRolls.length <= 12) {
    await showDiceRoll(`è‡´å‚·æ“²éª° (${woundExplanation})`, woundRolls, woundNeed, { duration: 1500 });
  }

  log(`è‡´å‚·æ“²éª°: ${woundRolls.join(", ")} (${woundExplanation})`, "info");

  // [Anti-X Y+] å°ç‰¹å®šé—œéµå­—ç›®æ¨™ï¼Œè‡´å‚·éª°Y+ç‚ºè‡´å‘½å‚·
  let antiMortalWounds = 0;
  if (weaponEffects.anti && target.keywords?.includes(weaponEffects.anti.keyword)) {
    const antiRoll = weaponEffects.anti.roll;
    for (const roll of woundRolls) {
      if (roll >= antiRoll) {
        antiMortalWounds++;
        log(`[Anti-${weaponEffects.anti.keyword} ${antiRoll}+] ${roll} â†’ è‡´å‘½å‚·ï¼`, "info");
      }
    }
  }

  // [Devastating Wounds] è‡´å‚·éª°6ç„¡è¦–è±å…ç›´æ¥é€ å‚·
  let devastatingWounds = 0;
  if (weaponEffects.devastatingWounds) {
    devastatingWounds = woundRolls.filter(r => r === 6).length;
    if (devastatingWounds > 0) {
      log(`[Devastating Wounds] ${devastatingWounds}å€‹6 â†’ ç„¡è¦–è±å…ï¼`, "info");
    }
  }

  // è‡´å‚·æ•¸ = æ“²éª°æˆåŠŸ + è‡´å‘½å‘½ä¸­è‡ªå‹•å‚·
  const woundRollSuccesses = woundRolls.filter(r => r >= woundNeed).length;
  const wounds = woundRollSuccesses + lethalWounds + antiMortalWounds;
  if (lethalWounds > 0) {
    log(`è‡´å‚·: ${wounds}/${hits} (å« ${lethalWounds} è‡´å‘½å‘½ä¸­)`, wounds > 0 ? "hit" : "miss");
  } else {
    log(`è‡´å‚·: ${wounds}/${hits}`, wounds > 0 ? "hit" : "miss");
  }

  if (wounds === 0) {
    showFloatingText(target.x, target.y, "æŠµæ“‹!", {
      color: "#4488ff",
      fontSize: 16,
      duration: 1000
    });
    return;
  }

  // è±å…æ“²éª° (å®˜æ–¹10ç‰ˆè¦å‰‡)
  // APåŠ æˆï¼ˆå¦‚ Pantheon of Woeï¼‰
  const effectiveAP = (weapon.AP || 0) + (detBonus.apBonus || 0);

  // æ©è­·åŠ æˆ: +1è­·ç”²è±å…ï¼Œä½†è­·ç”²3+æˆ–æ›´å¥½é¢å°AP0æ™‚ä¸é©ç”¨
  // [Ignores Cover] ç„¡è¦–æ©è­·åŠ æˆ
  let saveNeed = target.stats.Sv - effectiveAP;
  const canBenefitFromCover = target.inCover &&
    !(target.stats.Sv <= 3 && effectiveAP === 0) &&
    !weaponEffects.ignoresCover;
  if (canBenefitFromCover) {
    saveNeed += 1; // æ©è­·+1è±å…
    log(`æ©è­·åŠ æˆ: +1è±å…`, "info");
  } else if (target.inCover && weaponEffects.ignoresCover) {
    log(`[Ignores Cover] ç„¡è¦–æ©è­·ï¼`, "info");
  }
  saveNeed = Math.max(2, Math.min(7, saveNeed));

  // ç¨®æ—è¦å‰‡çš„ç„¡æ•µè±å…ï¼ˆå¦‚ Warrior Bioform Onslaughtï¼‰
  let targetInv = target.inv;
  const defenderBonus = getDetachmentBonus(target.player, target, attacker, { phase: "defense" });
  if (defenderBonus.invSave && (!targetInv || defenderBonus.invSave < targetInv)) {
    targetInv = defenderBonus.invSave;
    log(`[ç¨®æ—è¦å‰‡] ${target.name} ç²å¾— ${targetInv}+ ç„¡æ•µè±å…`, "info");
  }

  // ç„¡æ•µè±å…
  if (targetInv && targetInv < saveNeed) {
    saveNeed = targetInv;
    log(`ä½¿ç”¨ç„¡æ•µè±å… ${saveNeed}+`, "info");
  }

  const saveRolls = [];
  for (let i = 0; i < wounds; i++) saveRolls.push(rollD6());

  // è±å…éª°å­å‹•ç•«ï¼ˆæ³¨æ„ï¼šè±å…æ˜¯é«˜æ–¼æ‰æˆåŠŸï¼Œæ‰€ä»¥å¤±æ•—çš„é¡¯ç¤ºç‚ºç´…è‰²ï¼‰
  // è±å…éª°ç”±é˜²å®ˆæ–¹ï¼ˆå—å‚·å–®ä½çš„ç©å®¶ï¼‰æ“²
  if (enableDiceAnimation && saveRolls.length <= 12) {
    await showDiceRoll(`è±å…æ“²éª° (${target.name} ${saveNeed}+)`, saveRolls, saveNeed, {
      duration: 2000,
      rollingPlayer: target.player  // é˜²å®ˆæ–¹æ“²éª°
    });
  }

  log(`è±å…æ“²éª°: ${saveRolls.join(", ")} (éœ€è¦ ${saveNeed}+${target.inCover ? " å«æ©è­·" : ""})`, "info");

  // [Devastating Wounds] è‡´å‚·éª°6ç„¡è¦–è±å…ï¼Œç›´æ¥è¨ˆå…¥å¤±æ•—è±å…
  const regularSaveRolls = wounds - devastatingWounds;
  const failed = saveRolls.filter(r => r < saveNeed).length + devastatingWounds;
  log(`å¤±æ•—è±å…: ${failed}/${wounds}${devastatingWounds > 0 ? ` (å«${devastatingWounds}æ¯€æ»…å‚·å®³)` : ''}`, failed > 0 ? "damage" : "hit");

  if (failed === 0) {
    showFloatingText(target.x, target.y, "ğŸ›¡ï¸ è±å…!", {
      color: "#22cc66",
      fontSize: 16,
      duration: 1000
    });
    return;
  }

  // è¨ˆç®—å‚·å®³ï¼ˆåŒ…å«å–®ä½èƒ½åŠ›å‚·å®³åŠ æˆï¼‰
  let totalDamage = 0;

  // æª¢æŸ¥ç›®æ¨™çš„é˜²ç¦¦èƒ½åŠ›
  const targetDefense = getTargetDefenseAbilities(target);

  for (let i = 0; i < failed; i++) {
    let dmg = weapon.D;
    if (typeof dmg === "string" && dmg.includes("D6")) {
      dmg = rollD6();
    } else if (typeof dmg === "string" && dmg.includes("D3")) {
      dmg = Math.ceil(Math.random() * 3);
    } else if (typeof dmg === "string" && dmg.includes("+")) {
      const parts = dmg.split("+");
      dmg = rollD6() + parseInt(parts[1] || 0);
    }
    // åŠ ä¸Šå–®ä½èƒ½åŠ›å‚·å®³åŠ æˆï¼ˆå¦‚ä¸å¯é˜»æ“‹ï¼šè¡é‹’+1å‚·å®³ï¼‰
    dmg = parseInt(dmg) + (abilityBonus.damageBonus || 0);

    // [Melta X] åŠå°„ç¨‹å…§å‚·å®³+X
    if (weaponEffects.melta > 0 && isHalfRange) {
      dmg += weaponEffects.melta;
      if (i === 0) log(`[Melta ${weaponEffects.melta}] åŠå°„ç¨‹å…§å‚·å®³+${weaponEffects.melta}`, "info");
    }

    // C'tan ä¸æ»…é‡‘å±¬ï¼šæ¸›å°‘1å‚·å®³ï¼ˆæœ€ä½1ï¼‰
    if (targetDefense.damageReduction > 0) {
      const reduced = Math.max(1, dmg - targetDefense.damageReduction);
      if (reduced < dmg) {
        log(`[ä¸æ»…é‡‘å±¬] å‚·å®³æ¸›å°‘ ${dmg} â†’ ${reduced}`, "info");
        dmg = reduced;
      }
    }

    // ç„¡æ‡¼æ­»äº¡ (FNP)ï¼šé¡å¤–è±å…æª¢å®š
    if (targetDefense.fnp > 0) {
      const fnpRoll = rollD6();
      if (fnpRoll >= targetDefense.fnp) {
        log(`[ç„¡æ‡¼æ­»äº¡] ${fnpRoll} â‰¥ ${targetDefense.fnp}+ å¿½ç•¥å‚·å®³!`, "info");
        showFloatingText(target.x, target.y - 20, `FNP ${fnpRoll}+`, {
          color: "#44ff88",
          fontSize: 14,
          duration: 1000
        });
        continue; // å¿½ç•¥é€™æ¬¡å‚·å®³
      } else {
        log(`[ç„¡æ‡¼æ­»äº¡] ${fnpRoll} < ${targetDefense.fnp}+ å¤±æ•—`, "info");
      }
    }

    totalDamage += dmg;
  }

  log(`é€ æˆ ${totalDamage} é»å‚·å®³ï¼`, "damage");

  // è¨˜éŒ„æˆ°é¬¥æ­·å²
  addBattleHistory(attacker, `ğŸ”« æ”»æ“Š ${target.name}ï¼Œé€ æˆ ${totalDamage} å‚·å®³`, "attack");
  addBattleHistory(target, `ğŸ’¥ è¢« ${attacker.name} æ”»æ“Šï¼Œå—åˆ° ${totalDamage} å‚·å®³`, "damage");

  // éŸ³æ•ˆï¼šå‘½ä¸­
  playSound('hit');
  if (totalDamage >= 5) {
    playSound('explosion', { size: 'medium' });
  }

  // é¡¯ç¤ºå‚·å®³æ•¸å­—å’Œçˆ†ç‚¸æ•ˆæœ
  showDamageNumber(target.x, target.y, totalDamage, totalDamage >= 5);
  showExplosion(target.x, target.y, {
    radius: 15 + totalDamage * 2,
    color: totalDamage >= 5 ? "#ff0000" : "#ff6600"
  });

  // æ‡‰ç”¨æˆ°å¾Œèƒ½åŠ›æ•ˆæœï¼ˆå¦‚åå™¬æ¢å¾©ï¼‰
  applyPostCombatAbilities(attacker, target, totalDamage, context);

  target.currentHP -= totalDamage;

  // å°éšŠå–®ä½ï¼šæ ¹æ“šHPæå¤±ç§»é™¤æ¨¡å‹
  if (target.isSquad && target.models) {
    updateSquadModels(target);
  }

  if (target.currentHP <= 0) {
    target.currentHP = 0;
    target.alive = false;
    log(`ğŸ’€ ${target.name} è¢«æ¶ˆæ»…ï¼`, "damage");

    // è¨˜éŒ„æ“Šæ®ºæ­·å²
    addBattleHistory(attacker, `ğŸ’€ æ“Šæ®ºäº† ${target.name}ï¼`, "kill");
    addBattleHistory(target, `ğŸ’€ è¢« ${attacker.name} æ¶ˆæ»…`, "death");

    // éŸ³æ•ˆï¼šæ­»äº¡
    playSound('death');
    playSound('explosion', { size: 'large' });

    // å–®ä½è¢«æ¶ˆæ»…æ™‚é¡¯ç¤ºå¤§çˆ†ç‚¸
    showExplosion(target.x, target.y, {
      radius: 50,
      color: "#ff0000",
      duration: 500
    });
    showFloatingText(target.x, target.y, "ğŸ’€ æ“Šæ®º!", {
      color: "#ff0000",
      fontSize: 20,
      duration: 2000
    });

    // ===== Deadly Demiseï¼ˆè‡´å‘½æ¯€æ»…ï¼‰- å®˜æ–¹10ç‰ˆè¦å‰‡ =====
    // æœ‰è‡´å‘½æ¯€æ»…èƒ½åŠ›çš„å–®ä½è¢«æ‘§æ¯€æ™‚ï¼Œå°é™„è¿‘å–®ä½é€ æˆè‡´å‘½å‚·
    resolveDeadlyDemise(target);

    // ===== Transport Destroyedï¼ˆé‹è¼¸è¼‰å…·è¢«æ‘§æ¯€ï¼‰- å®˜æ–¹10ç‰ˆè¦å‰‡ =====
    // é‹è¼¸è¼‰å…·è¢«æ‘§æ¯€æ™‚ï¼Œæ­è¼‰çš„å–®ä½å¿…é ˆç·Šæ€¥ä¸‹è»Š
    if (target.embarkedUnits && target.embarkedUnits.length > 0) {
      handleTransportDestroyed(target);
    }

    // ===== æ¬¡è¦ä»»å‹™æª¢æŸ¥ =====
    // å–®ä½è¢«æ¶ˆæ»…æ™‚æª¢æŸ¥æ¬¡è¦ä»»å‹™å®Œæˆæ¢ä»¶
    checkSecondaryMissions(attacker.player, {
      type: "kill",
      killedUnit: target,
      killer: attacker
    });

    // æ›´æ–°ä»»å‹™é€²åº¦
    if (gameState.missionProgress && gameState.missionProgress[attacker.player]) {
      gameState.missionProgress[attacker.player].killedThisRound++;
      gameState.missionProgress[attacker.player].modelsKilled += (target.isSquad ? target.modelCount : 1);
    }
  }

  checkVictory();

  // ç·šä¸Šæ¨¡å¼åŒæ­¥æ”»æ“Šçµæœ
  if (isOnlineMode) {
    syncGameStateToFirebase();
  }
}


// ===== Deadly Demiseï¼ˆè‡´å‘½æ¯€æ»…ï¼‰- å®˜æ–¹10ç‰ˆè¦å‰‡ =====
// æœ‰è‡´å‘½æ¯€æ»…èƒ½åŠ›çš„å–®ä½è¢«æ‘§æ¯€æ™‚ï¼Œå°é™„è¿‘6"å…§çš„å–®ä½é€ æˆè‡´å‘½å‚·
function resolveDeadlyDemise(destroyedUnit) {
  if (!destroyedUnit || !destroyedUnit.abilities) return;

  // æ‰¾å‡ºè‡´å‘½æ¯€æ»…èƒ½åŠ›
  const deadlyDemiseAbility = destroyedUnit.abilities.find(a =>
    a.includes("è‡´å‘½æ¯€æ»…") || a.includes("Deadly Demise") || a.includes("çˆ†ç‚¸æ­»äº¡")
  );

  if (!deadlyDemiseAbility) return;

  // è§£æè‡´å‘½æ¯€æ»…çš„å‚·å®³éª°ï¼ˆé»˜èªD3ï¼‰
  let damageFormula = "D3";
  const match = deadlyDemiseAbility.match(/(D\d+|\d+)/);
  if (match) {
    damageFormula = match[1];
  }

  // è¨ˆç®—å‚·å®³
  let damage = 0;
  if (damageFormula === "D3") {
    damage = Math.ceil(Math.random() * 3);
  } else if (damageFormula === "D6") {
    damage = rollD6();
  } else if (damageFormula.startsWith("D")) {
    const sides = parseInt(damageFormula.substring(1));
    damage = Math.ceil(Math.random() * sides);
  } else {
    damage = parseInt(damageFormula) || 1;
  }

  log(`ğŸ’¥ ${destroyedUnit.name} è§¸ç™¼è‡´å‘½æ¯€æ»…ï¼`, "damage");

  // å°6"å…§çš„æ‰€æœ‰å–®ä½é€ æˆè‡´å‘½å‚·
  const DEADLY_DEMISE_RANGE = inchToPixels(6);
  const nearbyUnits = gameState.units.filter(u =>
    u.alive && u !== destroyedUnit &&
    Math.hypot(u.x - destroyedUnit.x, u.y - destroyedUnit.y) <= DEADLY_DEMISE_RANGE
  );

  for (const unit of nearbyUnits) {
    // æ“²éª°æ±ºå®šæ˜¯å¦å—å‚·ï¼ˆå®˜æ–¹è¦å‰‡ï¼šæ“²D6ï¼Œ4+é€ æˆå‚·å®³ï¼‰
    const roll = rollD6();
    if (roll >= 4) {
      unit.currentHP -= damage;
      log(`ğŸ’¥ ${unit.name} å—åˆ°è‡´å‘½æ¯€æ»…å‚·å®³ï¼š-${damage} HP (æ“² ${roll})`, "damage");

      showFloatingText(unit.x, unit.y, `-${damage} è‡´å‘½æ¯€æ»…`, {
        color: "#ff6600",
        fontSize: 14,
        duration: 1500
      });

      if (unit.currentHP <= 0) {
        unit.currentHP = 0;
        unit.alive = false;
        log(`ğŸ’€ ${unit.name} è¢«è‡´å‘½æ¯€æ»…æ¶ˆæ»…ï¼`, "damage");
        // éæ­¸è§¸ç™¼è©²å–®ä½çš„è‡´å‘½æ¯€æ»…
        resolveDeadlyDemise(unit);
      }
    } else {
      log(`âš¡ ${unit.name} èº²éè‡´å‘½æ¯€æ»… (æ“² ${roll})`, "info");
    }
  }

  // é¡¯ç¤ºçˆ†ç‚¸æ•ˆæœ
  showExplosion(destroyedUnit.x, destroyedUnit.y, {
    radius: 80,
    color: "#ff8800",
    duration: 800
  });
}

function resolveHazardous(attacker, weapon) {
  if (!weapon || !weapon.keywords || !weapon.keywords.includes("Hazardous")) return;
  // 10ç‰ˆï¼šä½¿ç”¨Hazardousæ­¦å™¨å®Œæˆæ”»æ“Šå¾Œï¼Œæ“²1D6ï¼›è‹¥ç‚º1ï¼Œæ‰¿å—3é»è‡´å‘½å‚·ï¼ˆç°¡åŒ–ï¼šç›´æ¥æ‰£HPï¼‰
  const r = rollD6();
  log(`âš ï¸ Hazardous æª¢å®š: ${r} (1æœƒå›ç«)`, "info");
  if (r === 1) {
    const mortals = 3;
    attacker.currentHP -= mortals;
    log(`ğŸ’¥ ${attacker.name} å—åˆ° Hazardous å›ç«ï¼š-${mortals} HP`, "damage");
    if (attacker.currentHP <= 0) {
      attacker.currentHP = 0;
      attacker.alive = false;
      log(`ğŸ’€ ${attacker.name} å› å›ç«è¢«æ¶ˆæ»…ï¼`, "damage");
    }
  }
}

function rollD6() {

  return Math.floor(Math.random() * 6) + 1;
}

// å®˜æ–¹10ç‰ˆå‚·å®³è¡¨
// S >= 2Ã—T â†’ 2+
// S > T â†’ 3+
// S = T â†’ 4+
// S < T â†’ 5+
// S <= T/2 â†’ 6+
function getWoundRoll(S, T) {
  if (S >= T * 2) return 2;      // Sæ˜¯Tçš„å…©å€æˆ–æ›´å¤š
  if (S > T) return 3;           // Så¤§æ–¼T
  if (S === T) return 4;         // Sç­‰æ–¼T
  if (S <= T / 2) return 6;      // Sæ˜¯Tçš„ä¸€åŠæˆ–æ›´å°‘ï¼ˆä¿®æ­£é †åºï¼‰
  return 5;                      // Så°æ–¼T
}

// ç²å–å‚·å®³è¡¨èªªæ˜
function getWoundRollExplanation(S, T) {
  if (S >= T * 2) return `S${S} â‰¥ 2Ã—T${T} â†’ 2+`;
  if (S > T) return `S${S} > T${T} â†’ 3+`;
  if (S === T) return `S${S} = T${T} â†’ 4+`;
  if (S <= T / 2) return `S${S} â‰¤ T${T}/2 â†’ 6+`;
  return `S${S} < T${T} â†’ 5+`;
}

// ========== æ©è­·æª¢æ¸¬ ==========
function checkCover(unit) {
  unit.inCover = false;
  for (const t of gameState.terrain) {
    if (unit.x >= t.x - t.width/2 && unit.x <= t.x + t.width/2 &&
        unit.y >= t.y - t.height/2 && unit.y <= t.y + t.height/2) {
      unit.inCover = true;
      break;
    }
  }
}

// ========== æ¥æˆ°ç¯„åœæª¢æ¸¬ (å®˜æ–¹10ç‰ˆè¦å‰‡) ==========
// æª¢æ¸¬å–®ä½æ˜¯å¦åœ¨æ•µäººçš„æ¥æˆ°ç¯„åœï¼ˆ1"ï¼‰å…§
function checkEngagement(unit) {
  if (!unit || !unit.alive) return false;

  const unitSize = getUnitBaseSize(unit);
  const enemies = gameState.units.filter(u => u.alive && u.player !== unit.player);

  for (const enemy of enemies) {
    const enemySize = getUnitBaseSize(enemy);
    const dist = Math.hypot(enemy.x - unit.x, enemy.y - unit.y);
    const engagementDist = unitSize + enemySize + inchToPixels(1);

    if (dist <= engagementDist) {
      unit.isInEngagement = true;
      return true;
    }
  }

  unit.isInEngagement = false;
  return false;
}

// æ›´æ–°æ‰€æœ‰å–®ä½çš„æ¥æˆ°ç‹€æ…‹
function updateAllEngagementStatus() {
  for (const unit of gameState.units) {
    if (unit.alive) {
      checkEngagement(unit);
    }
  }
}

// ===== Leaderï¼ˆé ˜è¢–ï¼‰é™„åŠ ç³»çµ± - å®˜æ–¹10ç‰ˆè¦å‰‡ =====
// è§’è‰²å¯ä»¥é™„åŠ åˆ°è­·è¡›å–®ä½ï¼Œåˆ†äº«èƒ½åŠ›ä¸¦ç²å¾—ä¿è­·
// æª¢æŸ¥å–®ä½æ˜¯å¦æœ‰é™„åŠ çš„é ˜è¢–
function getAttachedLeader(unit) {
  if (!unit || !unit.alive) return null;

  // æª¢æŸ¥æ˜¯å¦æ˜¯å¯é™„åŠ çš„å–®ä½é¡å‹ï¼ˆè­·è¡›å–®ä½ï¼‰
  const isBodyguardUnit = unit.keywords?.includes("Bodyguard") ||
    unit.abilities?.some(a => a.includes("è­·è¡›") || a.includes("Bodyguard"));

  if (!isBodyguardUnit) return null;

  // åœ¨3"å…§å°‹æ‰¾å¯é™„åŠ çš„è§’è‰²
  const LEADER_RANGE = inchToPixels(3);
  const leaders = gameState.units.filter(leader => {
    if (!leader.alive || leader.player !== unit.player) return false;
    if (!leader.keywords?.includes("Character")) return false;

    const dist = Math.hypot(leader.x - unit.x, leader.y - unit.y);
    return dist <= LEADER_RANGE;
  });

  return leaders.length > 0 ? leaders[0] : null;
}

// ç²å–é ˜è¢–çš„å…‰ç’°æ•ˆæœ
function getLeaderAuraBonus(leader, unit, context) {
  const bonus = {
    hitBonus: 0,
    woundBonus: 0,
    rerollHitOnes: false,
    rerollWoundOnes: false,
    invSave: null,
    fnp: 0,
    leaderAbilities: []
  };

  if (!leader || !leader.abilities) return bonus;

  for (const ability of leader.abilities) {
    const abilityLower = ability.toLowerCase();

    // é ˜å°å…‰ç’°ï¼šé‡æ“²å‘½ä¸­1
    if (ability.includes("é ˜å°") && ability.includes("é‡æ“²å‘½ä¸­")) {
      bonus.rerollHitOnes = true;
      bonus.leaderAbilities.push("é ˜å°å…‰ç’°ï¼šé‡æ“²å‘½ä¸­1");
    }

    // é ˜å°å…‰ç’°ï¼šé‡æ“²è‡´å‚·1
    if (ability.includes("é ˜å°") && ability.includes("é‡æ“²è‡´å‚·")) {
      bonus.rerollWoundOnes = true;
      bonus.leaderAbilities.push("é ˜å°å…‰ç’°ï¼šé‡æ“²è‡´å‚·1");
    }

    // è­·ç›¾/ç„¡æ•µè±å…
    if (ability.includes("è­·ç›¾") || ability.includes("Shield")) {
      const match = ability.match(/(\d)\+/);
      if (match) {
        const invValue = parseInt(match[1]);
        if (!bonus.invSave || invValue < bonus.invSave) {
          bonus.invSave = invValue;
          bonus.leaderAbilities.push(`é ˜è¢–è­·ç›¾ï¼š${invValue}+ ç„¡æ•µ`);
        }
      }
    }

    // æ¿€å‹µï¼šå‘½ä¸­+1
    if (ability.includes("æ¿€å‹µ") || ability.includes("Inspiring")) {
      bonus.hitBonus += 1;
      bonus.leaderAbilities.push("æ¿€å‹µï¼šå‘½ä¸­+1");
    }

    // æˆ°è¡“å¤©æ‰ï¼šè‡´å‚·+1
    if (ability.includes("æˆ°è¡“") && ability.includes("å¤©æ‰")) {
      bonus.woundBonus += 1;
      bonus.leaderAbilities.push("æˆ°è¡“å¤©æ‰ï¼šè‡´å‚·+1");
    }
  }

  return bonus;
}

// é ˜è¢–è­·è¡›ï¼šæ”»æ“Šè­·è¡›å–®ä½æ™‚ï¼Œé ˜è¢–å¯ä»¥æ‰¿å—å‚·å®³
function checkLeaderLookOut(target, damage) {
  if (!target.keywords?.includes("Character")) return { redirected: false };

  // å°‹æ‰¾é™„è¿‘çš„è­·è¡›å–®ä½
  const BODYGUARD_RANGE = inchToPixels(3);
  const bodyguards = gameState.units.filter(unit => {
    if (!unit.alive || unit.player !== target.player) return false;
    if (unit === target) return false;

    const isBodyguard = unit.keywords?.includes("Bodyguard") ||
      unit.abilities?.some(a => a.includes("è­·è¡›") || a.includes("Bodyguard"));
    if (!isBodyguard) return false;

    const dist = Math.hypot(unit.x - target.x, unit.y - target.y);
    return dist <= BODYGUARD_RANGE;
  });

  if (bodyguards.length === 0) return { redirected: false };

  // é¸æ“‡ç¬¬ä¸€å€‹è­·è¡›ä¾†æ‰¿å—å‚·å®³
  const bodyguard = bodyguards[0];
  log(`ğŸ›¡ï¸ ${bodyguard.name} ç‚º ${target.name} æ“‹ä¸‹å‚·å®³ï¼`, "info");

  return {
    redirected: true,
    bodyguard: bodyguard
  };
}

// ========== éšæ®µæ§åˆ¶ ==========
// åŸ·è¡ŒæŒ‡æ®éšæ®µçš„å¯¦éš›æ“ä½œï¼ˆä¸è¨­å®š phaseï¼Œä¾›ç·šä¸Šæ¨¡å¼ä½¿ç”¨ï¼‰
async function executeCommandPhase() {
  console.warn('[executeCommandPhase] é–‹å§‹åŸ·è¡ŒæŒ‡æ®éšæ®µ');

  // æ¸…é™¤ä¹‹å‰çš„ç‰¹æ•ˆ
  clearAllVisualEffects();
  hideDiceOverlay();

  const playerName = gameState.currentPlayer === 1 ?
    (ai1Enabled ? "AI-1" : "ç©å®¶ä¸€") :
    (ai2Enabled ? "AI-2" : "ç©å®¶äºŒ");
  log(`ã€${playerName}æŒ‡æ®éšæ®µé–‹å§‹ã€‘`, "phase");

  // æŒ‡æ®éšæ®µé–‹å§‹ï¼Œé›™æ–¹å„+1 CP
  gainCPAtCommandStart();

  // æ‡‰ç”¨å›åˆé–‹å§‹çš„å†ç”Ÿèƒ½åŠ›ï¼ˆæ´»é‡‘å±¬ç­‰ï¼‰
  applyRegenerationAbilities();

  // è¨ˆç®—ç›®æ¨™æ§åˆ¶ç‹€æ…‹
  computeObjectiveControl();

  // è¨ˆç®—VPç²å¾—
  const gain = scorePrimary(gameState.currentPlayer);
  const controlCount = gameState.objectives.filter(o => o.control === gameState.currentPlayer).length;
  const prevVP = gameState.vp[gameState.currentPlayer];
  gameState.vp[gameState.currentPlayer] += gain;
  updateVPDisplay();

  if (gain > 0) {
    log(`ğŸ† ${playerName}æ§åˆ¶ ${controlCount} å€‹ç›®æ¨™ â†’ +${gain} VP (ç¸½è¨ˆ: ${prevVP} â†’ ${gameState.vp[gameState.currentPlayer]})`, "phase");
    playSound('click');
  } else {
    log(`âš ï¸ ${playerName}æœªæ§åˆ¶ä»»ä½•ç›®æ¨™ï¼Œæœ¬å›åˆ+0 VP`, "info");
  }

  // é¡¯ç¤ºæˆ°ç•¥é¸æ“‡å½ˆçª—ï¼ˆç©å®¶æ§åˆ¶æ™‚ï¼Œæœ‰CPä¸”æœ‰æˆ°ç•¥æ™‚ï¼‰
  const isAI = (gameState.currentPlayer === 1 && ai1Enabled) || (gameState.currentPlayer === 2 && ai2Enabled);
  if (!isAI && gameState.cp[gameState.currentPlayer] >= 1) {
    try {
      await showStratagemPopup("command");
    } catch (e) {
      console.error("Stratagem popup error:", e);
    }
  }

  // æˆ°æ…„æ¸¬è©¦
  const currentUnits = gameState.units.filter(u => u.player === gameState.currentPlayer && u.alive);
  for (const unit of currentUnits) {
    if (unit.currentHP <= unit.maxHP / 2) {
      const roll = rollD6() + rollD6();
      if (roll >= unit.stats.Ld) {
        unit.battleShocked = false;
        log(`${unit.name} æˆ°æ…„æ¸¬è©¦é€šé (${roll} â‰¥ ${unit.stats.Ld}+)`, "hit");
      } else {
        unit.battleShocked = true;
        log(`${unit.name} æˆ°æ…„ï¼OCè®Šç‚º0 (${roll} < ${unit.stats.Ld}+)`, "miss");
      }
    }
  }

  // Necrons å¾©æ´»å”è­°
  for (const unit of currentUnits) {
    if (unit.faction === "necrons" && unit.currentHP < unit.maxHP) {
      const healed = Math.min(rollD6() % 3 + 1, unit.maxHP - unit.currentHP);
      unit.currentHP += healed;
      log(`${unit.name} å¾©æ´»å”è­°ï¼šæ¢å¾© ${healed} å‚·å£`, "hit");
    }
  }

  updateUnitLists();

  // ç·šä¸Šæ¨¡å¼ï¼šåŒæ­¥ CP å’Œ VP è®ŠåŒ–
  if (isOnlineMode) {
    syncGameStateToFirebase();
  }
}

async function startCommandPhase() {
  // æ¸…é™¤ä¹‹å‰çš„ç‰¹æ•ˆ
  clearAllVisualEffects();
  hideDiceOverlay();

  gameState.phase = "command";
  updatePhaseDisplay();

  const playerName = gameState.currentPlayer === 1 ?
    (ai1Enabled ? "AI-1" : "ç©å®¶ä¸€") :
    (ai2Enabled ? "AI-2" : "ç©å®¶äºŒ");
  log(`ã€${playerName}æŒ‡æ®éšæ®µé–‹å§‹ã€‘`, "phase");

  // æŒ‡æ®éšæ®µé–‹å§‹ï¼Œé›™æ–¹å„+1 CP
  gainCPAtCommandStart();

  // æ‡‰ç”¨å›åˆé–‹å§‹çš„å†ç”Ÿèƒ½åŠ›ï¼ˆæ´»é‡‘å±¬ç­‰ï¼‰
  applyRegenerationAbilities();

  // è¨ˆç®—ç›®æ¨™æ§åˆ¶ç‹€æ…‹
  computeObjectiveControl();

  // è¨ˆç®—VPç²å¾—
  const gain = scorePrimary(gameState.currentPlayer);
  const controlCount = gameState.objectives.filter(o => o.control === gameState.currentPlayer).length;
  const prevVP = gameState.vp[gameState.currentPlayer];
  gameState.vp[gameState.currentPlayer] += gain;
  updateVPDisplay();

  if (gain > 0) {
    log(`ğŸ† ${playerName}æ§åˆ¶ ${controlCount} å€‹ç›®æ¨™ â†’ +${gain} VP (ç¸½è¨ˆ: ${prevVP} â†’ ${gameState.vp[gameState.currentPlayer]})`, "phase");
    playSound('click');
  } else {
    log(`âš ï¸ ${playerName}æœªæ§åˆ¶ä»»ä½•ç›®æ¨™ï¼Œæœ¬å›åˆ+0 VP`, "info");
  }

  // é¡¯ç¤ºæˆ°ç•¥é¸æ“‡å½ˆçª—ï¼ˆç©å®¶æ§åˆ¶æ™‚ï¼Œæœ‰CPä¸”æœ‰æˆ°ç•¥æ™‚ï¼‰
  const isAI = (gameState.currentPlayer === 1 && ai1Enabled) || (gameState.currentPlayer === 2 && ai2Enabled);
  if (!isAI && gameState.cp[gameState.currentPlayer] >= 1) {
    try {
      await showStratagemPopup("command");
    } catch (e) {
      console.error("Stratagem popup error:", e);
    }
  }

  // æˆ°æ…„æ¸¬è©¦ Battle-shockï¼ˆå®˜æ–¹10ç‰ˆè¦å‰‡ï¼‰
  // ä½æ–¼åŠæ•¸å‚·å£çš„å–®ä½éœ€è¦æ¸¬è©¦
  const currentUnits = gameState.units.filter(u => u.player === gameState.currentPlayer && u.alive);
  for (const unit of currentUnits) {
    if (unit.currentHP <= unit.maxHP / 2) {
      const roll = rollD6() + rollD6(); // 2D6
      if (roll >= unit.stats.Ld) {
        unit.battleShocked = false;
        log(`${unit.name} æˆ°æ…„æ¸¬è©¦é€šé (${roll} â‰¥ ${unit.stats.Ld}+)`, "hit");
      } else {
        unit.battleShocked = true;
        log(`${unit.name} æˆ°æ…„ï¼OCè®Šç‚º0 (${roll} < ${unit.stats.Ld}+)`, "miss");
      }
    }
  }

  // Necrons å¾©æ´»å”è­°ï¼ˆå®˜æ–¹è¦å‰‡ï¼‰
  for (const unit of currentUnits) {
    if (unit.faction === "necrons" && unit.currentHP < unit.maxHP) {
      const healed = Math.min(rollD6() % 3 + 1, unit.maxHP - unit.currentHP); // D3
      unit.currentHP += healed;
      log(`${unit.name} å¾©æ´»å”è­°ï¼šæ¢å¾© ${healed} å‚·å£`, "hit");
    }
  }

  updateDeployButtons();  // ç¢ºä¿æŒ‰éˆ•ç‹€æ…‹æ­£ç¢º
  updateActionButtons();
  updateUnitLists();
  updateCPDisplay();
  render();
}

// ===== Objective Securedï¼ˆç›®æ¨™æ§åˆ¶å„ªå…ˆï¼‰- å®˜æ–¹10ç‰ˆè¦å‰‡ =====
// Battleline å–®ä½æ“æœ‰ Objective Securedï¼Œåœ¨OCå¹³æ‰‹æ™‚å„ªå…ˆç²å¾—æ§åˆ¶æ¬Š
function hasObjectiveSecured(unit) {
  if (!unit || !unit.alive) return false;
  // Battleline å–®ä½æœ‰ Objective Secured
  if (unit.keywords?.includes("Battleline")) return true;
  // æœ‰ç‰¹å®šèƒ½åŠ›çš„å–®ä½ä¹Ÿå¯èƒ½æœ‰
  if (unit.abilities?.some(a => a.includes("Objective Secured") || a.includes("ç›®æ¨™æ§åˆ¶å„ªå…ˆ"))) return true;
  return false;
}

function computeObjectiveControl() {
  const OBJ_RANGE = inchToPixels(3);
  let changes = [];

  for (const obj of gameState.objectives) {
    let oc1 = 0, oc2 = 0;
    let hasObjSec1 = false, hasObjSec2 = false;  // æ˜¯å¦æœ‰ Objective Secured å–®ä½
    let units1 = [], units2 = [];

    for (const unit of gameState.units) {
      if (!unit.alive) continue;
      const dist = Math.hypot(unit.x - obj.x, unit.y - obj.y);
      if (dist <= OBJ_RANGE) {
        // æˆ°æ…„ä¸­çš„å–®ä½OCç‚º0ï¼ˆå®˜æ–¹è¦å‰‡ï¼‰
        const effectiveOC = unit.battleShocked ? 0 : unit.stats.OC;
        const unitHasObjSec = hasObjectiveSecured(unit);

        if (unit.player === 1) {
          oc1 += effectiveOC;
          if (unitHasObjSec && effectiveOC > 0) hasObjSec1 = true;
          units1.push(unit.name + (unitHasObjSec ? "ğŸ”’" : ""));
        } else {
          oc2 += effectiveOC;
          if (unitHasObjSec && effectiveOC > 0) hasObjSec2 = true;
          units2.push(unit.name + (unitHasObjSec ? "ğŸ”’" : ""));
        }
      }
    }

    const prevControl = obj.control;

    // æ±ºå®šæ§åˆ¶æ¬Šï¼ˆå« Objective Secured è¦å‰‡ï¼‰
    if (oc1 > oc2) {
      obj.control = 1;
    } else if (oc2 > oc1) {
      obj.control = 2;
    } else if (oc1 === oc2 && oc1 > 0) {
      // OC å¹³æ‰‹æ™‚ï¼ŒObjective Secured æ±ºå®šå‹è² 
      if (hasObjSec1 && !hasObjSec2) {
        obj.control = 1;
        if (prevControl !== 1) {
          log(`ğŸ”’ ç©å®¶ä¸€çš„ Battleline å–®ä½æ“æœ‰ç›®æ¨™æ§åˆ¶å„ªå…ˆæ¬Šï¼`, "info");
        }
      } else if (hasObjSec2 && !hasObjSec1) {
        obj.control = 2;
        if (prevControl !== 2) {
          log(`ğŸ”’ ç©å®¶äºŒçš„ Battleline å–®ä½æ“æœ‰ç›®æ¨™æ§åˆ¶å„ªå…ˆæ¬Šï¼`, "info");
        }
      } else {
        // é›™æ–¹éƒ½æœ‰æˆ–éƒ½æ²’æœ‰ Objective Securedï¼Œç¶­æŒçˆ­å¥ª
        obj.control = null;
      }
    } else {
      obj.control = null;
    }

    // è¨˜éŒ„æ§åˆ¶æ¬Šè®ŠåŒ–
    if (prevControl !== obj.control) {
      if (obj.control === 1) {
        changes.push(`ğŸ´ ç©å®¶ä¸€ä½”é ˜ç›®æ¨™${obj.id} (OC: ${oc1} vs ${oc2})`);
        // æª¢æŸ¥æ¬¡è¦ä»»å‹™ï¼šä½”é ˜ç›®æ¨™
        checkSecondaryMissions(1, {
          type: "objectiveCaptured",
          objective: obj,
          previousControl: prevControl
        });
      } else if (obj.control === 2) {
        changes.push(`ğŸ´ ç©å®¶äºŒä½”é ˜ç›®æ¨™${obj.id} (OC: ${oc2} vs ${oc1})`);
        // æª¢æŸ¥æ¬¡è¦ä»»å‹™ï¼šä½”é ˜ç›®æ¨™
        checkSecondaryMissions(2, {
          type: "objectiveCaptured",
          objective: obj,
          previousControl: prevControl
        });
      } else if (prevControl !== null) {
        changes.push(`âš”ï¸ ç›®æ¨™${obj.id}è¢«çˆ­å¥ªä¸­ (OC: ${oc1} vs ${oc2})`);
      }
    }
  }

  // è¼¸å‡ºæ§åˆ¶æ¬Šè®ŠåŒ–
  changes.forEach(c => log(c, "info"));

  // é¡¯ç¤ºç•¶å‰ç›®æ¨™æ§åˆ¶ç‹€æ…‹
  const p1Count = gameState.objectives.filter(o => o.control === 1).length;
  const p2Count = gameState.objectives.filter(o => o.control === 2).length;
  const contested = gameState.objectives.filter(o => o.control === null).length;
  if (p1Count > 0 || p2Count > 0 || contested > 0) {
    log(`ğŸ“ ç›®æ¨™æ§åˆ¶ï¼šç©å®¶ä¸€ ${p1Count}å€‹ | ç©å®¶äºŒ ${p2Count}å€‹ | çˆ­å¥ªä¸­ ${contested}å€‹`, "info");
  }
}

function scorePrimary(player) {
  // ä½¿ç”¨ä¸»è¦ä»»å‹™çš„è¨ˆåˆ†è¦å‰‡
  if (gameState.primaryMission && PRIMARY_MISSIONS[gameState.primaryMission]) {
    return PRIMARY_MISSIONS[gameState.primaryMission].scoring(player);
  }
  // é è¨­è¨ˆåˆ†
  return Math.min(15, gameState.objectives.filter(o => o.control === player).length * 5);
}

async function nextPhase() {
  // ç·šä¸Šæ¨¡å¼ï¼šåªæœ‰ç•¶å‰å›åˆçš„ç©å®¶å¯ä»¥åˆ‡æ›éšæ®µ
  if (isOnlineMode && !isMyTurn()) {
    log('ç­‰å¾…å°æ‰‹å›åˆ...', 'info');
    return;
  }

  playSound('click');

  // æ¸…é™¤ä¸Šä¸€éšæ®µçš„è¦–è¦ºç‰¹æ•ˆ
  clearAllVisualEffects();
  hideDiceOverlay();

  const phases = ["command", "movement", "shooting", "charge", "fight"];
  const currentIndex = phases.indexOf(gameState.phase);

  if (currentIndex < phases.length - 1) {
    gameState.phase = phases[currentIndex + 1];
    log(`é€²å…¥ã€${getPhaseNameChinese(gameState.phase)}ã€‘`, "phase");

    // ç§»å‹•éšæ®µé–‹å§‹æ™‚æ›´æ–°æ‰€æœ‰å–®ä½çš„æ¥æˆ°ç‹€æ…‹
    if (gameState.phase === "movement") {
      updateAllEngagementStatus();
    }

    updatePhaseDisplay();
    updateActionButtons();
    updateDeployButtons();  // ç¢ºä¿æŒ‰éˆ•ç‹€æ…‹æ­£ç¢º

    // ç·šä¸Šæ¨¡å¼åŒæ­¥éšæ®µè®Šæ›´
    if (isOnlineMode) {
      syncGameStateToFirebase();
    }

    // é¡¯ç¤ºæˆ°ç•¥é¸æ“‡å½ˆçª—ï¼ˆç©å®¶æ§åˆ¶æ™‚ï¼‰
    const isAI = (gameState.currentPlayer === 1 && ai1Enabled) || (gameState.currentPlayer === 2 && ai2Enabled);
    if (!isAI && gameState.cp[gameState.currentPlayer] >= 1) {
      try {
        await showStratagemPopup(gameState.phase);
      } catch (e) {
        console.error("Stratagem popup error:", e);
      }
    }
  }
}

function endTurn() {
  // ç·šä¸Šæ¨¡å¼ï¼šåªæœ‰ç•¶å‰å›åˆçš„ç©å®¶å¯ä»¥çµæŸå›åˆ
  if (isOnlineMode && !isMyTurn()) {
    log('ç­‰å¾…å°æ‰‹å›åˆ...', 'info');
    return;
  }

  playSound('click');

  // é‡ç½®å›åˆé€²è¡Œä¸­æ¨™è¨˜ï¼Œé˜²æ­¢å¡ä½
  turnInProgress = false;

  // éš±è—æ”»æ“Šç¢ºèªæŒ‰éˆ•
  hideAttackConfirmButton();

  // æ¸…é™¤æ‰€æœ‰è¦–è¦ºç‰¹æ•ˆå’ŒUI
  clearAllUIEffects();

  // é‡ç½®å–®ä½ç‹€æ…‹
  gameState.units.forEach(u => {
    u.hasMoved = false;
    u.hasShot = false;
    u.hasCharged = false;
    u.hasFought = false;
    u.hasAdvanced = false;    // é‡ç½®æ€¥è¡Œç‹€æ…‹
    u.hasFallenBack = false;  // é‡ç½®æ’¤é€€ç‹€æ…‹
  });

  // æ›´æ–°æ‰€æœ‰å–®ä½çš„æ¥æˆ°ç‹€æ…‹
  updateAllEngagementStatus();

  // é‡ç½®æŒ‡æ®é‡æ“²
  gameState.pendingReroll = null;

  // åˆ‡æ›ç©å®¶
  gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;

  // å¦‚æœå›åˆ°ç©å®¶ä¸€ï¼Œæ–°å›åˆ
  if (gameState.currentPlayer === 1) {
    // ===== å›åˆçµæŸæ™‚æª¢æŸ¥æ¬¡è¦ä»»å‹™ =====
    // åœ¨å›åˆè®Šæ›´å‰ï¼Œæª¢æŸ¥å…©é‚Šç©å®¶çš„æ¬¡è¦ä»»å‹™å®Œæˆæƒ…æ³
    checkSecondaryMissions(1, { type: "endRound", round: gameState.round });
    checkSecondaryMissions(2, { type: "endRound", round: gameState.round });

    // é‡ç½®æ¯å›åˆè¨ˆæ•¸å™¨
    if (gameState.missionProgress) {
      gameState.missionProgress[1].killedThisRound = 0;
      gameState.missionProgress[2].killedThisRound = 0;
    }

    gameState.round++;
    document.getElementById("roundNum").textContent = gameState.round;
    document.getElementById("roundDisplay").textContent = gameState.round;

    // éŸ³æ•ˆï¼šæ–°å›åˆ
    playSound('roundStart');

    // æ–°å›åˆä¸å†æ¸…ç©ºæ—¥èªŒï¼Œä¿ç•™æ­·å²è¨˜éŒ„
    log(`â•â•â•â•â•â• ç¬¬ ${gameState.round} å›åˆé–‹å§‹ â•â•â•â•â•â•`, "phase");

    // ä¿ç•™æ­»äº¡å–®ä½å±é«”åœ¨æˆ°å ´ä¸Šï¼ˆä¸å†æ¸…é™¤ï¼‰
  }

  let playerName;
  if (gameState.currentPlayer === 1) {
    playerName = ai1Enabled ? "ğŸ¤– AI-1" : "ç©å®¶ä¸€";
  } else {
    playerName = ai2Enabled ? "ğŸ¤– AI-2" : "ç©å®¶äºŒ";
  }
  document.getElementById("currentPlayerName").textContent = playerName;

  // é¡¯ç¤ºç•¶å‰ç¨®æ—è¦å‰‡
  const det = playerDetachments[gameState.currentPlayer];
  document.getElementById("currentDetachment").textContent = det ? det.name : "";

  gameState.selectedUnit = null;
  clearAction();
  updateSelectedUnitInfo();
  updateUnitLists();
  updateCPDisplay();
  render();

  const currentName = gameState.currentPlayer === 1 ?
    (ai1Enabled ? "AI-1" : "ç©å®¶ä¸€") :
    (ai2Enabled ? "AI-2" : "ç©å®¶äºŒ");
  log(`=== ${currentName} å›åˆ ===`, "phase");

  // æ ¹æ“šæ˜¯å¦AIæ±ºå®šåŸ·è¡Œæ–¹å¼
  const isAITurn = (gameState.currentPlayer === 1 && ai1Enabled) || (gameState.currentPlayer === 2 && ai2Enabled);

  // ç·šä¸Šæ¨¡å¼è™•ç†
  if (isOnlineMode) {
    // è¨­å®š phase ç‚º command
    gameState.phase = "command";
    updatePhaseDisplay();

    // åŒæ­¥ç‹€æ…‹åˆ° Firebase
    sendAction({ type: 'endTurn' });
    syncGameStateToFirebase();

    console.warn('[endTurn] ç·šä¸Šæ¨¡å¼:', {
      currentPlayer: gameState.currentPlayer,
      myId: onlinePlayerId,
      isMyTurn: isMyTurn(),
      isAITurn: isAITurn,
      phase: gameState.phase
    });

    // å¦‚æœç¾åœ¨æ˜¯è‡ªå·±çš„å›åˆï¼Œé–‹å§‹è¡Œå‹•ï¼ˆæ›´æ–°è¿½è¹¤è®Šæ•¸é˜²æ­¢é‡è¤‡è§¸ç™¼ï¼‰
    if (isMyTurn()) {
      lastProcessedRound = gameState.round;
      lastProcessedPlayer = gameState.currentPlayer;
      turnInProgress = true;

      if (isAITurn) {
        setTimeout(async () => { await runAITurn(); turnInProgress = false; }, 500);
      } else {
        setTimeout(async () => { await executeCommandPhase(); turnInProgress = false; }, 100);
      }
    }
    // å°æ–¹çš„å›åˆï¼šç­‰å¾…å°æ–¹åŒæ­¥
    return;
  }

  // æœ¬åœ°æ¨¡å¼
  if (isAITurn) {
    // AIå›åˆï¼šç”±runAITurnè™•ç†æ‰€æœ‰éšæ®µ
    setTimeout(() => runAITurn(), 500);
  } else {
    // ç©å®¶å›åˆï¼šåŸ·è¡ŒæŒ‡æ®éšæ®µ
    startCommandPhase();
  }
}

function getPhaseNameChinese(phase) {
  const names = { deployment: "éƒ¨ç½²éšæ®µ", command: "æŒ‡æ®éšæ®µ", movement: "ç§»å‹•éšæ®µ", shooting: "å°„æ“Šéšæ®µ", charge: "è¡é‹’éšæ®µ", fight: "è¿‘æˆ°éšæ®µ" };
  return names[phase] || phase;
}

function updatePhaseDisplay() {
  document.querySelectorAll(".phase-pip").forEach(pip => {
    pip.classList.remove("active", "done");
    if (pip.dataset.phase === gameState.phase) pip.classList.add("active");
  });
  updateActionButtons();

  // æ›´æ–°æˆ°ç•¥é¢æ¿ï¼ˆå¦‚æœå·²å±•é–‹ï¼‰
  const stratagemPanel = document.getElementById("stratagemPanel");
  if (stratagemPanel && stratagemPanel.style.display !== "none") {
    updateStratagemPanel();
  }
}

function updateActionButtons() {
  const phase = gameState.phase;
  const unit = gameState.selectedUnit;
  const isMyUnit = unit && unit.player === gameState.currentPlayer;

  document.getElementById("btnMove").disabled = !(phase === "movement" && isMyUnit && !unit?.hasMoved && !unit?.inReserve && !unit?.isInEngagement);
  // æ€¥è¡ŒæŒ‰éˆ•ï¼šç§»å‹•éšæ®µã€æœªç§»å‹•ã€æœªæ¥æˆ°
  const btnAdvance = document.getElementById("btnAdvance");
  if (btnAdvance) {
    btnAdvance.disabled = !(phase === "movement" && isMyUnit && !unit?.hasMoved && !unit?.inReserve && !unit?.isInEngagement);
  }
  // æ’¤é€€æŒ‰éˆ•ï¼šç§»å‹•éšæ®µã€æœªç§»å‹•ã€å¿…é ˆåœ¨æ¥æˆ°ä¸­
  const btnFallBack = document.getElementById("btnFallBack");
  if (btnFallBack) {
    btnFallBack.disabled = !(phase === "movement" && isMyUnit && !unit?.hasMoved && unit?.isInEngagement);
    btnFallBack.style.display = unit?.isInEngagement ? "inline-block" : "none";
  }
  // å°„æ“ŠæŒ‰éˆ•ï¼šè€ƒæ…®æ€¥è¡Œå’Œæ’¤é€€é™åˆ¶
  let canShoot = phase === "shooting" && isMyUnit && !unit?.hasShot && !unit?.hasFallenBack;
  if (unit?.hasAdvanced && unit?.weapons?.ranged) {
    const hasAssault = unit.weapons.ranged.keywords?.some(k => k === "Assault" || k.startsWith("Assault "));
    canShoot = canShoot && hasAssault;
  }
  document.getElementById("btnShoot").disabled = !canShoot;
  // è¡é‹’æŒ‰éˆ•ï¼šè€ƒæ…®æ€¥è¡Œå’Œæ’¤é€€é™åˆ¶
  let canCharge = phase === "charge" && isMyUnit && !unit?.hasCharged && !unit?.hasFallenBack;
  if (unit?.hasAdvanced) {
    const canChargeAfterAdvance = unit.abilities?.some(a => a.includes("æ€¥è¡Œè¡é‹’") || a.includes("Assault") || a.includes("ç–¾é€Ÿ"));
    canCharge = canCharge && canChargeAfterAdvance;
  }
  document.getElementById("btnCharge").disabled = !canCharge;
  document.getElementById("btnFight").disabled = !(phase === "fight" && isMyUnit && !unit?.hasFought);

  // æ·±å…¥æ‰“æ“ŠæŒ‰éˆ•ï¼šç§»å‹•éšæ®µã€å›åˆ2+ã€æœ‰é å‚™éšŠä¸­çš„å–®ä½
  const hasReserveUnits = getReserveUnits(gameState.currentPlayer).length > 0;
  const canDeploy = phase === "movement" && canDeployFromReserves() && hasReserveUnits;
  const btnDeepStrike = document.getElementById("btnDeepStrike");
  if (btnDeepStrike) {
    btnDeepStrike.disabled = !canDeploy;
    btnDeepStrike.style.display = (hasReserveUnits || phase === "movement") ? "inline-block" : "none";
  }

  // ===== é‹è¼¸è¼‰å…·æŒ‰éˆ• =====
  const btnEmbark = document.getElementById("btnEmbark");
  const btnDisembark = document.getElementById("btnDisembark");

  if (btnEmbark) {
    // æ­è¼‰æŒ‰éˆ•ï¼šæ­¥å…µå–®ä½ã€ç§»å‹•éšæ®µã€é™„è¿‘æœ‰å¯æ­è¼‰çš„é‹è¼¸è¼‰å…·
    const isInfantry = unit?.keywords?.includes("Infantry");
    const nearbyTransports = isInfantry ? findNearbyTransports(unit) : [];
    const canEmbarkNow = phase === "movement" && isMyUnit && isInfantry &&
                         !unit?.hasMoved && !unit?.embarkedIn && nearbyTransports.length > 0;
    btnEmbark.disabled = !canEmbarkNow;
    btnEmbark.style.display = (isInfantry && nearbyTransports.length > 0) ? "inline-block" : "none";
  }

  if (btnDisembark) {
    // ä¸‹è»ŠæŒ‰éˆ•ï¼šé¸ä¸­çš„å–®ä½æ˜¯é‹è¼¸è¼‰å…·ä¸”æœ‰æ­è¼‰å–®ä½
    const hasEmbarkedUnits = unit?.embarkedUnits?.length > 0;
    const canDisembarkNow = phase === "movement" && isMyUnit && hasEmbarkedUnits && !unit?.hasMoved;
    btnDisembark.disabled = !canDisembarkNow;
    btnDisembark.style.display = hasEmbarkedUnits ? "inline-block" : "none";
  }

  // ===== é£›è¡Œå™¨æ‡¸åœæŒ‰éˆ• =====
  const btnHover = document.getElementById("btnHover");
  if (btnHover) {
    const canHoverNow = phase === "movement" && isMyUnit && isAircraft(unit) && canHover(unit);
    btnHover.disabled = !canHoverNow;
    btnHover.style.display = canHoverNow ? "inline-block" : "none";
    if (unit?.isHovering) {
      btnHover.textContent = "âœˆï¸ é£›è¡Œ";
      btnHover.title = "åˆ‡æ›å›é£›è¡Œæ¨¡å¼";
    } else {
      btnHover.textContent = "ğŸš æ‡¸åœ";
      btnHover.title = "é€²å…¥æ‡¸åœæ¨¡å¼";
    }
  }
}

// æ‰¾åˆ°é™„è¿‘å¯æ­è¼‰çš„é‹è¼¸è¼‰å…·
function findNearbyTransports(unit) {
  if (!unit) return [];
  const embarkRange = inchToPixels(3);
  return gameState.units.filter(t => {
    if (t.player !== unit.player || !t.alive || t.id === unit.id) return false;
    if (getTransportCapacity(t) <= 0) return false;
    const dist = Math.hypot(t.x - unit.x, t.y - unit.y);
    return dist <= embarkRange;
  });
}

// åˆ‡æ›é¸ä¸­å–®ä½çš„æ‡¸åœæ¨¡å¼
function toggleSelectedUnitHover() {
  const unit = gameState.selectedUnit;
  if (!unit || !canHover(unit)) return;
  toggleHoverMode(unit);
  updateActionButtons();
  render();
}

function updateVPDisplay() {
  document.getElementById("vp1Display").textContent = gameState.vp[1];
  document.getElementById("vp2Display").textContent = gameState.vp[2];
  document.getElementById("p1VPDisplay").textContent = gameState.vp[1];
  document.getElementById("p2VPDisplay").textContent = gameState.vp[2];
}

// ========== å‹åˆ©æª¢æŸ¥ ==========
function checkVictory() {
  const p1Alive = gameState.units.filter(u => u.player === 1 && u.alive).length;
  const p2Alive = gameState.units.filter(u => u.player === 2 && u.alive).length;

  if (p1Alive === 0) {
    const winner = ai2Enabled ? "ğŸ¤– AI-2" : "ç©å®¶äºŒ";
    const loser = ai1Enabled ? "AI-1" : "ç©å®¶ä¸€";
    playSound('victory'); // éŸ³æ•ˆï¼šå‹åˆ©
    log(`ğŸ† ${winner} å‹åˆ©ï¼`, "phase");
    if (ai1Enabled && ai2Enabled) {
      alert(`ğŸ¤– VS ğŸ¤– å°æˆ°çµæŸï¼\n${winner} æ“Šæ•—äº† ${loser}ï¼`);
    } else {
      alert(`éŠæˆ²çµæŸï¼${winner}å‹åˆ©ï¼`);
    }
  } else if (p2Alive === 0) {
    const winner = ai1Enabled ? "ğŸ¤– AI-1" : "ç©å®¶ä¸€";
    const loser = ai2Enabled ? "AI-2" : "ç©å®¶äºŒ";
    playSound('victory'); // éŸ³æ•ˆï¼šå‹åˆ©
    log(`ğŸ† ${winner} å‹åˆ©ï¼`, "phase");
    if (ai1Enabled && ai2Enabled) {
      alert(`ğŸ¤– VS ğŸ¤– å°æˆ°çµæŸï¼\n${winner} æ“Šæ•—äº† ${loser}ï¼`);
    } else if (ai2Enabled) {
      alert("ğŸ‰ æ­å–œï¼ä½ æ“Šæ•—äº†AIï¼");
    } else {
      alert(`éŠæˆ²çµæŸï¼${winner}å‹åˆ©ï¼`);
    }
  }
}

// ========== UI æ›´æ–° ==========
function updateUnitLists() {
  const list1 = document.getElementById("team1List");
  const list2 = document.getElementById("team2List");
  if (!list1 || !list2) return;

  list1.innerHTML = "";
  list2.innerHTML = "";

  if (!gameState.units || !Array.isArray(gameState.units)) return;

  gameState.units.forEach(unit => {
    // è·³éç„¡æ•ˆå–®ä½
    if (!unit || !unit.id || !unit.name) return;

    const container = unit.player === 1 ? list1 : list2;
    const hpPct = ((unit.currentHP || 0) / (unit.maxHP || 1)) * 100;

    let classes = "unit-item";
    if (!unit.alive) classes += " dead";
    if (unit.hasMoved && unit.hasShot && unit.hasFought) classes += " acted";
    if (gameState.selectedUnit?.id === unit.id) classes += " selected";
    // éƒ¨ç½²éšæ®µï¼šæ¨™è¨˜é¸ä¸­è¦éƒ¨ç½²çš„å–®ä½
    if (gameState.phase === "deployment" && gameState.selectedUnitForDeploy?.id === unit.id) {
      classes += " deploy-selected";
    }

    const div = document.createElement("div");
    div.className = classes;

    // éƒ¨ç½²éšæ®µï¼šæœªéƒ¨ç½²çš„è‡ªå·±å–®ä½å¯æ‹–æ›³
    const player = isOnlineMode ? onlinePlayerId : gameState.deploy.deployingPlayer;
    const canDrag = gameState.phase === "deployment" && !unit.deployed && unit.player === player;

    if (canDrag) {
      div.draggable = true;
      div.style.cursor = "grab";

      div.ondragstart = (e) => {
        gameState.selectedUnitForDeploy = unit;
        gameState.draggingFromPanel = true;
        e.dataTransfer.setData("text/plain", unit.id);
        e.dataTransfer.effectAllowed = "move";
        div.style.opacity = "0.5";
        playSound('select');
        log(`æ‹–æ›³éƒ¨ç½²: ${unit.name}`, "info");
      };

      div.ondragend = (e) => {
        div.style.opacity = "1";
        gameState.draggingFromPanel = false;
      };
    }

    div.onclick = () => {
      // éƒ¨ç½²éšæ®µï¼šé¸æ“‡è¦éƒ¨ç½²çš„å–®ä½
      if (gameState.phase === "deployment" && !unit.deployed) {
        const player = isOnlineMode ? onlinePlayerId : gameState.deploy.deployingPlayer;
        if (unit.player === player) {
          gameState.selectedUnitForDeploy = unit;
          playSound('select');
          log(`é¸æ“‡éƒ¨ç½²: ${unit.name}ï¼Œé»æ“Šæˆ°å ´æ”¾ç½®`, "info");
          updateUnitLists();
          updateSelectedUnitInfo();
        }
      } else {
        // å…¶ä»–éšæ®µï¼šæ­£å¸¸é¸æ“‡
        selectUnit(unit);
      }
    };
    div.title = `${unit.name}\nHP: ${unit.currentHP}/${unit.maxHP}\n${canDrag ? '(å¯æ‹–æ›³éƒ¨ç½²)' : ''}`;

    // ç‹€æ…‹åœ–æ¨™
    let statusIcon = "";
    if (gameState.phase === "deployment" && !unit.deployed) statusIcon = "ğŸ“";
    else if (unit.battleShocked) statusIcon = "ğŸ’€";
    else if (unit.inCover) statusIcon = "ğŸ›¡ï¸";
    else if (gameState.phase === "deployment" && unit.deployed) statusIcon = "âœ“";

    // ç°¡çŸ­åç¨±ï¼ˆå–å‰4å€‹å­—ï¼‰
    const shortName = unit.name.length > 6 ? unit.name.substring(0, 5) + ".." : unit.name;

    div.innerHTML = `
      ${statusIcon ? `<div class="unit-status-icon">${statusIcon}</div>` : ""}
      <div class="unit-avatar"><img src="${unit.img}" onerror="this.style.display='none'"></div>
      <div class="unit-info">
        <div class="unit-name">${shortName}</div>
        <div class="unit-hp-bar"><div class="unit-hp-fill" style="width: ${hpPct}%"></div></div>
      </div>
    `;
    container.appendChild(div);
  });

  const faction1 = UNIT_DATABASE[armyRosters[1][0]?.faction]?.name || "ç©å®¶ä¸€";
  const faction2 = UNIT_DATABASE[armyRosters[2][0]?.faction]?.name || "ç©å®¶äºŒ";
  const det1 = playerDetachments[1]?.name ? ` (${playerDetachments[1].name.split(' ')[0]})` : "";
  const det2 = playerDetachments[2]?.name ? ` (${playerDetachments[2].name.split(' ')[0]})` : "";
  document.getElementById("team1Label").textContent = faction1 + det1;
  document.getElementById("team2Label").textContent = faction2 + det2;
}

function highlightSelectedUnit() {
  document.querySelectorAll(".unit-item").forEach(item => item.classList.remove("selected"));
}

function log(message, type = "", sync = true) {
  const logContent = document.getElementById("logContent");
  if (!logContent) return;

  const entry = document.createElement("div");
  entry.className = `log-entry ${type}`;
  entry.textContent = message;
  logContent.appendChild(entry);

  // é™åˆ¶æ—¥èªŒæ¢ç›®æ•¸é‡ä»¥é˜²æ­¢lag
  const MAX_LOG_ENTRIES = 30;
  while (logContent.children.length > MAX_LOG_ENTRIES) {
    logContent.removeChild(logContent.firstChild);
  }

  logContent.scrollTop = logContent.scrollHeight;

  // ç·šä¸Šæ¨¡å¼åŒæ­¥ç´€éŒ„åˆ°å°æ‰‹
  if (sync && isOnlineMode && roomRef && isMyTurn()) {
    syncCombatLog(message, type);
  }
}

// æ¸…ç©ºæˆ°é¬¥æ—¥èªŒ
function clearLog() {
  const logContent = document.getElementById("logContent");
  if (logContent) {
    logContent.innerHTML = "";
  }
}

// åˆ‡æ›æˆ°é¬¥æ—¥èªŒé¡¯ç¤º
let combatLogVisible = true;
function toggleCombatLog() {
  const container = document.getElementById("combatLogContainer");
  const toggle = document.getElementById("combatLogToggle");
  if (!container) return;

  combatLogVisible = !combatLogVisible;
  if (combatLogVisible) {
    container.style.display = "block";
    toggle.textContent = "â–¼";
  } else {
    container.style.display = "none";
    toggle.textContent = "â–¶";
    // é—œé–‰æ™‚ä¸å†æ¸…ç©ºæ—¥èªŒ
  }
}

// æ¸…ç©ºæˆ°é¬¥æ—¥èªŒ
function clearCombatLog() {
  const logContent = document.getElementById("logContent");
  if (logContent) {
    logContent.innerHTML = "";
    log("æ—¥èªŒå·²æ¸…ç©º", "info");
  }
}

// æ·»åŠ å–®ä½æˆ°é¬¥æ­·å²è¨˜éŒ„
function addBattleHistory(unit, message, type = "info") {
  if (!unit) return;
  if (!unit.battleHistory) unit.battleHistory = [];

  unit.battleHistory.push({
    round: gameState.round,
    phase: gameState.phase,
    message: message,
    type: type,
    timestamp: Date.now()
  });
  // é™åˆ¶æ­·å²è¨˜éŒ„æ•¸é‡
  const MAX_HISTORY = 20;
  if (unit.battleHistory.length > MAX_HISTORY) {
    unit.battleHistory.shift();
  }

  // ç·šä¸Šæ¨¡å¼ï¼šç«‹å³åŒæ­¥æˆ°é¬¥æ­·å²
  if (isOnlineMode) {
    syncGameStateToFirebase();
  }
}

// ========== æ¸²æŸ“ ==========
let lastRenderTime = 0;
const TARGET_FPS = 30; // é™ä½ç›®æ¨™å¹€ç‡ä»¥æ¸›å°‘CPUä½¿ç”¨
const FRAME_TIME = 1000 / TARGET_FPS;

function render() {
  if (!ctx) return;

  // å¹€ç‡é™åˆ¶
  const now = performance.now();
  if (now - lastRenderTime < FRAME_TIME) {
    requestAnimationFrame(render);
    return;
  }
  lastRenderTime = now;

  // å®šæœŸæ¸…ç†è¨˜æ†¶é«”
  periodicCleanup();

  const w = gameState.canvasWidth || canvas.getBoundingClientRect().width;
  const h = gameState.canvasHeight || canvas.getBoundingClientRect().height;

  // æ¸…é™¤æ•´å€‹ç•«å¸ƒï¼ˆä½¿ç”¨canvaså¯¦éš›å°ºå¯¸ï¼Œä¸å—ç¸®æ”¾å½±éŸ¿ï¼‰
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®ç‚ºåŸå§‹è®Šæ›
  ctx.fillStyle = "#1a2a1a";
  ctx.fillRect(0, 0, canvas.width, canvas.height); // ä½¿ç”¨canvaså¯¦éš›åƒç´ å°ºå¯¸
  ctx.restore();

  // æ‡‰ç”¨ç¸®æ”¾å’Œå¹³ç§»
  ctx.save();
  ctx.setTransform(
    devicePixelRatio * viewZoom, 0,
    0, devicePixelRatio * viewZoom,
    viewOffsetX * devicePixelRatio,
    viewOffsetY * devicePixelRatio
  );

  // ç¹ªè£½ç¶²æ ¼ï¼ˆä½¿ç”¨çµ±ä¸€çš„ç¶²æ ¼å¤§å°å‡½æ•¸ï¼‰
  const gridSize = getGridSize();
  ctx.strokeStyle = "rgba(255,255,255,0.1)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let x = 0; x < w; x += gridSize) {
    ctx.moveTo(x, 0);
    ctx.lineTo(x, h);
  }
  for (let y = 0; y < h; y += gridSize) {
    ctx.moveTo(0, y);
    ctx.lineTo(w, y);
  }
  ctx.stroke();

  // ç¹ªè£½ç¶²æ ¼äº¤å‰é»ï¼ˆæ›´æ¸…æ™°çš„å®šä½åƒè€ƒï¼‰
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  for (let x = 0; x <= w; x += gridSize) {
    for (let y = 0; y <= h; y += gridSize) {
      ctx.beginPath();
      ctx.arc(x, y, Math.max(2, gridSize * 0.1), 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // ç¹ªè£½éƒ¨ç½²å€ï¼ˆéƒ¨ç½²éšæ®µæ™‚é¡¯ç¤ºï¼‰
  if (gameState.phase === "deployment") {
    // deployZone å·²ç¶“åŒ…å«ç¸®æ”¾ï¼Œç›´æ¥ä½¿ç”¨
    const deployZoneWidth = gameState.deployZone || inchToPixels(12);

    // ç©å®¶ä¸€éƒ¨ç½²å€ï¼ˆå·¦å´ï¼‰
    ctx.fillStyle = gameState.deploy.deployingPlayer === 1 ? "rgba(70, 130, 180, 0.3)" : "rgba(70, 130, 180, 0.1)";
    ctx.fillRect(0, 0, deployZoneWidth, h);
    ctx.strokeStyle = "rgba(70, 130, 180, 0.8)";
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, deployZoneWidth, h);

    // ç©å®¶äºŒéƒ¨ç½²å€ï¼ˆå³å´ï¼‰
    ctx.fillStyle = gameState.deploy.deployingPlayer === 2 ? "rgba(220, 80, 80, 0.3)" : "rgba(220, 80, 80, 0.1)";
    ctx.fillRect(w - deployZoneWidth, 0, deployZoneWidth, h);
    ctx.strokeStyle = "rgba(220, 80, 80, 0.8)";
    ctx.lineWidth = 2;
    ctx.strokeRect(w - deployZoneWidth, 0, deployZoneWidth, h);

    // æ¨™ç±¤
    ctx.font = "14px sans-serif";
    ctx.textAlign = "center";
    ctx.fillStyle = gameState.deploy.deployingPlayer === 1 ? "#4682B4" : "#666";
    ctx.fillText("ç©å®¶ä¸€éƒ¨ç½²å€", deployZoneWidth / 2, 20);
    ctx.fillStyle = gameState.deploy.deployingPlayer === 2 ? "#DC5050" : "#666";
    ctx.fillText("ç©å®¶äºŒéƒ¨ç½²å€", w - deployZoneWidth / 2, 20);

    // ç¹ªè£½æ‹–æ›³éƒ¨ç½²é è¦½
    const dragUnit = gameState.selectedUnitForDeploy;
    if (dragUnit && dragUnit.dragX !== undefined && dragUnit.dragY !== undefined) {
      const previewSize = getUnitBaseSize(dragUnit);
      const previewColor = dragUnit.player === 1 ? "rgba(59,130,246,0.6)" : "rgba(220,38,38,0.6)";

      // é è¦½åœ“å½¢
      ctx.beginPath();
      ctx.arc(dragUnit.dragX, dragUnit.dragY, previewSize, 0, Math.PI * 2);
      ctx.fillStyle = previewColor;
      ctx.fill();
      ctx.strokeStyle = "#fbbf24";
      ctx.lineWidth = 3;
      ctx.setLineDash([5, 5]);
      ctx.stroke();
      ctx.setLineDash([]);

      // é è¦½åç¨±
      ctx.font = "12px sans-serif";
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.fillText(dragUnit.name, dragUnit.dragX, dragUnit.dragY + previewSize + 15);
    }
  }

  // ç¹ªè£½åœ°å½¢
  for (const t of gameState.terrain) {
    ctx.fillStyle = TERRAIN_TYPES[t.type].color;
    ctx.globalAlpha = 0.6;
    ctx.fillRect(t.x - t.width/2, t.y - t.height/2, t.width, t.height);
    ctx.globalAlpha = 1;
    ctx.strokeStyle = TERRAIN_TYPES[t.type].color;
    ctx.lineWidth = 2;
    ctx.strokeRect(t.x - t.width/2, t.y - t.height/2, t.width, t.height);

    // æ¨™ç±¤
    ctx.font = "10px sans-serif";
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.fillText(TERRAIN_TYPES[t.type].name, t.x, t.y);
  }

  // ç¹ªè£½ç›®æ¨™é»
  const OBJ_RANGE = inchToPixels(3);
  for (const obj of gameState.objectives) {
    // æ§åˆ¶ç¯„åœ
    ctx.beginPath();
    ctx.arc(obj.x, obj.y, OBJ_RANGE, 0, Math.PI * 2);
    ctx.strokeStyle = obj.control === 1 ? "rgba(59,130,246,0.6)" :
                      obj.control === 2 ? "rgba(220,38,38,0.6)" :
                      "rgba(251,191,36,0.4)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // æ¨™è¨˜
    ctx.beginPath();
    ctx.arc(obj.x, obj.y, 12, 0, Math.PI * 2);
    ctx.fillStyle = obj.control === 1 ? "#3b82f6" :
                    obj.control === 2 ? "#dc2626" : "#fbbf24";
    ctx.fill();
    ctx.font = "bold 12px sans-serif";
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(obj.id.toString(), obj.x, obj.y);
  }

  // ç¹ªè£½ç§»å‹•/å°„æ“Šç¯„åœï¼ˆé¸ä¸­å–®ä½æ™‚è‡ªå‹•é¡¯ç¤ºï¼‰
  if (gameState.selectedUnit && gameState.selectedUnit.player === gameState.currentPlayer) {
    const unit = gameState.selectedUnit;
    const phase = gameState.phase;
    const action = gameState.currentAction;

    // æ ¹æ“šéšæ®µæˆ–å‹•ä½œæ±ºå®šé¡¯ç¤ºçš„ç¯„åœ
    let ranges = [];

    // ç§»å‹•ç¯„åœï¼ˆç§»å‹•éšæ®µæˆ–ç§»å‹•å‹•ä½œï¼‰
    if ((phase === "movement" || action === "move") && !unit.hasMoved) {
      ranges.push({ range: inchToPixels(unit.stats.M), color: "rgba(34,197,94,0.3)", label: "ç§»å‹•" });
    }

    // å°„æ“Šç¯„åœï¼ˆå°„æ“Šéšæ®µæˆ–å°„æ“Šå‹•ä½œï¼‰
    if ((phase === "shooting" || action === "shoot") && unit.weapons.ranged && !unit.hasShot) {
      ranges.push({ range: inchToPixels(unit.weapons.ranged.range), color: "rgba(251,191,36,0.2)", label: "å°„æ“Š" });
    }

    // è¡é‹’ç¯„åœï¼ˆè¡é‹’éšæ®µæˆ–è¡é‹’å‹•ä½œï¼‰
    if ((phase === "charge" || action === "charge") && !unit.hasCharged && !unit.battleShocked) {
      ranges.push({ range: inchToPixels(12), color: "rgba(220,38,38,0.2)", label: "è¡é‹’" });
    }

    // è¿‘æˆ°ç¯„åœï¼ˆè¿‘æˆ°éšæ®µï¼‰
    if ((phase === "fight" || action === "fight") && unit.weapons.melee && !unit.hasFought) {
      ranges.push({ range: inchToPixels(1.5), color: "rgba(168,85,247,0.3)", label: "è¿‘æˆ°" });
    }

    // ç¹ªè£½æ‰€æœ‰ç¯„åœ
    for (const r of ranges) {
      if (r.range > 0) {
        ctx.beginPath();
        ctx.arc(unit.x, unit.y, r.range, 0, Math.PI * 2);
        ctx.fillStyle = r.color;
        ctx.fill();
        ctx.strokeStyle = r.color.replace("0.2", "0.6").replace("0.3", "0.8");
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
  }

  // ç¹ªè£½å–®ä½
  for (const unit of gameState.units) {
    // è·³éç„¡æ•ˆå–®ä½ï¼ˆé˜²æ­¢æ¸²æŸ“éŒ¯èª¤å°è‡´æ‰€æœ‰å–®ä½æ¶ˆå¤±ï¼‰
    if (!unit || typeof unit.x !== 'number' || typeof unit.y !== 'number') {
      console.warn('[render] è·³éç„¡æ•ˆå–®ä½:', unit?.id);
      continue;
    }

    // éƒ¨ç½²éšæ®µåªé¡¯ç¤ºå·²éƒ¨ç½²çš„å–®ä½
    if (gameState.phase === "deployment" && !unit.deployed) continue;

    // å‹•æ…‹è¨ˆç®—åº•æ¿å¤§å°
    const BASE_SIZE = getUnitBaseSize(unit);

    ctx.globalAlpha = unit.alive !== false ? 1 : 0.3;

    const faction = UNIT_DATABASE[unit.faction];
    const color = faction?.color || (unit.player === 1 ? "#3b82f6" : "#dc2626");
    const isSelected = gameState.selectedUnit?.id === unit.id;

    // ===== å°éšŠå–®ä½ï¼šç¹ªè£½å€‹åˆ¥æ¨¡å‹ =====
    if (unit.isSquad && unit.models && unit.models.length > 1) {
      const modelSize = Math.max(10, BASE_SIZE * 0.45); // å°æ¨¡å‹å¤§å°ï¼ˆèˆ‡é–“è·è¨ˆç®—ä¸€è‡´ï¼‰
      const modelsAlive = unit.modelsAlive || unit.models.filter(m => m.alive).length;

      // ç¹ªè£½é€£è²«æ€§ç¯„åœ (2" åœ“åœˆ)
      if (isSelected) {
        ctx.beginPath();
        ctx.arc(unit.x, unit.y, inchToPixels(2) + BASE_SIZE, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(34,197,94,0.3)";
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // ç¹ªè£½æ¯å€‹æ¨¡å‹ - å…ˆç¢ºä¿åœ–ç‰‡å·²è¼‰å…¥
      if (!unitImageCache[unit.img]) {
        loadUnitImage(unit);
      }
      const squadImg = unitImageCache[unit.img];
      const hasSquadImg = squadImg && squadImg.complete && squadImg.naturalWidth > 0;

      unit.models.forEach((model, idx) => {
        if (!model.alive) return;

        const mx = unit.x + model.x - unit.models[0].x;
        const my = unit.y + model.y - unit.models[0].y;

        // æ¨¡å‹åº•åº§ï¼ˆç©å®¶é¡è‰²ï¼‰
        ctx.beginPath();
        ctx.arc(mx, my, modelSize + 2, 0, Math.PI * 2);
        ctx.fillStyle = unit.player === 1 ? "rgba(59,130,246,0.9)" : "rgba(220,38,38,0.9)";
        ctx.fill();

        // ç¹ªè£½æ¨¡å‹åœ–ç‰‡
        if (hasSquadImg) {
          ctx.save();
          ctx.beginPath();
          ctx.arc(mx, my, modelSize, 0, Math.PI * 2);
          ctx.clip();
          const imgSize = modelSize * 2;
          ctx.drawImage(squadImg, mx - modelSize, my - modelSize, imgSize, imgSize);
          ctx.restore();
        }

        // æ¨¡å‹é‚Šæ¡†
        ctx.beginPath();
        ctx.arc(mx, my, modelSize, 0, Math.PI * 2);
        ctx.strokeStyle = isSelected ? "#fbbf24" : "#000";
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // é ˜éšŠæ¨™è¨˜
        if (idx === 0) {
          ctx.beginPath();
          ctx.arc(mx, my, modelSize + 4, 0, Math.PI * 2);
          ctx.strokeStyle = "#fbbf24";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      });

      // ç¹ªè£½å–®ä½åç¨±å’Œæ¨¡å‹æ•¸é‡
      ctx.font = "bold 11px sans-serif";
      ctx.textAlign = "center";
      ctx.fillStyle = unit.player === 1 ? "rgba(59,130,246,0.9)" : "rgba(220,38,38,0.9)";
      const shortName = unit.name.length > 8 ? unit.name.substring(0, 7) + ".." : unit.name;
      ctx.fillRect(unit.x - 35, unit.y + BASE_SIZE + 5, 70, 16);
      ctx.fillStyle = "#fff";
      ctx.fillText(`${shortName} (${modelsAlive}/${unit.modelCount})`, unit.x, unit.y + BASE_SIZE + 17);

      ctx.globalAlpha = 1;
      continue; // è·³éåŸæœ¬çš„å–®ä¸€å–®ä½ç¹ªè£½
    }
    // ===== çµæŸå°éšŠç¹ªè£½ =====

    // é¸ä¸­å…‰ç’°
    if (isSelected) {
      ctx.beginPath();
      ctx.arc(unit.x, unit.y, BASE_SIZE + 6, 0, Math.PI * 2);
      ctx.strokeStyle = "#fbbf24";
      ctx.lineWidth = 3;
      ctx.setLineDash([4, 4]);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // ç©å®¶é¡è‰²åº•åœˆ
    ctx.beginPath();
    ctx.arc(unit.x, unit.y, BASE_SIZE + 2, 0, Math.PI * 2);
    ctx.fillStyle = unit.player === 1 ? "rgba(59,130,246,0.8)" : "rgba(220,38,38,0.8)";
    ctx.fill();

    // å˜—è©¦ç¹ªè£½å–®ä½åœ–åƒ
    const img = unitImageCache[unit.img];
    if (img && img.complete && img.naturalWidth > 0) {
      // å‰µå»ºåœ“å½¢è£åˆ‡è·¯å¾‘
      ctx.save();
      ctx.beginPath();
      ctx.arc(unit.x, unit.y, BASE_SIZE, 0, Math.PI * 2);
      ctx.clip();

      // ç¹ªè£½åœ–åƒ
      const imgSize = BASE_SIZE * 2;
      ctx.drawImage(img, unit.x - BASE_SIZE, unit.y - BASE_SIZE, imgSize, imgSize);
      ctx.restore();

      // åœ–åƒé‚Šæ¡†
      ctx.beginPath();
      ctx.arc(unit.x, unit.y, BASE_SIZE, 0, Math.PI * 2);
      ctx.strokeStyle = isSelected ? "#fbbf24" : "#000";
      ctx.lineWidth = 2;
      ctx.stroke();
    } else {
      // ç„¡åœ–åƒæ™‚é¡¯ç¤ºé¡è‰²åœ“å½¢å’Œé¦–å­—æ¯
      loadUnitImage(unit);
      ctx.beginPath();
      ctx.arc(unit.x, unit.y, BASE_SIZE, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.strokeStyle = isSelected ? "#fbbf24" : "#000";
      ctx.lineWidth = 2;
      ctx.stroke();

      // é¡¯ç¤ºé¦–å­—æ¯ï¼ˆæ ¹æ“šåº•æ¿å¤§å°èª¿æ•´å­—é«”ï¼‰
      const fontSize = Math.max(10, Math.min(20, BASE_SIZE * 0.7));
      ctx.font = `bold ${fontSize}px sans-serif`;
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(unit.name.charAt(0), unit.x, unit.y);
    }

    // HP ç’°ï¼ˆå¤–åœˆï¼‰
    const hpPct = unit.currentHP / unit.maxHP;
    const hpColor = hpPct > 0.5 ? "#22c55e" : hpPct > 0.25 ? "#f59e0b" : "#ef4444";
    ctx.beginPath();
    ctx.arc(unit.x, unit.y, BASE_SIZE + 5, -Math.PI/2, -Math.PI/2 + hpPct * Math.PI * 2);
    ctx.strokeStyle = hpColor;
    ctx.lineWidth = 3;
    ctx.stroke();

    // HP èƒŒæ™¯ç’°
    ctx.beginPath();
    ctx.arc(unit.x, unit.y, BASE_SIZE + 5, -Math.PI/2 + hpPct * Math.PI * 2, Math.PI * 1.5);
    ctx.strokeStyle = "rgba(100,100,100,0.3)";
    ctx.lineWidth = 3;
    ctx.stroke();

    // ç‹€æ…‹æ¨™è¨˜ - æ©è­·
    if (unit.inCover) {
      ctx.fillStyle = "#22c55e";
      ctx.beginPath();
      ctx.arc(unit.x + BASE_SIZE, unit.y - BASE_SIZE, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.font = "10px sans-serif";
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ğŸ›¡", unit.x + BASE_SIZE, unit.y - BASE_SIZE);
    }

    // ç‹€æ…‹æ¨™è¨˜ - æˆ°æ…„
    if (unit.battleShocked) {
      ctx.fillStyle = "#ef4444";
      ctx.beginPath();
      ctx.arc(unit.x - BASE_SIZE, unit.y - BASE_SIZE, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.font = "10px sans-serif";
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ğŸ’€", unit.x - BASE_SIZE, unit.y - BASE_SIZE);
    }

    // åç¨±æ¨™ç±¤ï¼ˆèƒŒæ™¯æ¡†ï¼‰
    ctx.font = "bold 10px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    const shortName = unit.name.split(" ")[0].slice(0, 8);
    const textWidth = ctx.measureText(shortName).width;

    // ç¹ªè£½åç¨±èƒŒæ™¯
    ctx.fillStyle = unit.player === 1 ? "rgba(59,130,246,0.85)" : "rgba(220,38,38,0.85)";
    ctx.fillRect(unit.x - textWidth/2 - 3, unit.y - BASE_SIZE - 18, textWidth + 6, 14);
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 0.5;
    ctx.strokeRect(unit.x - textWidth/2 - 3, unit.y - BASE_SIZE - 18, textWidth + 6, 14);

    // ç¹ªè£½åç¨±
    ctx.fillStyle = "#fff";
    ctx.fillText(shortName, unit.x, unit.y - BASE_SIZE - 16);

    // OCå€¼å’ŒHPé¡¯ç¤º
    const labelY = unit.y + BASE_SIZE + 6;
    ctx.font = "bold 9px sans-serif";
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(unit.x - 20, labelY - 2, 40, 12);

    ctx.fillStyle = "#fbbf24";
    ctx.textAlign = "center";
    ctx.fillText(`OC${unit.stats.OC} HP${unit.currentHP}`, unit.x, labelY);

    ctx.globalAlpha = 1;
  }

  // æ¸²æŸ“è¦–è¦ºç‰¹æ•ˆï¼ˆæ”»æ“Šå°„ç·šã€å‚·å®³æ•¸å­—ã€æŠ€èƒ½æ–‡å­—ï¼‰
  renderVisualEffects();

  // æ¢å¾©åŸå§‹è®Šæ›
  ctx.restore();

  requestAnimationFrame(render);
}

// åˆå§‹åŒ–
init();
</script>
</body>
</html>
